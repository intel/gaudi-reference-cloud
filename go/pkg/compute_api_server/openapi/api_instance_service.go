/*
compute.proto

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// InstanceServiceApiService InstanceServiceApi service
type InstanceServiceApiService service

type ApiInstanceServiceCreateRequest struct {
	ctx                    context.Context
	ApiService             *InstanceServiceApiService
	metadataCloudAccountId string
	body                   *InstanceServiceCreateRequest
}

func (r ApiInstanceServiceCreateRequest) Body(body InstanceServiceCreateRequest) ApiInstanceServiceCreateRequest {
	r.body = &body
	return r
}

func (r ApiInstanceServiceCreateRequest) Execute() (*ProtoInstance, *http.Response, error) {
	return r.ApiService.InstanceServiceCreateExecute(r)
}

/*
InstanceServiceCreate Launch a new baremetal or virtual machine instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@return ApiInstanceServiceCreateRequest
*/
func (a *InstanceServiceApiService) InstanceServiceCreate(ctx context.Context, metadataCloudAccountId string) ApiInstanceServiceCreateRequest {
	return ApiInstanceServiceCreateRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
	}
}

// Execute executes the request
//
//	@return ProtoInstance
func (a *InstanceServiceApiService) InstanceServiceCreateExecute(r ApiInstanceServiceCreateRequest) (*ProtoInstance, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceDeleteRequest struct {
	ctx                     context.Context
	ApiService              *InstanceServiceApiService
	metadataCloudAccountId  string
	metadataResourceId      string
	metadataName            *string
	metadataResourceVersion *string
	metadataReserved1       *string
}

func (r ApiInstanceServiceDeleteRequest) MetadataName(metadataName string) ApiInstanceServiceDeleteRequest {
	r.metadataName = &metadataName
	return r
}

// If provided, the existing record must have this resourceVersion for the request to succeed.
func (r ApiInstanceServiceDeleteRequest) MetadataResourceVersion(metadataResourceVersion string) ApiInstanceServiceDeleteRequest {
	r.metadataResourceVersion = &metadataResourceVersion
	return r
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceServiceDeleteRequest) MetadataReserved1(metadataReserved1 string) ApiInstanceServiceDeleteRequest {
	r.metadataReserved1 = &metadataReserved1
	return r
}

func (r ApiInstanceServiceDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceServiceDeleteExecute(r)
}

/*
InstanceServiceDelete Request deletion (termination) of an instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataResourceId
	@return ApiInstanceServiceDeleteRequest
*/
func (a *InstanceServiceApiService) InstanceServiceDelete(ctx context.Context, metadataCloudAccountId string, metadataResourceId string) ApiInstanceServiceDeleteRequest {
	return ApiInstanceServiceDeleteRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataResourceId:     metadataResourceId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceServiceApiService) InstanceServiceDeleteExecute(r ApiInstanceServiceDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/id/{metadata.resourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.resourceId"+"}", url.PathEscape(parameterToString(r.metadataResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataName != nil {
		localVarQueryParams.Add("metadata.name", parameterToString(*r.metadataName, ""))
	}
	if r.metadataResourceVersion != nil {
		localVarQueryParams.Add("metadata.resourceVersion", parameterToString(*r.metadataResourceVersion, ""))
	}
	if r.metadataReserved1 != nil {
		localVarQueryParams.Add("metadata.reserved1", parameterToString(*r.metadataReserved1, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceDelete2Request struct {
	ctx                     context.Context
	ApiService              *InstanceServiceApiService
	metadataCloudAccountId  string
	metadataName            string
	metadataResourceId      *string
	metadataResourceVersion *string
	metadataReserved1       *string
}

func (r ApiInstanceServiceDelete2Request) MetadataResourceId(metadataResourceId string) ApiInstanceServiceDelete2Request {
	r.metadataResourceId = &metadataResourceId
	return r
}

// If provided, the existing record must have this resourceVersion for the request to succeed.
func (r ApiInstanceServiceDelete2Request) MetadataResourceVersion(metadataResourceVersion string) ApiInstanceServiceDelete2Request {
	r.metadataResourceVersion = &metadataResourceVersion
	return r
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceServiceDelete2Request) MetadataReserved1(metadataReserved1 string) ApiInstanceServiceDelete2Request {
	r.metadataReserved1 = &metadataReserved1
	return r
}

func (r ApiInstanceServiceDelete2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceServiceDelete2Execute(r)
}

/*
InstanceServiceDelete2 Request deletion (termination) of an instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@return ApiInstanceServiceDelete2Request
*/
func (a *InstanceServiceApiService) InstanceServiceDelete2(ctx context.Context, metadataCloudAccountId string, metadataName string) ApiInstanceServiceDelete2Request {
	return ApiInstanceServiceDelete2Request{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceServiceApiService) InstanceServiceDelete2Execute(r ApiInstanceServiceDelete2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceDelete2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/name/{metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataResourceId != nil {
		localVarQueryParams.Add("metadata.resourceId", parameterToString(*r.metadataResourceId, ""))
	}
	if r.metadataResourceVersion != nil {
		localVarQueryParams.Add("metadata.resourceVersion", parameterToString(*r.metadataResourceVersion, ""))
	}
	if r.metadataReserved1 != nil {
		localVarQueryParams.Add("metadata.reserved1", parameterToString(*r.metadataReserved1, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceGetRequest struct {
	ctx                     context.Context
	ApiService              *InstanceServiceApiService
	metadataCloudAccountId  string
	metadataResourceId      string
	metadataName            *string
	metadataResourceVersion *string
	metadataReserved1       *string
}

func (r ApiInstanceServiceGetRequest) MetadataName(metadataName string) ApiInstanceServiceGetRequest {
	r.metadataName = &metadataName
	return r
}

// If provided, the existing record must have this resourceVersion for the request to succeed.
func (r ApiInstanceServiceGetRequest) MetadataResourceVersion(metadataResourceVersion string) ApiInstanceServiceGetRequest {
	r.metadataResourceVersion = &metadataResourceVersion
	return r
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceServiceGetRequest) MetadataReserved1(metadataReserved1 string) ApiInstanceServiceGetRequest {
	r.metadataReserved1 = &metadataReserved1
	return r
}

func (r ApiInstanceServiceGetRequest) Execute() (*ProtoInstance, *http.Response, error) {
	return r.ApiService.InstanceServiceGetExecute(r)
}

/*
InstanceServiceGet Get the status of an instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataResourceId
	@return ApiInstanceServiceGetRequest
*/
func (a *InstanceServiceApiService) InstanceServiceGet(ctx context.Context, metadataCloudAccountId string, metadataResourceId string) ApiInstanceServiceGetRequest {
	return ApiInstanceServiceGetRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataResourceId:     metadataResourceId,
	}
}

// Execute executes the request
//
//	@return ProtoInstance
func (a *InstanceServiceApiService) InstanceServiceGetExecute(r ApiInstanceServiceGetRequest) (*ProtoInstance, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/id/{metadata.resourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.resourceId"+"}", url.PathEscape(parameterToString(r.metadataResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataName != nil {
		localVarQueryParams.Add("metadata.name", parameterToString(*r.metadataName, ""))
	}
	if r.metadataResourceVersion != nil {
		localVarQueryParams.Add("metadata.resourceVersion", parameterToString(*r.metadataResourceVersion, ""))
	}
	if r.metadataReserved1 != nil {
		localVarQueryParams.Add("metadata.reserved1", parameterToString(*r.metadataReserved1, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceGet2Request struct {
	ctx                     context.Context
	ApiService              *InstanceServiceApiService
	metadataCloudAccountId  string
	metadataName            string
	metadataResourceId      *string
	metadataResourceVersion *string
	metadataReserved1       *string
}

func (r ApiInstanceServiceGet2Request) MetadataResourceId(metadataResourceId string) ApiInstanceServiceGet2Request {
	r.metadataResourceId = &metadataResourceId
	return r
}

// If provided, the existing record must have this resourceVersion for the request to succeed.
func (r ApiInstanceServiceGet2Request) MetadataResourceVersion(metadataResourceVersion string) ApiInstanceServiceGet2Request {
	r.metadataResourceVersion = &metadataResourceVersion
	return r
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceServiceGet2Request) MetadataReserved1(metadataReserved1 string) ApiInstanceServiceGet2Request {
	r.metadataReserved1 = &metadataReserved1
	return r
}

func (r ApiInstanceServiceGet2Request) Execute() (*ProtoInstance, *http.Response, error) {
	return r.ApiService.InstanceServiceGet2Execute(r)
}

/*
InstanceServiceGet2 Get the status of an instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@return ApiInstanceServiceGet2Request
*/
func (a *InstanceServiceApiService) InstanceServiceGet2(ctx context.Context, metadataCloudAccountId string, metadataName string) ApiInstanceServiceGet2Request {
	return ApiInstanceServiceGet2Request{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
	}
}

// Execute executes the request
//
//	@return ProtoInstance
func (a *InstanceServiceApiService) InstanceServiceGet2Execute(r ApiInstanceServiceGet2Request) (*ProtoInstance, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceGet2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/name/{metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataResourceId != nil {
		localVarQueryParams.Add("metadata.resourceId", parameterToString(*r.metadataResourceId, ""))
	}
	if r.metadataResourceVersion != nil {
		localVarQueryParams.Add("metadata.resourceVersion", parameterToString(*r.metadataResourceVersion, ""))
	}
	if r.metadataReserved1 != nil {
		localVarQueryParams.Add("metadata.reserved1", parameterToString(*r.metadataReserved1, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServicePingRequest struct {
	ctx        context.Context
	ApiService *InstanceServiceApiService
	body       *map[string]interface{}
}

func (r ApiInstanceServicePingRequest) Body(body map[string]interface{}) ApiInstanceServicePingRequest {
	r.body = &body
	return r
}

func (r ApiInstanceServicePingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceServicePingExecute(r)
}

/*
InstanceServicePing Ping always returns a successful response by the service implementation. It can be used for testing connectivity to the service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInstanceServicePingRequest
*/
func (a *InstanceServiceApiService) InstanceServicePing(ctx context.Context) ApiInstanceServicePingRequest {
	return ApiInstanceServicePingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceServiceApiService) InstanceServicePingExecute(r ApiInstanceServicePingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServicePing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proto.InstanceService/Ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceSearchRequest struct {
	ctx                         context.Context
	ApiService                  *InstanceServiceApiService
	metadataCloudAccountId      string
	metadataReserved1           *string
	metadataInstanceGroup       *string
	metadataInstanceGroupFilter *string
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceServiceSearchRequest) MetadataReserved1(metadataReserved1 string) ApiInstanceServiceSearchRequest {
	r.metadataReserved1 = &metadataReserved1
	return r
}

// If instanceGroupFilter is ExactValue, return instances in this instance group. Otherwise, this field is ignored
func (r ApiInstanceServiceSearchRequest) MetadataInstanceGroup(metadataInstanceGroup string) ApiInstanceServiceSearchRequest {
	r.metadataInstanceGroup = &metadataInstanceGroup
	return r
}

// Filter instances by instance group. If Default, this behaves like Empty and returns instances that are not in any instance group.   - Default: Use the default behavior, which is described in the specific SearchFilterCriteria field.  - Any: Return records with any value in this field (including empty).  - Empty: Return records with an empty value in this field  - NonEmpty: Return records with a non-empty value in this field  - ExactValue: Return records with an exact value in this field
func (r ApiInstanceServiceSearchRequest) MetadataInstanceGroupFilter(metadataInstanceGroupFilter string) ApiInstanceServiceSearchRequest {
	r.metadataInstanceGroupFilter = &metadataInstanceGroupFilter
	return r
}

func (r ApiInstanceServiceSearchRequest) Execute() (*ProtoInstanceSearchResponse, *http.Response, error) {
	return r.ApiService.InstanceServiceSearchExecute(r)
}

/*
InstanceServiceSearch List instances.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@return ApiInstanceServiceSearchRequest
*/
func (a *InstanceServiceApiService) InstanceServiceSearch(ctx context.Context, metadataCloudAccountId string) ApiInstanceServiceSearchRequest {
	return ApiInstanceServiceSearchRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
	}
}

// Execute executes the request
//
//	@return ProtoInstanceSearchResponse
func (a *InstanceServiceApiService) InstanceServiceSearchExecute(r ApiInstanceServiceSearchRequest) (*ProtoInstanceSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstanceSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataReserved1 != nil {
		localVarQueryParams.Add("metadata.reserved1", parameterToString(*r.metadataReserved1, ""))
	}
	if r.metadataInstanceGroup != nil {
		localVarQueryParams.Add("metadata.instanceGroup", parameterToString(*r.metadataInstanceGroup, ""))
	}
	if r.metadataInstanceGroupFilter != nil {
		localVarQueryParams.Add("metadata.instanceGroupFilter", parameterToString(*r.metadataInstanceGroupFilter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceSearch2Request struct {
	ctx                    context.Context
	ApiService             *InstanceServiceApiService
	metadataCloudAccountId string
	body                   *InstanceServiceSearch2Request
}

func (r ApiInstanceServiceSearch2Request) Body(body InstanceServiceSearch2Request) ApiInstanceServiceSearch2Request {
	r.body = &body
	return r
}

func (r ApiInstanceServiceSearch2Request) Execute() (*ProtoInstanceSearchResponse, *http.Response, error) {
	return r.ApiService.InstanceServiceSearch2Execute(r)
}

/*
InstanceServiceSearch2 List instances.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@return ApiInstanceServiceSearch2Request
*/
func (a *InstanceServiceApiService) InstanceServiceSearch2(ctx context.Context, metadataCloudAccountId string) ApiInstanceServiceSearch2Request {
	return ApiInstanceServiceSearch2Request{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
	}
}

// Execute executes the request
//
//	@return ProtoInstanceSearchResponse
func (a *InstanceServiceApiService) InstanceServiceSearch2Execute(r ApiInstanceServiceSearch2Request) (*ProtoInstanceSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstanceSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceSearch2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/search"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceUpdateRequest struct {
	ctx                    context.Context
	ApiService             *InstanceServiceApiService
	metadataCloudAccountId string
	metadataResourceId     string
	body                   *InstanceServiceUpdateRequest
}

func (r ApiInstanceServiceUpdateRequest) Body(body InstanceServiceUpdateRequest) ApiInstanceServiceUpdateRequest {
	r.body = &body
	return r
}

func (r ApiInstanceServiceUpdateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceServiceUpdateExecute(r)
}

/*
InstanceServiceUpdate Update the specification of an instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataResourceId
	@return ApiInstanceServiceUpdateRequest
*/
func (a *InstanceServiceApiService) InstanceServiceUpdate(ctx context.Context, metadataCloudAccountId string, metadataResourceId string) ApiInstanceServiceUpdateRequest {
	return ApiInstanceServiceUpdateRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataResourceId:     metadataResourceId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceServiceApiService) InstanceServiceUpdateExecute(r ApiInstanceServiceUpdateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/id/{metadata.resourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.resourceId"+"}", url.PathEscape(parameterToString(r.metadataResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceServiceUpdate2Request struct {
	ctx                    context.Context
	ApiService             *InstanceServiceApiService
	metadataCloudAccountId string
	metadataName           string
	body                   *InstanceServiceUpdate2Request
}

func (r ApiInstanceServiceUpdate2Request) Body(body InstanceServiceUpdate2Request) ApiInstanceServiceUpdate2Request {
	r.body = &body
	return r
}

func (r ApiInstanceServiceUpdate2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceServiceUpdate2Execute(r)
}

/*
InstanceServiceUpdate2 Update the specification of an instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@return ApiInstanceServiceUpdate2Request
*/
func (a *InstanceServiceApiService) InstanceServiceUpdate2(ctx context.Context, metadataCloudAccountId string, metadataName string) ApiInstanceServiceUpdate2Request {
	return ApiInstanceServiceUpdate2Request{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceServiceApiService) InstanceServiceUpdate2Execute(r ApiInstanceServiceUpdate2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceServiceApiService.InstanceServiceUpdate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instances/name/{metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
