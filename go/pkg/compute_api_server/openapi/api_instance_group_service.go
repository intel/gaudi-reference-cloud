/*
compute.proto

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// InstanceGroupServiceApiService InstanceGroupServiceApi service
type InstanceGroupServiceApiService service

type ApiInstanceGroupServiceCreateRequest struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
	body                   *InstanceGroupServiceCreateRequest
}

func (r ApiInstanceGroupServiceCreateRequest) Body(body InstanceGroupServiceCreateRequest) ApiInstanceGroupServiceCreateRequest {
	r.body = &body
	return r
}

func (r ApiInstanceGroupServiceCreateRequest) Execute() (*ProtoInstanceGroup, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceCreateExecute(r)
}

/*
InstanceGroupServiceCreate Launch a new group of instances.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@return ApiInstanceGroupServiceCreateRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceCreate(ctx context.Context, metadataCloudAccountId string) ApiInstanceGroupServiceCreateRequest {
	return ApiInstanceGroupServiceCreateRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
	}
}

// Execute executes the request
//
//	@return ProtoInstanceGroup
func (a *InstanceGroupServiceApiService) InstanceGroupServiceCreateExecute(r ApiInstanceGroupServiceCreateRequest) (*ProtoInstanceGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstanceGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServiceDeleteRequest struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
	metadataName           string
}

func (r ApiInstanceGroupServiceDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceDeleteExecute(r)
}

/*
InstanceGroupServiceDelete Request deletion (termination) of an instance group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@return ApiInstanceGroupServiceDeleteRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceDelete(ctx context.Context, metadataCloudAccountId string, metadataName string) ApiInstanceGroupServiceDeleteRequest {
	return ApiInstanceGroupServiceDeleteRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceGroupServiceApiService) InstanceGroupServiceDeleteExecute(r ApiInstanceGroupServiceDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups/name/{metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServiceDeleteMemberRequest struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
	metadataName           string
	instanceResourceId     string
	metadataReserved2      *string
	instanceName           *string
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceGroupServiceDeleteMemberRequest) MetadataReserved2(metadataReserved2 string) ApiInstanceGroupServiceDeleteMemberRequest {
	r.metadataReserved2 = &metadataReserved2
	return r
}

func (r ApiInstanceGroupServiceDeleteMemberRequest) InstanceName(instanceName string) ApiInstanceGroupServiceDeleteMemberRequest {
	r.instanceName = &instanceName
	return r
}

func (r ApiInstanceGroupServiceDeleteMemberRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceDeleteMemberExecute(r)
}

/*
InstanceGroupServiceDeleteMember Request deletion (termination) of an instance in a group. It always retains at least one instance in the group to use a template. To delete the entire group, use Delete API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@param instanceResourceId
	@return ApiInstanceGroupServiceDeleteMemberRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceDeleteMember(ctx context.Context, metadataCloudAccountId string, metadataName string, instanceResourceId string) ApiInstanceGroupServiceDeleteMemberRequest {
	return ApiInstanceGroupServiceDeleteMemberRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
		instanceResourceId:     instanceResourceId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceGroupServiceApiService) InstanceGroupServiceDeleteMemberExecute(r ApiInstanceGroupServiceDeleteMemberRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceDeleteMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups/name/{metadata.name}/instance/id/{instanceResourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceResourceId"+"}", url.PathEscape(parameterToString(r.instanceResourceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataReserved2 != nil {
		localVarQueryParams.Add("metadata.reserved2", parameterToString(*r.metadataReserved2, ""))
	}
	if r.instanceName != nil {
		localVarQueryParams.Add("instanceName", parameterToString(*r.instanceName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServiceDeleteMember2Request struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
	metadataName           string
	instanceName           string
	metadataReserved2      *string
	instanceResourceId     *string
}

// Reserved. Added this field to overcome openAPi-same-struct issue.
func (r ApiInstanceGroupServiceDeleteMember2Request) MetadataReserved2(metadataReserved2 string) ApiInstanceGroupServiceDeleteMember2Request {
	r.metadataReserved2 = &metadataReserved2
	return r
}

func (r ApiInstanceGroupServiceDeleteMember2Request) InstanceResourceId(instanceResourceId string) ApiInstanceGroupServiceDeleteMember2Request {
	r.instanceResourceId = &instanceResourceId
	return r
}

func (r ApiInstanceGroupServiceDeleteMember2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceDeleteMember2Execute(r)
}

/*
InstanceGroupServiceDeleteMember2 Request deletion (termination) of an instance in a group. It always retains at least one instance in the group to use a template. To delete the entire group, use Delete API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@param instanceName
	@return ApiInstanceGroupServiceDeleteMember2Request
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceDeleteMember2(ctx context.Context, metadataCloudAccountId string, metadataName string, instanceName string) ApiInstanceGroupServiceDeleteMember2Request {
	return ApiInstanceGroupServiceDeleteMember2Request{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
		instanceName:           instanceName,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceGroupServiceApiService) InstanceGroupServiceDeleteMember2Execute(r ApiInstanceGroupServiceDeleteMember2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceDeleteMember2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups/name/{metadata.name}/instance/name/{instanceName}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceName"+"}", url.PathEscape(parameterToString(r.instanceName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataReserved2 != nil {
		localVarQueryParams.Add("metadata.reserved2", parameterToString(*r.metadataReserved2, ""))
	}
	if r.instanceResourceId != nil {
		localVarQueryParams.Add("instanceResourceId", parameterToString(*r.instanceResourceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServicePingRequest struct {
	ctx        context.Context
	ApiService *InstanceGroupServiceApiService
	body       *map[string]interface{}
}

func (r ApiInstanceGroupServicePingRequest) Body(body map[string]interface{}) ApiInstanceGroupServicePingRequest {
	r.body = &body
	return r
}

func (r ApiInstanceGroupServicePingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceGroupServicePingExecute(r)
}

/*
InstanceGroupServicePing Ping always returns a successful response by the service implementation. It can be used for testing connectivity to the service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInstanceGroupServicePingRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServicePing(ctx context.Context) ApiInstanceGroupServicePingRequest {
	return ApiInstanceGroupServicePingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceGroupServiceApiService) InstanceGroupServicePingExecute(r ApiInstanceGroupServicePingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServicePing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/proto.InstanceGroupService/Ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServiceScaleUpRequest struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
	metadataName           string
	body                   *InstanceGroupServiceScaleUpRequest
}

func (r ApiInstanceGroupServiceScaleUpRequest) Body(body InstanceGroupServiceScaleUpRequest) ApiInstanceGroupServiceScaleUpRequest {
	r.body = &body
	return r
}

func (r ApiInstanceGroupServiceScaleUpRequest) Execute() (*ProtoInstanceGroupScaleResponse, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceScaleUpExecute(r)
}

/*
InstanceGroupServiceScaleUp Create new instances for the group to reach to the desired count. This returns an error if the desired count is less than the current count.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@return ApiInstanceGroupServiceScaleUpRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceScaleUp(ctx context.Context, metadataCloudAccountId string, metadataName string) ApiInstanceGroupServiceScaleUpRequest {
	return ApiInstanceGroupServiceScaleUpRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
	}
}

// Execute executes the request
//
//	@return ProtoInstanceGroupScaleResponse
func (a *InstanceGroupServiceApiService) InstanceGroupServiceScaleUpExecute(r ApiInstanceGroupServiceScaleUpRequest) (*ProtoInstanceGroupScaleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstanceGroupScaleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceScaleUp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups/name/{metadata.name}/scale-up"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServiceSearchRequest struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
}

func (r ApiInstanceGroupServiceSearchRequest) Execute() (*ProtoInstanceGroupSearchResponse, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceSearchExecute(r)
}

/*
InstanceGroupServiceSearch List instance groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@return ApiInstanceGroupServiceSearchRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceSearch(ctx context.Context, metadataCloudAccountId string) ApiInstanceGroupServiceSearchRequest {
	return ApiInstanceGroupServiceSearchRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
	}
}

// Execute executes the request
//
//	@return ProtoInstanceGroupSearchResponse
func (a *InstanceGroupServiceApiService) InstanceGroupServiceSearchExecute(r ApiInstanceGroupServiceSearchRequest) (*ProtoInstanceGroupSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtoInstanceGroupSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInstanceGroupServiceUpdateRequest struct {
	ctx                    context.Context
	ApiService             *InstanceGroupServiceApiService
	metadataCloudAccountId string
	metadataName           string
	body                   *InstanceGroupServiceUpdateRequest
}

func (r ApiInstanceGroupServiceUpdateRequest) Body(body InstanceGroupServiceUpdateRequest) ApiInstanceGroupServiceUpdateRequest {
	r.body = &body
	return r
}

func (r ApiInstanceGroupServiceUpdateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InstanceGroupServiceUpdateExecute(r)
}

/*
InstanceGroupServiceUpdate Update the specification of an instanceGroup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param metadataCloudAccountId
	@param metadataName
	@return ApiInstanceGroupServiceUpdateRequest
*/
func (a *InstanceGroupServiceApiService) InstanceGroupServiceUpdate(ctx context.Context, metadataCloudAccountId string, metadataName string) ApiInstanceGroupServiceUpdateRequest {
	return ApiInstanceGroupServiceUpdateRequest{
		ApiService:             a,
		ctx:                    ctx,
		metadataCloudAccountId: metadataCloudAccountId,
		metadataName:           metadataName,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *InstanceGroupServiceApiService) InstanceGroupServiceUpdateExecute(r ApiInstanceGroupServiceUpdateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceGroupServiceApiService.InstanceGroupServiceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cloudaccounts/{metadata.cloudAccountId}/instancegroups/name/{metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.cloudAccountId"+"}", url.PathEscape(parameterToString(r.metadataCloudAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metadata.name"+"}", url.PathEscape(parameterToString(r.metadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	closeErr := localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if closeErr != nil {
		return localVarReturnValue, localVarHTTPResponse, closeErr
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
