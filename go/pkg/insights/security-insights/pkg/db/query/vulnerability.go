// INTEL CONFIDENTIAL
// Copyright (C) 2023 Intel Corporation
package query

import (
	"context"
	"database/sql"
	"strings"
	"time"

	"github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/log"
	"github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/pb"
	v1 "github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/pb"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	insertVulnerabilityScan = `
		WITH rid AS(
			select id 
			from k8s_release
			where version = $1
		),
		cid AS(
			select id 
			from k8s_release_components
			WHERE name = $2 AND version = $3 AND release_id = (select id from rid)
		)
		insert into vulnerability_scan_schedule (release_id, component_id, scan_tool, scan_at)
		values ((select id from rid), (select id from cid), $4, $5)
		RETURNING id
	`

	insertVulnerabilityData = `
		INSERT INTO vulnerability (cveid, severity, description, affected_package, affected_version,fixed_version,published_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		ON CONFLICT(cveid) DO UPDATE SET cveid = $1
		RETURNING id
	`

	insertVulnerabilityScanMapping = `
		INSERT INTO vulnerability_scan_report(scan_id, vulnerability_id)
		VALUES ($1, $2)
	`

	getScanScheduleForComponent = `
		WITH rid AS(
			select id 
			from k8s_release
			where version = $1
		),
		cid AS(
			select id 
			from k8s_release_components
			WHERE name = $2 AND version = $3 AND release_id = (select id from rid)
		)
		SELECT vs.id, vs.scan_tool, vs.scan_at
		FROM vulnerability_scan_schedule as vs
		WHERE vs.release_id = (select id from rid) AND
		vs.component_id = (select id from cid)
		ORDER BY scan_at DESC 
		LIMIT 1
	`

	getVulnerabilitiesForScan = `
		SELECT v.cveid, v.severity, v.description, v.affected_package, v.affected_version,v.fixed_version,v.published_at 
		FROM vulnerability as v, vulnerability_scan_report as vr
		WHERE vr.scan_id =  $1 AND v.id = vr.vulnerability_id
	`
)

func StoreReleaseVulnerability(ctx context.Context, dbconn *sql.DB, in *v1.VulnerabilityReport) error {
	logger := log.FromContext(ctx).WithName("StoreReleaseVulnerability()")
	logger.Info("store vulnerability record", "releaseId", in.ComponentName)
	var idx int64

	tx, err := dbconn.BeginTx(ctx, &sql.TxOptions{})
	if err != nil {
		logger.Error(err, "error initializing transaction")
		return err
	}
	defer tx.Rollback()

	err = tx.QueryRow(
		insertVulnerabilityScan, in.ReleaseId, in.ComponentName, in.ComponentVersion,
		in.ScanTool, in.ScanTimestamp.AsTime(),
	).Scan(&idx)

	if err != nil {
		logger.Error(err, "error inserting vulnerability schedule")
		return err
	}

	for _, v := range in.Vulnerabilities {
		var vId int64
		err = tx.QueryRow(
			insertVulnerabilityData,
			v.Id, v.Severity, v.Description, v.AffectedPackage,
			v.AffectedVersions, v.FixedVersion, v.PublishedAt.AsTime(),
		).Scan(&vId)

		if err != nil {
			logger.Error(err, "error inserting vulnerability data")
			return err
		}

		_, err = tx.Exec(
			insertVulnerabilityScanMapping,
			idx, vId,
		)

		if err != nil {
			logger.Error(err, "error inserting vulnerability data mapping")
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		logger.Error(err, "Error commiting db transaction")
	}

	return nil
}

func ReadReleaseVulnerability(ctx context.Context, dbconn *sql.DB, component pb.ReleaseComponent, releaseId string) (*v1.VulnerabilitiesResult, error) {
	logger := log.FromContext(ctx).WithName("ReadReleaseVulnerability()")
	logger.Info("read vulnerability record", "releaseId", releaseId)
	result := v1.VulnerabilitiesResult{}
	// get all release components
	components, err := getAllReleaseComponents(ctx, dbconn, releaseId, "oss")
	if err != nil {
		logger.Error(err, "error reading release components")
		return nil, status.Errorf(codes.Internal, "release components record find failed")
	}

	for _, comp := range components {
		if component == pb.ReleaseComponent_KUBERNETES && !strings.HasPrefix(comp.Name, "registry.k8s.io") {
			continue
		}
		if component == pb.ReleaseComponent_CALICO && !strings.HasPrefix(comp.Name, "quay.io") {
			continue
		}
		currReport := v1.VulnerabilityReport{}
		currReport.ComponentName = comp.Name
		currReport.ComponentSHA256 = comp.Sha256
		currReport.ComponentVersion = comp.Version
		currReport.ReleaseId = releaseId

		row := dbconn.QueryRow(
			getScanScheduleForComponent,
			releaseId, comp.Name, comp.Version)

		var scanTs time.Time
		var scanId int64
		switch err := row.Scan(&scanId, &currReport.ScanTool, &scanTs); err {
		case sql.ErrNoRows:
			logger.Info("no records found ", " component ", comp.Name, "version ", comp.Version)
		case nil:
			currReport.ScanTimestamp = timestamppb.New(scanTs)
		default:
			logger.Error(err, "error searching release record in db")
		}

		currReport.Vulnerabilities, err = readVulnerabilitiesByScanId(dbconn, scanId)
		if err != nil {
			logger.Error(err, "error fetching vulnerability report")
		}

		result.Report = append(result.Report, &currReport)
	}
	return &result, nil
}

func readVulnerabilitiesByScanId(dbconn *sql.DB, scanId int64) ([]*v1.Vulnerability, error) {
	ctx := context.Background()
	logger := log.FromContext(ctx).WithName("ReadReleaseVulnerability()")
	rows, err := dbconn.Query(getVulnerabilitiesForScan, scanId)
	if err != nil {
		logger.Error(err, "error searching vulnerability record in db")
		return nil, status.Errorf(codes.Internal, "vulnerability record find failed")
	}
	defer rows.Close()
	result := []*v1.Vulnerability{}
	for rows.Next() {
		vuln := v1.Vulnerability{}
		var publishedTs time.Time
		if err := rows.Scan(&vuln.Id, &vuln.Severity, &vuln.Description,
			&vuln.AffectedPackage, &vuln.AffectedVersions,
			&vuln.FixedVersion, &publishedTs); err != nil {
			logger.Error(err, "error reading result row, continue...")
		}
		vuln.PublishedAt = timestamppb.New(publishedTs)
		result = append(result, &vuln)
	}
	return result, nil
}
