// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: compute_private.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InstancePrivateServiceClient is the client API for InstancePrivateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstancePrivateServiceClient interface {
	// Launch a new baremetal or virtual machine instance.
	// Similar to InstanceService.Create with the following differences:
	//   - Caller can provide serviceType.
	//   - Caller can provide resourceId.
	//   - Caller can provide a private instanceType (not implemented).
	//   - Caller can provide a custom instanceTypeSpec (not implemented).
	//   - Caller can provide private network interface fields (not implemented).
	CreatePrivate(ctx context.Context, in *InstanceCreatePrivateRequest, opts ...grpc.CallOption) (*InstancePrivate, error)
	// Launch one or more new baremetal or virtual machine instances.
	// This method succeeds only if prerequisites are satisified to begin launching all of the requested instances.
	// In particular, if there is insufficient capacity to launch all of the requested instances, then no instances will be created.
	// If this method returns an error, then no instances will be created.
	CreateMultiplePrivate(ctx context.Context, in *InstanceCreateMultiplePrivateRequest, opts ...grpc.CallOption) (*InstanceCreateMultiplePrivateResponse, error)
	// Update the specification of a private instance.
	UpdatePrivate(ctx context.Context, in *InstanceUpdatePrivateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Update the resource status.
	UpdateStatus(ctx context.Context, in *InstanceUpdateStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Remove finalizer from an instance that was previously requested to be deleted.
	// After this returns, the record will no longer be visible to users or controllers.
	// Used by Instance Replicator.
	RemoveFinalizer(ctx context.Context, in *InstanceRemoveFinalizerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List instances.
	SearchPrivate(ctx context.Context, in *InstanceSearchPrivateRequest, opts ...grpc.CallOption) (*InstanceSearchPrivateResponse, error)
	// List instances as a stream.
	// This returns all non-deleted instances as messages with WatchDeltaType=Updated,
	// followed by a single WatchDeltaType=Bookmark with the last-seen resourceVersion.
	// Used by Instance Replicator.
	SearchStreamPrivate(ctx context.Context, in *InstanceSearchStreamPrivateRequest, opts ...grpc.CallOption) (InstancePrivateService_SearchStreamPrivateClient, error)
	// Return a stream of changes to instances using messages with WatchDeltaType=Updated or Deleted.
	// Messages with WatchDeltaType=Bookmark and the last-seen resourceVersion will be sent periodically.
	// Used by Instance Replicator.
	Watch(ctx context.Context, in *InstanceWatchRequest, opts ...grpc.CallOption) (InstancePrivateService_WatchClient, error)
	// PingPrivate returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	PingPrivate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeletePrivate deletes an instance, including one which belongs to an instance group.
	DeletePrivate(ctx context.Context, in *InstanceDeletePrivateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type instancePrivateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstancePrivateServiceClient(cc grpc.ClientConnInterface) InstancePrivateServiceClient {
	return &instancePrivateServiceClient{cc}
}

func (c *instancePrivateServiceClient) CreatePrivate(ctx context.Context, in *InstanceCreatePrivateRequest, opts ...grpc.CallOption) (*InstancePrivate, error) {
	out := new(InstancePrivate)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/CreatePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) CreateMultiplePrivate(ctx context.Context, in *InstanceCreateMultiplePrivateRequest, opts ...grpc.CallOption) (*InstanceCreateMultiplePrivateResponse, error) {
	out := new(InstanceCreateMultiplePrivateResponse)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/CreateMultiplePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) UpdatePrivate(ctx context.Context, in *InstanceUpdatePrivateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/UpdatePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) UpdateStatus(ctx context.Context, in *InstanceUpdateStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/UpdateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) RemoveFinalizer(ctx context.Context, in *InstanceRemoveFinalizerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/RemoveFinalizer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) SearchPrivate(ctx context.Context, in *InstanceSearchPrivateRequest, opts ...grpc.CallOption) (*InstanceSearchPrivateResponse, error) {
	out := new(InstanceSearchPrivateResponse)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/SearchPrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) SearchStreamPrivate(ctx context.Context, in *InstanceSearchStreamPrivateRequest, opts ...grpc.CallOption) (InstancePrivateService_SearchStreamPrivateClient, error) {
	stream, err := c.cc.NewStream(ctx, &InstancePrivateService_ServiceDesc.Streams[0], "/proto.InstancePrivateService/SearchStreamPrivate", opts...)
	if err != nil {
		return nil, err
	}
	x := &instancePrivateServiceSearchStreamPrivateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InstancePrivateService_SearchStreamPrivateClient interface {
	Recv() (*InstanceWatchResponse, error)
	grpc.ClientStream
}

type instancePrivateServiceSearchStreamPrivateClient struct {
	grpc.ClientStream
}

func (x *instancePrivateServiceSearchStreamPrivateClient) Recv() (*InstanceWatchResponse, error) {
	m := new(InstanceWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *instancePrivateServiceClient) Watch(ctx context.Context, in *InstanceWatchRequest, opts ...grpc.CallOption) (InstancePrivateService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &InstancePrivateService_ServiceDesc.Streams[1], "/proto.InstancePrivateService/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &instancePrivateServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InstancePrivateService_WatchClient interface {
	Recv() (*InstanceWatchResponse, error)
	grpc.ClientStream
}

type instancePrivateServiceWatchClient struct {
	grpc.ClientStream
}

func (x *instancePrivateServiceWatchClient) Recv() (*InstanceWatchResponse, error) {
	m := new(InstanceWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *instancePrivateServiceClient) PingPrivate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/PingPrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancePrivateServiceClient) DeletePrivate(ctx context.Context, in *InstanceDeletePrivateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstancePrivateService/DeletePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstancePrivateServiceServer is the server API for InstancePrivateService service.
// All implementations must embed UnimplementedInstancePrivateServiceServer
// for forward compatibility
type InstancePrivateServiceServer interface {
	// Launch a new baremetal or virtual machine instance.
	// Similar to InstanceService.Create with the following differences:
	//   - Caller can provide serviceType.
	//   - Caller can provide resourceId.
	//   - Caller can provide a private instanceType (not implemented).
	//   - Caller can provide a custom instanceTypeSpec (not implemented).
	//   - Caller can provide private network interface fields (not implemented).
	CreatePrivate(context.Context, *InstanceCreatePrivateRequest) (*InstancePrivate, error)
	// Launch one or more new baremetal or virtual machine instances.
	// This method succeeds only if prerequisites are satisified to begin launching all of the requested instances.
	// In particular, if there is insufficient capacity to launch all of the requested instances, then no instances will be created.
	// If this method returns an error, then no instances will be created.
	CreateMultiplePrivate(context.Context, *InstanceCreateMultiplePrivateRequest) (*InstanceCreateMultiplePrivateResponse, error)
	// Update the specification of a private instance.
	UpdatePrivate(context.Context, *InstanceUpdatePrivateRequest) (*emptypb.Empty, error)
	// Update the resource status.
	UpdateStatus(context.Context, *InstanceUpdateStatusRequest) (*emptypb.Empty, error)
	// Remove finalizer from an instance that was previously requested to be deleted.
	// After this returns, the record will no longer be visible to users or controllers.
	// Used by Instance Replicator.
	RemoveFinalizer(context.Context, *InstanceRemoveFinalizerRequest) (*emptypb.Empty, error)
	// List instances.
	SearchPrivate(context.Context, *InstanceSearchPrivateRequest) (*InstanceSearchPrivateResponse, error)
	// List instances as a stream.
	// This returns all non-deleted instances as messages with WatchDeltaType=Updated,
	// followed by a single WatchDeltaType=Bookmark with the last-seen resourceVersion.
	// Used by Instance Replicator.
	SearchStreamPrivate(*InstanceSearchStreamPrivateRequest, InstancePrivateService_SearchStreamPrivateServer) error
	// Return a stream of changes to instances using messages with WatchDeltaType=Updated or Deleted.
	// Messages with WatchDeltaType=Bookmark and the last-seen resourceVersion will be sent periodically.
	// Used by Instance Replicator.
	Watch(*InstanceWatchRequest, InstancePrivateService_WatchServer) error
	// PingPrivate returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	PingPrivate(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// DeletePrivate deletes an instance, including one which belongs to an instance group.
	DeletePrivate(context.Context, *InstanceDeletePrivateRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInstancePrivateServiceServer()
}

// UnimplementedInstancePrivateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstancePrivateServiceServer struct {
}

func (UnimplementedInstancePrivateServiceServer) CreatePrivate(context.Context, *InstanceCreatePrivateRequest) (*InstancePrivate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) CreateMultiplePrivate(context.Context, *InstanceCreateMultiplePrivateRequest) (*InstanceCreateMultiplePrivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultiplePrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) UpdatePrivate(context.Context, *InstanceUpdatePrivateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) UpdateStatus(context.Context, *InstanceUpdateStatusRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedInstancePrivateServiceServer) RemoveFinalizer(context.Context, *InstanceRemoveFinalizerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFinalizer not implemented")
}
func (UnimplementedInstancePrivateServiceServer) SearchPrivate(context.Context, *InstanceSearchPrivateRequest) (*InstanceSearchPrivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchPrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) SearchStreamPrivate(*InstanceSearchStreamPrivateRequest, InstancePrivateService_SearchStreamPrivateServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStreamPrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) Watch(*InstanceWatchRequest, InstancePrivateService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedInstancePrivateServiceServer) PingPrivate(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingPrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) DeletePrivate(context.Context, *InstanceDeletePrivateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePrivate not implemented")
}
func (UnimplementedInstancePrivateServiceServer) mustEmbedUnimplementedInstancePrivateServiceServer() {
}

// UnsafeInstancePrivateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstancePrivateServiceServer will
// result in compilation errors.
type UnsafeInstancePrivateServiceServer interface {
	mustEmbedUnimplementedInstancePrivateServiceServer()
}

func RegisterInstancePrivateServiceServer(s grpc.ServiceRegistrar, srv InstancePrivateServiceServer) {
	s.RegisterService(&InstancePrivateService_ServiceDesc, srv)
}

func _InstancePrivateService_CreatePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceCreatePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).CreatePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/CreatePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).CreatePrivate(ctx, req.(*InstanceCreatePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_CreateMultiplePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceCreateMultiplePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).CreateMultiplePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/CreateMultiplePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).CreateMultiplePrivate(ctx, req.(*InstanceCreateMultiplePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_UpdatePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceUpdatePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).UpdatePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/UpdatePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).UpdatePrivate(ctx, req.(*InstanceUpdatePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceUpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/UpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).UpdateStatus(ctx, req.(*InstanceUpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_RemoveFinalizer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceRemoveFinalizerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).RemoveFinalizer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/RemoveFinalizer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).RemoveFinalizer(ctx, req.(*InstanceRemoveFinalizerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_SearchPrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceSearchPrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).SearchPrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/SearchPrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).SearchPrivate(ctx, req.(*InstanceSearchPrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_SearchStreamPrivate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceSearchStreamPrivateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InstancePrivateServiceServer).SearchStreamPrivate(m, &instancePrivateServiceSearchStreamPrivateServer{stream})
}

type InstancePrivateService_SearchStreamPrivateServer interface {
	Send(*InstanceWatchResponse) error
	grpc.ServerStream
}

type instancePrivateServiceSearchStreamPrivateServer struct {
	grpc.ServerStream
}

func (x *instancePrivateServiceSearchStreamPrivateServer) Send(m *InstanceWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InstancePrivateService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InstancePrivateServiceServer).Watch(m, &instancePrivateServiceWatchServer{stream})
}

type InstancePrivateService_WatchServer interface {
	Send(*InstanceWatchResponse) error
	grpc.ServerStream
}

type instancePrivateServiceWatchServer struct {
	grpc.ServerStream
}

func (x *instancePrivateServiceWatchServer) Send(m *InstanceWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InstancePrivateService_PingPrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).PingPrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/PingPrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).PingPrivate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstancePrivateService_DeletePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceDeletePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancePrivateServiceServer).DeletePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstancePrivateService/DeletePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancePrivateServiceServer).DeletePrivate(ctx, req.(*InstanceDeletePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstancePrivateService_ServiceDesc is the grpc.ServiceDesc for InstancePrivateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstancePrivateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.InstancePrivateService",
	HandlerType: (*InstancePrivateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePrivate",
			Handler:    _InstancePrivateService_CreatePrivate_Handler,
		},
		{
			MethodName: "CreateMultiplePrivate",
			Handler:    _InstancePrivateService_CreateMultiplePrivate_Handler,
		},
		{
			MethodName: "UpdatePrivate",
			Handler:    _InstancePrivateService_UpdatePrivate_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _InstancePrivateService_UpdateStatus_Handler,
		},
		{
			MethodName: "RemoveFinalizer",
			Handler:    _InstancePrivateService_RemoveFinalizer_Handler,
		},
		{
			MethodName: "SearchPrivate",
			Handler:    _InstancePrivateService_SearchPrivate_Handler,
		},
		{
			MethodName: "PingPrivate",
			Handler:    _InstancePrivateService_PingPrivate_Handler,
		},
		{
			MethodName: "DeletePrivate",
			Handler:    _InstancePrivateService_DeletePrivate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStreamPrivate",
			Handler:       _InstancePrivateService_SearchStreamPrivate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Watch",
			Handler:       _InstancePrivateService_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute_private.proto",
}

// InstanceGroupPrivateServiceClient is the client API for InstanceGroupPrivateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceGroupPrivateServiceClient interface {
	// Launch a new instance group.
	CreatePrivate(ctx context.Context, in *InstanceGroupCreatePrivateRequest, opts ...grpc.CallOption) (*InstanceGroupPrivateCreateResponse, error)
}

type instanceGroupPrivateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceGroupPrivateServiceClient(cc grpc.ClientConnInterface) InstanceGroupPrivateServiceClient {
	return &instanceGroupPrivateServiceClient{cc}
}

func (c *instanceGroupPrivateServiceClient) CreatePrivate(ctx context.Context, in *InstanceGroupCreatePrivateRequest, opts ...grpc.CallOption) (*InstanceGroupPrivateCreateResponse, error) {
	out := new(InstanceGroupPrivateCreateResponse)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupPrivateService/CreatePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceGroupPrivateServiceServer is the server API for InstanceGroupPrivateService service.
// All implementations must embed UnimplementedInstanceGroupPrivateServiceServer
// for forward compatibility
type InstanceGroupPrivateServiceServer interface {
	// Launch a new instance group.
	CreatePrivate(context.Context, *InstanceGroupCreatePrivateRequest) (*InstanceGroupPrivateCreateResponse, error)
	mustEmbedUnimplementedInstanceGroupPrivateServiceServer()
}

// UnimplementedInstanceGroupPrivateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceGroupPrivateServiceServer struct {
}

func (UnimplementedInstanceGroupPrivateServiceServer) CreatePrivate(context.Context, *InstanceGroupCreatePrivateRequest) (*InstanceGroupPrivateCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrivate not implemented")
}
func (UnimplementedInstanceGroupPrivateServiceServer) mustEmbedUnimplementedInstanceGroupPrivateServiceServer() {
}

// UnsafeInstanceGroupPrivateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceGroupPrivateServiceServer will
// result in compilation errors.
type UnsafeInstanceGroupPrivateServiceServer interface {
	mustEmbedUnimplementedInstanceGroupPrivateServiceServer()
}

func RegisterInstanceGroupPrivateServiceServer(s grpc.ServiceRegistrar, srv InstanceGroupPrivateServiceServer) {
	s.RegisterService(&InstanceGroupPrivateService_ServiceDesc, srv)
}

func _InstanceGroupPrivateService_CreatePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupCreatePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupPrivateServiceServer).CreatePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupPrivateService/CreatePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupPrivateServiceServer).CreatePrivate(ctx, req.(*InstanceGroupCreatePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceGroupPrivateService_ServiceDesc is the grpc.ServiceDesc for InstanceGroupPrivateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceGroupPrivateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.InstanceGroupPrivateService",
	HandlerType: (*InstanceGroupPrivateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePrivate",
			Handler:    _InstanceGroupPrivateService_CreatePrivate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "compute_private.proto",
}

// InstanceSchedulingServiceClient is the client API for InstanceSchedulingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceSchedulingServiceClient interface {
	// Schedule one or more resources (instances).
	// All resources will be reserved or, if an error is returned, none will.
	Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error)
	// Returns a successful response when the service is ready to handle schedule requests.
	Ready(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetStatistics retrieves the current statistical data of all nodes.
	GetStatistics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SchedulerStatistics, error)
}

type instanceSchedulingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceSchedulingServiceClient(cc grpc.ClientConnInterface) InstanceSchedulingServiceClient {
	return &instanceSchedulingServiceClient{cc}
}

func (c *instanceSchedulingServiceClient) Schedule(ctx context.Context, in *ScheduleRequest, opts ...grpc.CallOption) (*ScheduleResponse, error) {
	out := new(ScheduleResponse)
	err := c.cc.Invoke(ctx, "/proto.InstanceSchedulingService/Schedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceSchedulingServiceClient) Ready(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceSchedulingService/Ready", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceSchedulingServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceSchedulingService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceSchedulingServiceClient) GetStatistics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SchedulerStatistics, error) {
	out := new(SchedulerStatistics)
	err := c.cc.Invoke(ctx, "/proto.InstanceSchedulingService/GetStatistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceSchedulingServiceServer is the server API for InstanceSchedulingService service.
// All implementations must embed UnimplementedInstanceSchedulingServiceServer
// for forward compatibility
type InstanceSchedulingServiceServer interface {
	// Schedule one or more resources (instances).
	// All resources will be reserved or, if an error is returned, none will.
	Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error)
	// Returns a successful response when the service is ready to handle schedule requests.
	Ready(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetStatistics retrieves the current statistical data of all nodes.
	GetStatistics(context.Context, *emptypb.Empty) (*SchedulerStatistics, error)
	mustEmbedUnimplementedInstanceSchedulingServiceServer()
}

// UnimplementedInstanceSchedulingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceSchedulingServiceServer struct {
}

func (UnimplementedInstanceSchedulingServiceServer) Schedule(context.Context, *ScheduleRequest) (*ScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Schedule not implemented")
}
func (UnimplementedInstanceSchedulingServiceServer) Ready(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedInstanceSchedulingServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedInstanceSchedulingServiceServer) GetStatistics(context.Context, *emptypb.Empty) (*SchedulerStatistics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatistics not implemented")
}
func (UnimplementedInstanceSchedulingServiceServer) mustEmbedUnimplementedInstanceSchedulingServiceServer() {
}

// UnsafeInstanceSchedulingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceSchedulingServiceServer will
// result in compilation errors.
type UnsafeInstanceSchedulingServiceServer interface {
	mustEmbedUnimplementedInstanceSchedulingServiceServer()
}

func RegisterInstanceSchedulingServiceServer(s grpc.ServiceRegistrar, srv InstanceSchedulingServiceServer) {
	s.RegisterService(&InstanceSchedulingService_ServiceDesc, srv)
}

func _InstanceSchedulingService_Schedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceSchedulingServiceServer).Schedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceSchedulingService/Schedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceSchedulingServiceServer).Schedule(ctx, req.(*ScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceSchedulingService_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceSchedulingServiceServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceSchedulingService/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceSchedulingServiceServer).Ready(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceSchedulingService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceSchedulingServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceSchedulingService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceSchedulingServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceSchedulingService_GetStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceSchedulingServiceServer).GetStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceSchedulingService/GetStatistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceSchedulingServiceServer).GetStatistics(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceSchedulingService_ServiceDesc is the grpc.ServiceDesc for InstanceSchedulingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceSchedulingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.InstanceSchedulingService",
	HandlerType: (*InstanceSchedulingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Schedule",
			Handler:    _InstanceSchedulingService_Schedule_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _InstanceSchedulingService_Ready_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _InstanceSchedulingService_Ping_Handler,
		},
		{
			MethodName: "GetStatistics",
			Handler:    _InstanceSchedulingService_GetStatistics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "compute_private.proto",
}

// IpResourceManagerServiceClient is the client API for IpResourceManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IpResourceManagerServiceClient interface {
	// Create or update a subnet and its address records.
	// Updates an existing subnet with matching region, availabilityZone, addressSpace, and subnet.
	// Creates a new subnet if a matching subnet is not found.
	// Adds and deletes addresses to match the request.
	// subnetConsumerId of an existing subnet is not changed.
	// addressConsumerId of existing addresses is not changed.
	// This is idempotent.
	PutSubnet(ctx context.Context, in *CreateSubnetRequest, opts ...grpc.CallOption) (*CreateSubnetResponse, error)
	// Unreserve and delete a subnet and address records.
	// This is idempotent.
	DeleteSubnet(ctx context.Context, in *DeleteSubnetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List subnets as a stream.
	SearchSubnetStream(ctx context.Context, in *SearchSubnetRequest, opts ...grpc.CallOption) (IpResourceManagerService_SearchSubnetStreamClient, error)
	// Reserve a subnet for a generic consumer.
	// A subnet specifies the CIDR and VLAN ID.
	// Try to find the subnet record with a matching subnetConsumerId.
	// If not found, find a subnet record with empty subnetConsumerId but same parameters (region, availabilityZone, prefixLength),
	// then set subnetConsumerId.
	// This is idempotent.
	// Returns ResourceExhausted if no subnet is available.
	// Notes:
	// Accelerator/Gaudi cluster network
	// VlanDomain field helps to allocate a VLAN or BGP community ID when reserving a subnet to the accelerator network
	//
	// Accelerator network - L2 mode (VVV)
	// ----------------------------------
	// VlanDomain value is set to the value of cluster group ID.
	// Cluster group ID uniquely identify an accelerator Cluster in L2 setup.
	// SDN controller use the VLAN ID to setup the accelerator network.
	//
	// Accelerator network - L3 mode (XBX)
	// ----------------------------------
	// VLAN ID value is set to the value of BGP community ID.
	// BGP community ID uniquely identify an accelerator cluster in L3 setup.
	// SDN controller use the BGP community ID to setup the accelerator network
	ReserveSubnet(ctx context.Context, in *ReserveSubnetRequest, opts ...grpc.CallOption) (*Subnet, error)
	// Release (unreserve) a subnet previously reserved with ReserveSubnet.
	// This is idempotent.
	// Returns NotFound if a subnet with this subnetConsumerId does not exist.
	// Returns FailedPrecondition if the subnet has consumed addresses.
	ReleaseSubnet(ctx context.Context, in *ReleaseSubnetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Reserve (allocate, claim) an IP address in the subnet.
	// The subnet must have been reserved with ReserveSubnet.
	// This is idempotent.
	// Returns ResourceExhausted if no address is available.
	// Returns NotFound if subnet with this subnetConsumerId does not exist.
	ReserveAddress(ctx context.Context, in *ReserveAddressRequest, opts ...grpc.CallOption) (*ReserveAddressResponse, error)
	// Release (unallocate, free) an IP address previously reserved with ReserveAddress.
	// This is idempotent.
	// Returns NotFound if a subnet with this subnetConsumerId does not exist.
	// Returns NotFound if an address with this addressConsumerId does not exist in the subnet.
	ReleaseAddress(ctx context.Context, in *ReleaseAddressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetSubnetStatistics returns the total number subnets and the total number of consumed subnets
	// for each of the corresponding region, availability zone, address space, vlan domain and prefixlength.
	GetSubnetStatistics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetSubnetStatisticsResponse, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type ipResourceManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIpResourceManagerServiceClient(cc grpc.ClientConnInterface) IpResourceManagerServiceClient {
	return &ipResourceManagerServiceClient{cc}
}

func (c *ipResourceManagerServiceClient) PutSubnet(ctx context.Context, in *CreateSubnetRequest, opts ...grpc.CallOption) (*CreateSubnetResponse, error) {
	out := new(CreateSubnetResponse)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/PutSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) DeleteSubnet(ctx context.Context, in *DeleteSubnetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/DeleteSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) SearchSubnetStream(ctx context.Context, in *SearchSubnetRequest, opts ...grpc.CallOption) (IpResourceManagerService_SearchSubnetStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &IpResourceManagerService_ServiceDesc.Streams[0], "/proto.IpResourceManagerService/SearchSubnetStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &ipResourceManagerServiceSearchSubnetStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IpResourceManagerService_SearchSubnetStreamClient interface {
	Recv() (*Subnet, error)
	grpc.ClientStream
}

type ipResourceManagerServiceSearchSubnetStreamClient struct {
	grpc.ClientStream
}

func (x *ipResourceManagerServiceSearchSubnetStreamClient) Recv() (*Subnet, error) {
	m := new(Subnet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ipResourceManagerServiceClient) ReserveSubnet(ctx context.Context, in *ReserveSubnetRequest, opts ...grpc.CallOption) (*Subnet, error) {
	out := new(Subnet)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/ReserveSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) ReleaseSubnet(ctx context.Context, in *ReleaseSubnetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/ReleaseSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) ReserveAddress(ctx context.Context, in *ReserveAddressRequest, opts ...grpc.CallOption) (*ReserveAddressResponse, error) {
	out := new(ReserveAddressResponse)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/ReserveAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) ReleaseAddress(ctx context.Context, in *ReleaseAddressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/ReleaseAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) GetSubnetStatistics(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetSubnetStatisticsResponse, error) {
	out := new(GetSubnetStatisticsResponse)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/GetSubnetStatistics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipResourceManagerServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.IpResourceManagerService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IpResourceManagerServiceServer is the server API for IpResourceManagerService service.
// All implementations must embed UnimplementedIpResourceManagerServiceServer
// for forward compatibility
type IpResourceManagerServiceServer interface {
	// Create or update a subnet and its address records.
	// Updates an existing subnet with matching region, availabilityZone, addressSpace, and subnet.
	// Creates a new subnet if a matching subnet is not found.
	// Adds and deletes addresses to match the request.
	// subnetConsumerId of an existing subnet is not changed.
	// addressConsumerId of existing addresses is not changed.
	// This is idempotent.
	PutSubnet(context.Context, *CreateSubnetRequest) (*CreateSubnetResponse, error)
	// Unreserve and delete a subnet and address records.
	// This is idempotent.
	DeleteSubnet(context.Context, *DeleteSubnetRequest) (*emptypb.Empty, error)
	// List subnets as a stream.
	SearchSubnetStream(*SearchSubnetRequest, IpResourceManagerService_SearchSubnetStreamServer) error
	// Reserve a subnet for a generic consumer.
	// A subnet specifies the CIDR and VLAN ID.
	// Try to find the subnet record with a matching subnetConsumerId.
	// If not found, find a subnet record with empty subnetConsumerId but same parameters (region, availabilityZone, prefixLength),
	// then set subnetConsumerId.
	// This is idempotent.
	// Returns ResourceExhausted if no subnet is available.
	// Notes:
	// Accelerator/Gaudi cluster network
	// VlanDomain field helps to allocate a VLAN or BGP community ID when reserving a subnet to the accelerator network
	//
	// Accelerator network - L2 mode (VVV)
	// ----------------------------------
	// VlanDomain value is set to the value of cluster group ID.
	// Cluster group ID uniquely identify an accelerator Cluster in L2 setup.
	// SDN controller use the VLAN ID to setup the accelerator network.
	//
	// Accelerator network - L3 mode (XBX)
	// ----------------------------------
	// VLAN ID value is set to the value of BGP community ID.
	// BGP community ID uniquely identify an accelerator cluster in L3 setup.
	// SDN controller use the BGP community ID to setup the accelerator network
	ReserveSubnet(context.Context, *ReserveSubnetRequest) (*Subnet, error)
	// Release (unreserve) a subnet previously reserved with ReserveSubnet.
	// This is idempotent.
	// Returns NotFound if a subnet with this subnetConsumerId does not exist.
	// Returns FailedPrecondition if the subnet has consumed addresses.
	ReleaseSubnet(context.Context, *ReleaseSubnetRequest) (*emptypb.Empty, error)
	// Reserve (allocate, claim) an IP address in the subnet.
	// The subnet must have been reserved with ReserveSubnet.
	// This is idempotent.
	// Returns ResourceExhausted if no address is available.
	// Returns NotFound if subnet with this subnetConsumerId does not exist.
	ReserveAddress(context.Context, *ReserveAddressRequest) (*ReserveAddressResponse, error)
	// Release (unallocate, free) an IP address previously reserved with ReserveAddress.
	// This is idempotent.
	// Returns NotFound if a subnet with this subnetConsumerId does not exist.
	// Returns NotFound if an address with this addressConsumerId does not exist in the subnet.
	ReleaseAddress(context.Context, *ReleaseAddressRequest) (*emptypb.Empty, error)
	// GetSubnetStatistics returns the total number subnets and the total number of consumed subnets
	// for each of the corresponding region, availability zone, address space, vlan domain and prefixlength.
	GetSubnetStatistics(context.Context, *emptypb.Empty) (*GetSubnetStatisticsResponse, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedIpResourceManagerServiceServer()
}

// UnimplementedIpResourceManagerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedIpResourceManagerServiceServer struct {
}

func (UnimplementedIpResourceManagerServiceServer) PutSubnet(context.Context, *CreateSubnetRequest) (*CreateSubnetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSubnet not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) DeleteSubnet(context.Context, *DeleteSubnetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSubnet not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) SearchSubnetStream(*SearchSubnetRequest, IpResourceManagerService_SearchSubnetStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchSubnetStream not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) ReserveSubnet(context.Context, *ReserveSubnetRequest) (*Subnet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveSubnet not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) ReleaseSubnet(context.Context, *ReleaseSubnetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseSubnet not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) ReserveAddress(context.Context, *ReserveAddressRequest) (*ReserveAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveAddress not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) ReleaseAddress(context.Context, *ReleaseAddressRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseAddress not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) GetSubnetStatistics(context.Context, *emptypb.Empty) (*GetSubnetStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSubnetStatistics not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedIpResourceManagerServiceServer) mustEmbedUnimplementedIpResourceManagerServiceServer() {
}

// UnsafeIpResourceManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IpResourceManagerServiceServer will
// result in compilation errors.
type UnsafeIpResourceManagerServiceServer interface {
	mustEmbedUnimplementedIpResourceManagerServiceServer()
}

func RegisterIpResourceManagerServiceServer(s grpc.ServiceRegistrar, srv IpResourceManagerServiceServer) {
	s.RegisterService(&IpResourceManagerService_ServiceDesc, srv)
}

func _IpResourceManagerService_PutSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).PutSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/PutSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).PutSubnet(ctx, req.(*CreateSubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_DeleteSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).DeleteSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/DeleteSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).DeleteSubnet(ctx, req.(*DeleteSubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_SearchSubnetStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchSubnetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IpResourceManagerServiceServer).SearchSubnetStream(m, &ipResourceManagerServiceSearchSubnetStreamServer{stream})
}

type IpResourceManagerService_SearchSubnetStreamServer interface {
	Send(*Subnet) error
	grpc.ServerStream
}

type ipResourceManagerServiceSearchSubnetStreamServer struct {
	grpc.ServerStream
}

func (x *ipResourceManagerServiceSearchSubnetStreamServer) Send(m *Subnet) error {
	return x.ServerStream.SendMsg(m)
}

func _IpResourceManagerService_ReserveSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReserveSubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).ReserveSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/ReserveSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).ReserveSubnet(ctx, req.(*ReserveSubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_ReleaseSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseSubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).ReleaseSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/ReleaseSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).ReleaseSubnet(ctx, req.(*ReleaseSubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_ReserveAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReserveAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).ReserveAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/ReserveAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).ReserveAddress(ctx, req.(*ReserveAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_ReleaseAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).ReleaseAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/ReleaseAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).ReleaseAddress(ctx, req.(*ReleaseAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_GetSubnetStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).GetSubnetStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/GetSubnetStatistics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).GetSubnetStatistics(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpResourceManagerService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpResourceManagerServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.IpResourceManagerService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpResourceManagerServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// IpResourceManagerService_ServiceDesc is the grpc.ServiceDesc for IpResourceManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IpResourceManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.IpResourceManagerService",
	HandlerType: (*IpResourceManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PutSubnet",
			Handler:    _IpResourceManagerService_PutSubnet_Handler,
		},
		{
			MethodName: "DeleteSubnet",
			Handler:    _IpResourceManagerService_DeleteSubnet_Handler,
		},
		{
			MethodName: "ReserveSubnet",
			Handler:    _IpResourceManagerService_ReserveSubnet_Handler,
		},
		{
			MethodName: "ReleaseSubnet",
			Handler:    _IpResourceManagerService_ReleaseSubnet_Handler,
		},
		{
			MethodName: "ReserveAddress",
			Handler:    _IpResourceManagerService_ReserveAddress_Handler,
		},
		{
			MethodName: "ReleaseAddress",
			Handler:    _IpResourceManagerService_ReleaseAddress_Handler,
		},
		{
			MethodName: "GetSubnetStatistics",
			Handler:    _IpResourceManagerService_GetSubnetStatistics_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _IpResourceManagerService_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchSubnetStream",
			Handler:       _IpResourceManagerService_SearchSubnetStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute_private.proto",
}

// VNetPrivateServiceClient is the client API for VNetPrivateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VNetPrivateServiceClient interface {
	// Reserve a subnet for a VNet.
	// A subnet specifies the CIDR and VLAN ID.
	// If the VNet already has a reserved subnet, this returns that subnet.
	// If the VNet does not already have a reserved subnet, then find a subnet with an empty subnetConsumerId but the same parameters
	// (region, availabilityZone, prefixLength), then set subnetConsumerId.
	// This is idempotent.
	// Returns ResourceExhausted if no subnet is available.
	ReserveSubnet(ctx context.Context, in *VNetReserveSubnetRequest, opts ...grpc.CallOption) (*VNetPrivate, error)
	// Release (unreserve) a subnet previously reserved with ReserveSubnet.
	// This is idempotent.
	// Returns NotFound if the VNet does not have a reserved subnet.
	// Returns FailedPrecondition if the VNet has consumed addresses.
	ReleaseSubnet(ctx context.Context, in *VNetReleaseSubnetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Reserve (allocate, claim) an IP address in the VNet.
	// The subnet must have been reserved with ReserveSubnet.
	// This is idempotent.
	// Returns ResourceExhausted if no address is available.
	// Returns NotFound if the VNet does not have a reserved subnet.
	ReserveAddress(ctx context.Context, in *VNetReserveAddressRequest, opts ...grpc.CallOption) (*VNetReserveAddressResponse, error)
	// Release (unallocate, free) an IP address previously reserved with ReserveAddress.
	// This is idempotent.
	// Returns NotFound if the VNet does not have a reserved subnet.
	// Returns NotFound if the address with this addressConsumerId does not exist in the subnet.
	ReleaseAddress(ctx context.Context, in *VNetReleaseAddressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// PingPrivate always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	PingPrivate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type vNetPrivateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVNetPrivateServiceClient(cc grpc.ClientConnInterface) VNetPrivateServiceClient {
	return &vNetPrivateServiceClient{cc}
}

func (c *vNetPrivateServiceClient) ReserveSubnet(ctx context.Context, in *VNetReserveSubnetRequest, opts ...grpc.CallOption) (*VNetPrivate, error) {
	out := new(VNetPrivate)
	err := c.cc.Invoke(ctx, "/proto.VNetPrivateService/ReserveSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetPrivateServiceClient) ReleaseSubnet(ctx context.Context, in *VNetReleaseSubnetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VNetPrivateService/ReleaseSubnet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetPrivateServiceClient) ReserveAddress(ctx context.Context, in *VNetReserveAddressRequest, opts ...grpc.CallOption) (*VNetReserveAddressResponse, error) {
	out := new(VNetReserveAddressResponse)
	err := c.cc.Invoke(ctx, "/proto.VNetPrivateService/ReserveAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetPrivateServiceClient) ReleaseAddress(ctx context.Context, in *VNetReleaseAddressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VNetPrivateService/ReleaseAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetPrivateServiceClient) PingPrivate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VNetPrivateService/PingPrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNetPrivateServiceServer is the server API for VNetPrivateService service.
// All implementations must embed UnimplementedVNetPrivateServiceServer
// for forward compatibility
type VNetPrivateServiceServer interface {
	// Reserve a subnet for a VNet.
	// A subnet specifies the CIDR and VLAN ID.
	// If the VNet already has a reserved subnet, this returns that subnet.
	// If the VNet does not already have a reserved subnet, then find a subnet with an empty subnetConsumerId but the same parameters
	// (region, availabilityZone, prefixLength), then set subnetConsumerId.
	// This is idempotent.
	// Returns ResourceExhausted if no subnet is available.
	ReserveSubnet(context.Context, *VNetReserveSubnetRequest) (*VNetPrivate, error)
	// Release (unreserve) a subnet previously reserved with ReserveSubnet.
	// This is idempotent.
	// Returns NotFound if the VNet does not have a reserved subnet.
	// Returns FailedPrecondition if the VNet has consumed addresses.
	ReleaseSubnet(context.Context, *VNetReleaseSubnetRequest) (*emptypb.Empty, error)
	// Reserve (allocate, claim) an IP address in the VNet.
	// The subnet must have been reserved with ReserveSubnet.
	// This is idempotent.
	// Returns ResourceExhausted if no address is available.
	// Returns NotFound if the VNet does not have a reserved subnet.
	ReserveAddress(context.Context, *VNetReserveAddressRequest) (*VNetReserveAddressResponse, error)
	// Release (unallocate, free) an IP address previously reserved with ReserveAddress.
	// This is idempotent.
	// Returns NotFound if the VNet does not have a reserved subnet.
	// Returns NotFound if the address with this addressConsumerId does not exist in the subnet.
	ReleaseAddress(context.Context, *VNetReleaseAddressRequest) (*emptypb.Empty, error)
	// PingPrivate always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	PingPrivate(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedVNetPrivateServiceServer()
}

// UnimplementedVNetPrivateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVNetPrivateServiceServer struct {
}

func (UnimplementedVNetPrivateServiceServer) ReserveSubnet(context.Context, *VNetReserveSubnetRequest) (*VNetPrivate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveSubnet not implemented")
}
func (UnimplementedVNetPrivateServiceServer) ReleaseSubnet(context.Context, *VNetReleaseSubnetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseSubnet not implemented")
}
func (UnimplementedVNetPrivateServiceServer) ReserveAddress(context.Context, *VNetReserveAddressRequest) (*VNetReserveAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveAddress not implemented")
}
func (UnimplementedVNetPrivateServiceServer) ReleaseAddress(context.Context, *VNetReleaseAddressRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseAddress not implemented")
}
func (UnimplementedVNetPrivateServiceServer) PingPrivate(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingPrivate not implemented")
}
func (UnimplementedVNetPrivateServiceServer) mustEmbedUnimplementedVNetPrivateServiceServer() {}

// UnsafeVNetPrivateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VNetPrivateServiceServer will
// result in compilation errors.
type UnsafeVNetPrivateServiceServer interface {
	mustEmbedUnimplementedVNetPrivateServiceServer()
}

func RegisterVNetPrivateServiceServer(s grpc.ServiceRegistrar, srv VNetPrivateServiceServer) {
	s.RegisterService(&VNetPrivateService_ServiceDesc, srv)
}

func _VNetPrivateService_ReserveSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetReserveSubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetPrivateServiceServer).ReserveSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetPrivateService/ReserveSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetPrivateServiceServer).ReserveSubnet(ctx, req.(*VNetReserveSubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetPrivateService_ReleaseSubnet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetReleaseSubnetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetPrivateServiceServer).ReleaseSubnet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetPrivateService/ReleaseSubnet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetPrivateServiceServer).ReleaseSubnet(ctx, req.(*VNetReleaseSubnetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetPrivateService_ReserveAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetReserveAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetPrivateServiceServer).ReserveAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetPrivateService/ReserveAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetPrivateServiceServer).ReserveAddress(ctx, req.(*VNetReserveAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetPrivateService_ReleaseAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetReleaseAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetPrivateServiceServer).ReleaseAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetPrivateService/ReleaseAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetPrivateServiceServer).ReleaseAddress(ctx, req.(*VNetReleaseAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetPrivateService_PingPrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetPrivateServiceServer).PingPrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetPrivateService/PingPrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetPrivateServiceServer).PingPrivate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// VNetPrivateService_ServiceDesc is the grpc.ServiceDesc for VNetPrivateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VNetPrivateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.VNetPrivateService",
	HandlerType: (*VNetPrivateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReserveSubnet",
			Handler:    _VNetPrivateService_ReserveSubnet_Handler,
		},
		{
			MethodName: "ReleaseSubnet",
			Handler:    _VNetPrivateService_ReleaseSubnet_Handler,
		},
		{
			MethodName: "ReserveAddress",
			Handler:    _VNetPrivateService_ReserveAddress_Handler,
		},
		{
			MethodName: "ReleaseAddress",
			Handler:    _VNetPrivateService_ReleaseAddress_Handler,
		},
		{
			MethodName: "PingPrivate",
			Handler:    _VNetPrivateService_PingPrivate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "compute_private.proto",
}

// LoadBalancerPrivateServiceClient is the client API for LoadBalancerPrivateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadBalancerPrivateServiceClient interface {
	// Launch a load balancer.
	CreatePrivate(ctx context.Context, in *LoadBalancerCreatePrivateRequest, opts ...grpc.CallOption) (*LoadBalancerPrivate, error)
	// Update the resource status.
	UpdateStatus(ctx context.Context, in *LoadBalancerUpdateStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Remove finalizer from an load balancer that was previously requested to be deleted.
	// After this returns, the record will no longer be visible to users or controllers.
	// Used by Compute Replicator.
	RemoveFinalizer(ctx context.Context, in *LoadBalancerRemoveFinalizerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// PingPrivate returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	PingPrivate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeletePrivate deletes a loadbalancer.
	DeletePrivate(ctx context.Context, in *LoadBalancerDeletePrivateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List loadbalancers as a stream.
	// This returns all non-deleted load balancers as messages with WatchDeltaType=Updated,
	// followed by a single WatchDeltaType=Bookmark with the last-seen resourceVersion.
	// Used by Compute Replicator.
	SearchStreamPrivate(ctx context.Context, in *LoadBalancerSearchStreamPrivateRequest, opts ...grpc.CallOption) (LoadBalancerPrivateService_SearchStreamPrivateClient, error)
	// Return a stream of changes to load balancers using messages with WatchDeltaType=Updated or Deleted.
	// Messages with WatchDeltaType=Bookmark and the last-seen resourceVersion will be sent periodically.
	// Used by Compute Replicator.
	Watch(ctx context.Context, in *LoadBalancerWatchRequest, opts ...grpc.CallOption) (LoadBalancerPrivateService_WatchClient, error)
}

type loadBalancerPrivateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadBalancerPrivateServiceClient(cc grpc.ClientConnInterface) LoadBalancerPrivateServiceClient {
	return &loadBalancerPrivateServiceClient{cc}
}

func (c *loadBalancerPrivateServiceClient) CreatePrivate(ctx context.Context, in *LoadBalancerCreatePrivateRequest, opts ...grpc.CallOption) (*LoadBalancerPrivate, error) {
	out := new(LoadBalancerPrivate)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerPrivateService/CreatePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerPrivateServiceClient) UpdateStatus(ctx context.Context, in *LoadBalancerUpdateStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerPrivateService/UpdateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerPrivateServiceClient) RemoveFinalizer(ctx context.Context, in *LoadBalancerRemoveFinalizerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerPrivateService/RemoveFinalizer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerPrivateServiceClient) PingPrivate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerPrivateService/PingPrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerPrivateServiceClient) DeletePrivate(ctx context.Context, in *LoadBalancerDeletePrivateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerPrivateService/DeletePrivate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerPrivateServiceClient) SearchStreamPrivate(ctx context.Context, in *LoadBalancerSearchStreamPrivateRequest, opts ...grpc.CallOption) (LoadBalancerPrivateService_SearchStreamPrivateClient, error) {
	stream, err := c.cc.NewStream(ctx, &LoadBalancerPrivateService_ServiceDesc.Streams[0], "/proto.LoadBalancerPrivateService/SearchStreamPrivate", opts...)
	if err != nil {
		return nil, err
	}
	x := &loadBalancerPrivateServiceSearchStreamPrivateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LoadBalancerPrivateService_SearchStreamPrivateClient interface {
	Recv() (*LoadBalancerWatchResponse, error)
	grpc.ClientStream
}

type loadBalancerPrivateServiceSearchStreamPrivateClient struct {
	grpc.ClientStream
}

func (x *loadBalancerPrivateServiceSearchStreamPrivateClient) Recv() (*LoadBalancerWatchResponse, error) {
	m := new(LoadBalancerWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *loadBalancerPrivateServiceClient) Watch(ctx context.Context, in *LoadBalancerWatchRequest, opts ...grpc.CallOption) (LoadBalancerPrivateService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &LoadBalancerPrivateService_ServiceDesc.Streams[1], "/proto.LoadBalancerPrivateService/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &loadBalancerPrivateServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LoadBalancerPrivateService_WatchClient interface {
	Recv() (*LoadBalancerWatchResponse, error)
	grpc.ClientStream
}

type loadBalancerPrivateServiceWatchClient struct {
	grpc.ClientStream
}

func (x *loadBalancerPrivateServiceWatchClient) Recv() (*LoadBalancerWatchResponse, error) {
	m := new(LoadBalancerWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LoadBalancerPrivateServiceServer is the server API for LoadBalancerPrivateService service.
// All implementations must embed UnimplementedLoadBalancerPrivateServiceServer
// for forward compatibility
type LoadBalancerPrivateServiceServer interface {
	// Launch a load balancer.
	CreatePrivate(context.Context, *LoadBalancerCreatePrivateRequest) (*LoadBalancerPrivate, error)
	// Update the resource status.
	UpdateStatus(context.Context, *LoadBalancerUpdateStatusRequest) (*emptypb.Empty, error)
	// Remove finalizer from an load balancer that was previously requested to be deleted.
	// After this returns, the record will no longer be visible to users or controllers.
	// Used by Compute Replicator.
	RemoveFinalizer(context.Context, *LoadBalancerRemoveFinalizerRequest) (*emptypb.Empty, error)
	// PingPrivate returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	PingPrivate(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// DeletePrivate deletes a loadbalancer.
	DeletePrivate(context.Context, *LoadBalancerDeletePrivateRequest) (*emptypb.Empty, error)
	// List loadbalancers as a stream.
	// This returns all non-deleted load balancers as messages with WatchDeltaType=Updated,
	// followed by a single WatchDeltaType=Bookmark with the last-seen resourceVersion.
	// Used by Compute Replicator.
	SearchStreamPrivate(*LoadBalancerSearchStreamPrivateRequest, LoadBalancerPrivateService_SearchStreamPrivateServer) error
	// Return a stream of changes to load balancers using messages with WatchDeltaType=Updated or Deleted.
	// Messages with WatchDeltaType=Bookmark and the last-seen resourceVersion will be sent periodically.
	// Used by Compute Replicator.
	Watch(*LoadBalancerWatchRequest, LoadBalancerPrivateService_WatchServer) error
	mustEmbedUnimplementedLoadBalancerPrivateServiceServer()
}

// UnimplementedLoadBalancerPrivateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadBalancerPrivateServiceServer struct {
}

func (UnimplementedLoadBalancerPrivateServiceServer) CreatePrivate(context.Context, *LoadBalancerCreatePrivateRequest) (*LoadBalancerPrivate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrivate not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) UpdateStatus(context.Context, *LoadBalancerUpdateStatusRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) RemoveFinalizer(context.Context, *LoadBalancerRemoveFinalizerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFinalizer not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) PingPrivate(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingPrivate not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) DeletePrivate(context.Context, *LoadBalancerDeletePrivateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePrivate not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) SearchStreamPrivate(*LoadBalancerSearchStreamPrivateRequest, LoadBalancerPrivateService_SearchStreamPrivateServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStreamPrivate not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) Watch(*LoadBalancerWatchRequest, LoadBalancerPrivateService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedLoadBalancerPrivateServiceServer) mustEmbedUnimplementedLoadBalancerPrivateServiceServer() {
}

// UnsafeLoadBalancerPrivateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadBalancerPrivateServiceServer will
// result in compilation errors.
type UnsafeLoadBalancerPrivateServiceServer interface {
	mustEmbedUnimplementedLoadBalancerPrivateServiceServer()
}

func RegisterLoadBalancerPrivateServiceServer(s grpc.ServiceRegistrar, srv LoadBalancerPrivateServiceServer) {
	s.RegisterService(&LoadBalancerPrivateService_ServiceDesc, srv)
}

func _LoadBalancerPrivateService_CreatePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerCreatePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerPrivateServiceServer).CreatePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerPrivateService/CreatePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerPrivateServiceServer).CreatePrivate(ctx, req.(*LoadBalancerCreatePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerPrivateService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerUpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerPrivateServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerPrivateService/UpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerPrivateServiceServer).UpdateStatus(ctx, req.(*LoadBalancerUpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerPrivateService_RemoveFinalizer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerRemoveFinalizerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerPrivateServiceServer).RemoveFinalizer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerPrivateService/RemoveFinalizer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerPrivateServiceServer).RemoveFinalizer(ctx, req.(*LoadBalancerRemoveFinalizerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerPrivateService_PingPrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerPrivateServiceServer).PingPrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerPrivateService/PingPrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerPrivateServiceServer).PingPrivate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerPrivateService_DeletePrivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerDeletePrivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerPrivateServiceServer).DeletePrivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerPrivateService/DeletePrivate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerPrivateServiceServer).DeletePrivate(ctx, req.(*LoadBalancerDeletePrivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerPrivateService_SearchStreamPrivate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LoadBalancerSearchStreamPrivateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoadBalancerPrivateServiceServer).SearchStreamPrivate(m, &loadBalancerPrivateServiceSearchStreamPrivateServer{stream})
}

type LoadBalancerPrivateService_SearchStreamPrivateServer interface {
	Send(*LoadBalancerWatchResponse) error
	grpc.ServerStream
}

type loadBalancerPrivateServiceSearchStreamPrivateServer struct {
	grpc.ServerStream
}

func (x *loadBalancerPrivateServiceSearchStreamPrivateServer) Send(m *LoadBalancerWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _LoadBalancerPrivateService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LoadBalancerWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoadBalancerPrivateServiceServer).Watch(m, &loadBalancerPrivateServiceWatchServer{stream})
}

type LoadBalancerPrivateService_WatchServer interface {
	Send(*LoadBalancerWatchResponse) error
	grpc.ServerStream
}

type loadBalancerPrivateServiceWatchServer struct {
	grpc.ServerStream
}

func (x *loadBalancerPrivateServiceWatchServer) Send(m *LoadBalancerWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

// LoadBalancerPrivateService_ServiceDesc is the grpc.ServiceDesc for LoadBalancerPrivateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadBalancerPrivateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.LoadBalancerPrivateService",
	HandlerType: (*LoadBalancerPrivateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePrivate",
			Handler:    _LoadBalancerPrivateService_CreatePrivate_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _LoadBalancerPrivateService_UpdateStatus_Handler,
		},
		{
			MethodName: "RemoveFinalizer",
			Handler:    _LoadBalancerPrivateService_RemoveFinalizer_Handler,
		},
		{
			MethodName: "PingPrivate",
			Handler:    _LoadBalancerPrivateService_PingPrivate_Handler,
		},
		{
			MethodName: "DeletePrivate",
			Handler:    _LoadBalancerPrivateService_DeletePrivate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStreamPrivate",
			Handler:       _LoadBalancerPrivateService_SearchStreamPrivate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Watch",
			Handler:       _LoadBalancerPrivateService_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute_private.proto",
}
