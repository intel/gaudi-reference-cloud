// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: usage.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on InvalidProductUsageRecordsFilter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *InvalidProductUsageRecordsFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvalidProductUsageRecordsFilter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InvalidProductUsageRecordsFilterMultiError, or nil if none found.
func (m *InvalidProductUsageRecordsFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *InvalidProductUsageRecordsFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.RecordId != nil {
		// no validation rules for RecordId
	}

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.ProductName != nil {
		// no validation rules for ProductName
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordsFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordsFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordsFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordsFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordsFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordsFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvalidProductUsageRecordsFilterMultiError(errors)
	}

	return nil
}

// InvalidProductUsageRecordsFilterMultiError is an error wrapping multiple
// validation errors returned by
// InvalidProductUsageRecordsFilter.ValidateAll() if the designated
// constraints aren't met.
type InvalidProductUsageRecordsFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvalidProductUsageRecordsFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvalidProductUsageRecordsFilterMultiError) AllErrors() []error { return m }

// InvalidProductUsageRecordsFilterValidationError is the validation error
// returned by InvalidProductUsageRecordsFilter.Validate if the designated
// constraints aren't met.
type InvalidProductUsageRecordsFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvalidProductUsageRecordsFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvalidProductUsageRecordsFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvalidProductUsageRecordsFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvalidProductUsageRecordsFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvalidProductUsageRecordsFilterValidationError) ErrorName() string {
	return "InvalidProductUsageRecordsFilterValidationError"
}

// Error satisfies the builtin error interface
func (e InvalidProductUsageRecordsFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvalidProductUsageRecordsFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvalidProductUsageRecordsFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvalidProductUsageRecordsFilterValidationError{}

// Validate checks the field values on CreateInvalidProductUsageRecords with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateInvalidProductUsageRecords) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvalidProductUsageRecords with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateInvalidProductUsageRecordsMultiError, or nil if none found.
func (m *CreateInvalidProductUsageRecords) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvalidProductUsageRecords) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCreateInvalidProductUsageRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateInvalidProductUsageRecordsValidationError{
						field:  fmt.Sprintf("CreateInvalidProductUsageRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateInvalidProductUsageRecordsValidationError{
						field:  fmt.Sprintf("CreateInvalidProductUsageRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateInvalidProductUsageRecordsValidationError{
					field:  fmt.Sprintf("CreateInvalidProductUsageRecords[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateInvalidProductUsageRecordsMultiError(errors)
	}

	return nil
}

// CreateInvalidProductUsageRecordsMultiError is an error wrapping multiple
// validation errors returned by
// CreateInvalidProductUsageRecords.ValidateAll() if the designated
// constraints aren't met.
type CreateInvalidProductUsageRecordsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvalidProductUsageRecordsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvalidProductUsageRecordsMultiError) AllErrors() []error { return m }

// CreateInvalidProductUsageRecordsValidationError is the validation error
// returned by CreateInvalidProductUsageRecords.Validate if the designated
// constraints aren't met.
type CreateInvalidProductUsageRecordsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvalidProductUsageRecordsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvalidProductUsageRecordsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvalidProductUsageRecordsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvalidProductUsageRecordsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvalidProductUsageRecordsValidationError) ErrorName() string {
	return "CreateInvalidProductUsageRecordsValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvalidProductUsageRecordsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvalidProductUsageRecords.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvalidProductUsageRecordsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvalidProductUsageRecordsValidationError{}

// Validate checks the field values on InvalidProductUsageRecordCreate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvalidProductUsageRecordCreate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvalidProductUsageRecordCreate with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InvalidProductUsageRecordCreateMultiError, or nil if none found.
func (m *InvalidProductUsageRecordCreate) ValidateAll() error {
	return m.validate(true)
}

func (m *InvalidProductUsageRecordCreate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for CloudAccountId

	// no validation rules for Region

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvalidProductUsageRecordCreateValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvalidProductUsageRecordCreateValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvalidProductUsageRecordCreateValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Properties

	// no validation rules for ProductUsageRecordInvalidityReason

	if m.RecordId != nil {
		// no validation rules for RecordId
	}

	if m.ProductName != nil {
		// no validation rules for ProductName
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordCreateValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordCreateValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordCreateValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordCreateValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordCreateValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordCreateValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvalidProductUsageRecordCreateMultiError(errors)
	}

	return nil
}

// InvalidProductUsageRecordCreateMultiError is an error wrapping multiple
// validation errors returned by InvalidProductUsageRecordCreate.ValidateAll()
// if the designated constraints aren't met.
type InvalidProductUsageRecordCreateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvalidProductUsageRecordCreateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvalidProductUsageRecordCreateMultiError) AllErrors() []error { return m }

// InvalidProductUsageRecordCreateValidationError is the validation error
// returned by InvalidProductUsageRecordCreate.Validate if the designated
// constraints aren't met.
type InvalidProductUsageRecordCreateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvalidProductUsageRecordCreateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvalidProductUsageRecordCreateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvalidProductUsageRecordCreateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvalidProductUsageRecordCreateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvalidProductUsageRecordCreateValidationError) ErrorName() string {
	return "InvalidProductUsageRecordCreateValidationError"
}

// Error satisfies the builtin error interface
func (e InvalidProductUsageRecordCreateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvalidProductUsageRecordCreate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvalidProductUsageRecordCreateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvalidProductUsageRecordCreateValidationError{}

// Validate checks the field values on InvalidProductUsageRecords with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvalidProductUsageRecords) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvalidProductUsageRecords with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvalidProductUsageRecordsMultiError, or nil if none found.
func (m *InvalidProductUsageRecords) ValidateAll() error {
	return m.validate(true)
}

func (m *InvalidProductUsageRecords) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvalidProductUsageRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordsValidationError{
						field:  fmt.Sprintf("InvalidProductUsageRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordsValidationError{
						field:  fmt.Sprintf("InvalidProductUsageRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordsValidationError{
					field:  fmt.Sprintf("InvalidProductUsageRecords[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvalidProductUsageRecordsMultiError(errors)
	}

	return nil
}

// InvalidProductUsageRecordsMultiError is an error wrapping multiple
// validation errors returned by InvalidProductUsageRecords.ValidateAll() if
// the designated constraints aren't met.
type InvalidProductUsageRecordsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvalidProductUsageRecordsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvalidProductUsageRecordsMultiError) AllErrors() []error { return m }

// InvalidProductUsageRecordsValidationError is the validation error returned
// by InvalidProductUsageRecords.Validate if the designated constraints aren't met.
type InvalidProductUsageRecordsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvalidProductUsageRecordsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvalidProductUsageRecordsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvalidProductUsageRecordsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvalidProductUsageRecordsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvalidProductUsageRecordsValidationError) ErrorName() string {
	return "InvalidProductUsageRecordsValidationError"
}

// Error satisfies the builtin error interface
func (e InvalidProductUsageRecordsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvalidProductUsageRecords.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvalidProductUsageRecordsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvalidProductUsageRecordsValidationError{}

// Validate checks the field values on InvalidProductUsageRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvalidProductUsageRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvalidProductUsageRecord with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvalidProductUsageRecordMultiError, or nil if none found.
func (m *InvalidProductUsageRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *InvalidProductUsageRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TransactionId

	// no validation rules for CloudAccountId

	// no validation rules for Region

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvalidProductUsageRecordValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvalidProductUsageRecordValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvalidProductUsageRecordValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Properties

	// no validation rules for ProductUsageRecordInvalidityReason

	if m.RecordId != nil {
		// no validation rules for RecordId
	}

	if m.ProductName != nil {
		// no validation rules for ProductName
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvalidProductUsageRecordValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvalidProductUsageRecordValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvalidProductUsageRecordValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvalidProductUsageRecordMultiError(errors)
	}

	return nil
}

// InvalidProductUsageRecordMultiError is an error wrapping multiple validation
// errors returned by InvalidProductUsageRecord.ValidateAll() if the
// designated constraints aren't met.
type InvalidProductUsageRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvalidProductUsageRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvalidProductUsageRecordMultiError) AllErrors() []error { return m }

// InvalidProductUsageRecordValidationError is the validation error returned by
// InvalidProductUsageRecord.Validate if the designated constraints aren't met.
type InvalidProductUsageRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvalidProductUsageRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvalidProductUsageRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvalidProductUsageRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvalidProductUsageRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvalidProductUsageRecordValidationError) ErrorName() string {
	return "InvalidProductUsageRecordValidationError"
}

// Error satisfies the builtin error interface
func (e InvalidProductUsageRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvalidProductUsageRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvalidProductUsageRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvalidProductUsageRecordValidationError{}

// Validate checks the field values on ProductUsageRecordCreate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductUsageRecordCreate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsageRecordCreate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductUsageRecordCreateMultiError, or nil if none found.
func (m *ProductUsageRecordCreate) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsageRecordCreate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for CloudAccountId

	// no validation rules for Region

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductUsageRecordCreateValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductUsageRecordCreateValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductUsageRecordCreateValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Properties

	if m.ProductName != nil {
		// no validation rules for ProductName
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsageRecordCreateValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsageRecordCreateValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsageRecordCreateValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsageRecordCreateValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsageRecordCreateValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsageRecordCreateValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductUsageRecordCreateMultiError(errors)
	}

	return nil
}

// ProductUsageRecordCreateMultiError is an error wrapping multiple validation
// errors returned by ProductUsageRecordCreate.ValidateAll() if the designated
// constraints aren't met.
type ProductUsageRecordCreateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsageRecordCreateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsageRecordCreateMultiError) AllErrors() []error { return m }

// ProductUsageRecordCreateValidationError is the validation error returned by
// ProductUsageRecordCreate.Validate if the designated constraints aren't met.
type ProductUsageRecordCreateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsageRecordCreateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsageRecordCreateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsageRecordCreateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsageRecordCreateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsageRecordCreateValidationError) ErrorName() string {
	return "ProductUsageRecordCreateValidationError"
}

// Error satisfies the builtin error interface
func (e ProductUsageRecordCreateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsageRecordCreate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsageRecordCreateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsageRecordCreateValidationError{}

// Validate checks the field values on ProductUsageRecordsFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductUsageRecordsFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsageRecordsFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductUsageRecordsFilterMultiError, or nil if none found.
func (m *ProductUsageRecordsFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsageRecordsFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.Reported != nil {
		// no validation rules for Reported
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsageRecordsFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsageRecordsFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsageRecordsFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsageRecordsFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsageRecordsFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsageRecordsFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductUsageRecordsFilterMultiError(errors)
	}

	return nil
}

// ProductUsageRecordsFilterMultiError is an error wrapping multiple validation
// errors returned by ProductUsageRecordsFilter.ValidateAll() if the
// designated constraints aren't met.
type ProductUsageRecordsFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsageRecordsFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsageRecordsFilterMultiError) AllErrors() []error { return m }

// ProductUsageRecordsFilterValidationError is the validation error returned by
// ProductUsageRecordsFilter.Validate if the designated constraints aren't met.
type ProductUsageRecordsFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsageRecordsFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsageRecordsFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsageRecordsFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsageRecordsFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsageRecordsFilterValidationError) ErrorName() string {
	return "ProductUsageRecordsFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ProductUsageRecordsFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsageRecordsFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsageRecordsFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsageRecordsFilterValidationError{}

// Validate checks the field values on ProductUsageRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductUsageRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsageRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductUsageRecordMultiError, or nil if none found.
func (m *ProductUsageRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsageRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TransactionId

	// no validation rules for CloudAccountId

	// no validation rules for Region

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductUsageRecordValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductUsageRecordValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductUsageRecordValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reported

	// no validation rules for Properties

	if m.ProductName != nil {
		// no validation rules for ProductName
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsageRecordValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsageRecordValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsageRecordValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsageRecordValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsageRecordValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsageRecordValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductUsageRecordMultiError(errors)
	}

	return nil
}

// ProductUsageRecordMultiError is an error wrapping multiple validation errors
// returned by ProductUsageRecord.ValidateAll() if the designated constraints
// aren't met.
type ProductUsageRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsageRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsageRecordMultiError) AllErrors() []error { return m }

// ProductUsageRecordValidationError is the validation error returned by
// ProductUsageRecord.Validate if the designated constraints aren't met.
type ProductUsageRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsageRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsageRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsageRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsageRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsageRecordValidationError) ErrorName() string {
	return "ProductUsageRecordValidationError"
}

// Error satisfies the builtin error interface
func (e ProductUsageRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsageRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsageRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsageRecordValidationError{}

// Validate checks the field values on ResourceUsageId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResourceUsageId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsageId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceUsageIdMultiError, or nil if none found.
func (m *ResourceUsageId) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsageId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ResourceUsageIdMultiError(errors)
	}

	return nil
}

// ResourceUsageIdMultiError is an error wrapping multiple validation errors
// returned by ResourceUsageId.ValidateAll() if the designated constraints
// aren't met.
type ResourceUsageIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsageIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsageIdMultiError) AllErrors() []error { return m }

// ResourceUsageIdValidationError is the validation error returned by
// ResourceUsageId.Validate if the designated constraints aren't met.
type ResourceUsageIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsageIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsageIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsageIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsageIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsageIdValidationError) ErrorName() string { return "ResourceUsageIdValidationError" }

// Error satisfies the builtin error interface
func (e ResourceUsageIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsageId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsageIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsageIdValidationError{}

// Validate checks the field values on ProductUsageId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductUsageId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsageId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductUsageIdMultiError,
// or nil if none found.
func (m *ProductUsageId) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsageId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ProductUsageIdMultiError(errors)
	}

	return nil
}

// ProductUsageIdMultiError is an error wrapping multiple validation errors
// returned by ProductUsageId.ValidateAll() if the designated constraints
// aren't met.
type ProductUsageIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsageIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsageIdMultiError) AllErrors() []error { return m }

// ProductUsageIdValidationError is the validation error returned by
// ProductUsageId.Validate if the designated constraints aren't met.
type ProductUsageIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsageIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsageIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsageIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsageIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsageIdValidationError) ErrorName() string { return "ProductUsageIdValidationError" }

// Error satisfies the builtin error interface
func (e ProductUsageIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsageId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsageIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsageIdValidationError{}

// Validate checks the field values on ReportProductUsageId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportProductUsageId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportProductUsageId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportProductUsageIdMultiError, or nil if none found.
func (m *ReportProductUsageId) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportProductUsageId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ReportProductUsageIdMultiError(errors)
	}

	return nil
}

// ReportProductUsageIdMultiError is an error wrapping multiple validation
// errors returned by ReportProductUsageId.ValidateAll() if the designated
// constraints aren't met.
type ReportProductUsageIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportProductUsageIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportProductUsageIdMultiError) AllErrors() []error { return m }

// ReportProductUsageIdValidationError is the validation error returned by
// ReportProductUsageId.Validate if the designated constraints aren't met.
type ReportProductUsageIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportProductUsageIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportProductUsageIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportProductUsageIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportProductUsageIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportProductUsageIdValidationError) ErrorName() string {
	return "ReportProductUsageIdValidationError"
}

// Error satisfies the builtin error interface
func (e ReportProductUsageIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportProductUsageId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportProductUsageIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportProductUsageIdValidationError{}

// Validate checks the field values on ResourceUsagesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceUsagesFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsagesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceUsagesFilterMultiError, or nil if none found.
func (m *ResourceUsagesFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsagesFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ResourceId != nil {
		// no validation rules for ResourceId
	}

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceUsagesFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceUsagesFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceUsagesFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceUsagesFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceUsagesFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceUsagesFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Reported != nil {
		// no validation rules for Reported
	}

	if len(errors) > 0 {
		return ResourceUsagesFilterMultiError(errors)
	}

	return nil
}

// ResourceUsagesFilterMultiError is an error wrapping multiple validation
// errors returned by ResourceUsagesFilter.ValidateAll() if the designated
// constraints aren't met.
type ResourceUsagesFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsagesFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsagesFilterMultiError) AllErrors() []error { return m }

// ResourceUsagesFilterValidationError is the validation error returned by
// ResourceUsagesFilter.Validate if the designated constraints aren't met.
type ResourceUsagesFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsagesFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsagesFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsagesFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsagesFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsagesFilterValidationError) ErrorName() string {
	return "ResourceUsagesFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceUsagesFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsagesFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsagesFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsagesFilterValidationError{}

// Validate checks the field values on ResourceUsageCreate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceUsageCreate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsageCreate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceUsageCreateMultiError, or nil if none found.
func (m *ResourceUsageCreate) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsageCreate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for ResourceId

	// no validation rules for ResourceName

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for TransactionId

	// no validation rules for Region

	// no validation rules for Quantity

	// no validation rules for Rate

	// no validation rules for UsageUnitType

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceUsageCreateValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceUsageCreateValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceUsageCreateValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceUsageCreateValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceUsageCreateValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceUsageCreateValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResourceUsageCreateMultiError(errors)
	}

	return nil
}

// ResourceUsageCreateMultiError is an error wrapping multiple validation
// errors returned by ResourceUsageCreate.ValidateAll() if the designated
// constraints aren't met.
type ResourceUsageCreateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsageCreateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsageCreateMultiError) AllErrors() []error { return m }

// ResourceUsageCreateValidationError is the validation error returned by
// ResourceUsageCreate.Validate if the designated constraints aren't met.
type ResourceUsageCreateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsageCreateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsageCreateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsageCreateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsageCreateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsageCreateValidationError) ErrorName() string {
	return "ResourceUsageCreateValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceUsageCreateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsageCreate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsageCreateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsageCreateValidationError{}

// Validate checks the field values on ResourceUsageUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceUsageUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsageUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceUsageUpdateMultiError, or nil if none found.
func (m *ResourceUsageUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsageUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceUsageId

	// no validation rules for UnReportedQuantity

	if len(errors) > 0 {
		return ResourceUsageUpdateMultiError(errors)
	}

	return nil
}

// ResourceUsageUpdateMultiError is an error wrapping multiple validation
// errors returned by ResourceUsageUpdate.ValidateAll() if the designated
// constraints aren't met.
type ResourceUsageUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsageUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsageUpdateMultiError) AllErrors() []error { return m }

// ResourceUsageUpdateValidationError is the validation error returned by
// ResourceUsageUpdate.Validate if the designated constraints aren't met.
type ResourceUsageUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsageUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsageUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsageUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsageUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsageUpdateValidationError) ErrorName() string {
	return "ResourceUsageUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceUsageUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsageUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsageUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsageUpdateValidationError{}

// Validate checks the field values on ReportProductUsageUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportProductUsageUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportProductUsageUpdate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportProductUsageUpdateMultiError, or nil if none found.
func (m *ReportProductUsageUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportProductUsageUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductUsageReportId

	// no validation rules for UnReportedQuantity

	if len(errors) > 0 {
		return ReportProductUsageUpdateMultiError(errors)
	}

	return nil
}

// ReportProductUsageUpdateMultiError is an error wrapping multiple validation
// errors returned by ReportProductUsageUpdate.ValidateAll() if the designated
// constraints aren't met.
type ReportProductUsageUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportProductUsageUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportProductUsageUpdateMultiError) AllErrors() []error { return m }

// ReportProductUsageUpdateValidationError is the validation error returned by
// ReportProductUsageUpdate.Validate if the designated constraints aren't met.
type ReportProductUsageUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportProductUsageUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportProductUsageUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportProductUsageUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportProductUsageUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportProductUsageUpdateValidationError) ErrorName() string {
	return "ReportProductUsageUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e ReportProductUsageUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportProductUsageUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportProductUsageUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportProductUsageUpdateValidationError{}

// Validate checks the field values on ResourceUsageCreateFailed with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceUsageCreateFailed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsageCreateFailed with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceUsageCreateFailedMultiError, or nil if none found.
func (m *ResourceUsageCreateFailed) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsageCreateFailed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for ResourceId

	// no validation rules for ResourceName

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for Region

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return ResourceUsageCreateFailedMultiError(errors)
	}

	return nil
}

// ResourceUsageCreateFailedMultiError is an error wrapping multiple validation
// errors returned by ResourceUsageCreateFailed.ValidateAll() if the
// designated constraints aren't met.
type ResourceUsageCreateFailedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsageCreateFailedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsageCreateFailedMultiError) AllErrors() []error { return m }

// ResourceUsageCreateFailedValidationError is the validation error returned by
// ResourceUsageCreateFailed.Validate if the designated constraints aren't met.
type ResourceUsageCreateFailedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsageCreateFailedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsageCreateFailedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsageCreateFailedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsageCreateFailedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsageCreateFailedValidationError) ErrorName() string {
	return "ResourceUsageCreateFailedValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceUsageCreateFailedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsageCreateFailed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsageCreateFailedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsageCreateFailedValidationError{}

// Validate checks the field values on BulkUploadResourceUsagesFailed with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkUploadResourceUsagesFailed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkUploadResourceUsagesFailed with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkUploadResourceUsagesFailedMultiError, or nil if none found.
func (m *BulkUploadResourceUsagesFailed) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkUploadResourceUsagesFailed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResourceUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkUploadResourceUsagesFailedValidationError{
						field:  fmt.Sprintf("ResourceUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkUploadResourceUsagesFailedValidationError{
						field:  fmt.Sprintf("ResourceUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkUploadResourceUsagesFailedValidationError{
					field:  fmt.Sprintf("ResourceUsages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkUploadResourceUsagesFailedMultiError(errors)
	}

	return nil
}

// BulkUploadResourceUsagesFailedMultiError is an error wrapping multiple
// validation errors returned by BulkUploadResourceUsagesFailed.ValidateAll()
// if the designated constraints aren't met.
type BulkUploadResourceUsagesFailedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkUploadResourceUsagesFailedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkUploadResourceUsagesFailedMultiError) AllErrors() []error { return m }

// BulkUploadResourceUsagesFailedValidationError is the validation error
// returned by BulkUploadResourceUsagesFailed.Validate if the designated
// constraints aren't met.
type BulkUploadResourceUsagesFailedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkUploadResourceUsagesFailedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkUploadResourceUsagesFailedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkUploadResourceUsagesFailedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkUploadResourceUsagesFailedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkUploadResourceUsagesFailedValidationError) ErrorName() string {
	return "BulkUploadResourceUsagesFailedValidationError"
}

// Error satisfies the builtin error interface
func (e BulkUploadResourceUsagesFailedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkUploadResourceUsagesFailed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkUploadResourceUsagesFailedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkUploadResourceUsagesFailedValidationError{}

// Validate checks the field values on BulkUploadResourceUsages with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkUploadResourceUsages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkUploadResourceUsages with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BulkUploadResourceUsagesMultiError, or nil if none found.
func (m *BulkUploadResourceUsages) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkUploadResourceUsages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResourceUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkUploadResourceUsagesValidationError{
						field:  fmt.Sprintf("ResourceUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkUploadResourceUsagesValidationError{
						field:  fmt.Sprintf("ResourceUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkUploadResourceUsagesValidationError{
					field:  fmt.Sprintf("ResourceUsages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkUploadResourceUsagesMultiError(errors)
	}

	return nil
}

// BulkUploadResourceUsagesMultiError is an error wrapping multiple validation
// errors returned by BulkUploadResourceUsages.ValidateAll() if the designated
// constraints aren't met.
type BulkUploadResourceUsagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkUploadResourceUsagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkUploadResourceUsagesMultiError) AllErrors() []error { return m }

// BulkUploadResourceUsagesValidationError is the validation error returned by
// BulkUploadResourceUsages.Validate if the designated constraints aren't met.
type BulkUploadResourceUsagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkUploadResourceUsagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkUploadResourceUsagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkUploadResourceUsagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkUploadResourceUsagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkUploadResourceUsagesValidationError) ErrorName() string {
	return "BulkUploadResourceUsagesValidationError"
}

// Error satisfies the builtin error interface
func (e BulkUploadResourceUsagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkUploadResourceUsages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkUploadResourceUsagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkUploadResourceUsagesValidationError{}

// Validate checks the field values on ResourceUsage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceUsage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceUsageMultiError, or
// nil if none found.
func (m *ResourceUsage) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CloudAccountId

	// no validation rules for ResourceId

	// no validation rules for ResourceName

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for Region

	// no validation rules for TransactionId

	// no validation rules for Quantity

	// no validation rules for UnReportedQuantity

	// no validation rules for Rate

	// no validation rules for UsageUnitType

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceUsageValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceUsageValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceUsageValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceUsageValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceUsageValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceUsageValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceUsageValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceUsageValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceUsageValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reported

	if len(errors) > 0 {
		return ResourceUsageMultiError(errors)
	}

	return nil
}

// ResourceUsageMultiError is an error wrapping multiple validation errors
// returned by ResourceUsage.ValidateAll() if the designated constraints
// aren't met.
type ResourceUsageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsageMultiError) AllErrors() []error { return m }

// ResourceUsageValidationError is the validation error returned by
// ResourceUsage.Validate if the designated constraints aren't met.
type ResourceUsageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsageValidationError) ErrorName() string { return "ResourceUsageValidationError" }

// Error satisfies the builtin error interface
func (e ResourceUsageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsageValidationError{}

// Validate checks the field values on ResourceUsages with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceUsages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceUsages with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceUsagesMultiError,
// or nil if none found.
func (m *ResourceUsages) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceUsages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResourceUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceUsagesValidationError{
						field:  fmt.Sprintf("ResourceUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceUsagesValidationError{
						field:  fmt.Sprintf("ResourceUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceUsagesValidationError{
					field:  fmt.Sprintf("ResourceUsages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResourceUsagesMultiError(errors)
	}

	return nil
}

// ResourceUsagesMultiError is an error wrapping multiple validation errors
// returned by ResourceUsages.ValidateAll() if the designated constraints
// aren't met.
type ResourceUsagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceUsagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceUsagesMultiError) AllErrors() []error { return m }

// ResourceUsagesValidationError is the validation error returned by
// ResourceUsages.Validate if the designated constraints aren't met.
type ResourceUsagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceUsagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceUsagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceUsagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceUsagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceUsagesValidationError) ErrorName() string { return "ResourceUsagesValidationError" }

// Error satisfies the builtin error interface
func (e ResourceUsagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceUsages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceUsagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceUsagesValidationError{}

// Validate checks the field values on ProductUsagesReportFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductUsagesReportFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsagesReportFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductUsagesReportFilterMultiError, or nil if none found.
func (m *ProductUsagesReportFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsagesReportFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ProductId != nil {
		// no validation rules for ProductId
	}

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.Reported != nil {
		// no validation rules for Reported
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsagesReportFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsagesReportFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsagesReportFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsagesReportFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsagesReportFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsagesReportFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductUsagesReportFilterMultiError(errors)
	}

	return nil
}

// ProductUsagesReportFilterMultiError is an error wrapping multiple validation
// errors returned by ProductUsagesReportFilter.ValidateAll() if the
// designated constraints aren't met.
type ProductUsagesReportFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsagesReportFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsagesReportFilterMultiError) AllErrors() []error { return m }

// ProductUsagesReportFilterValidationError is the validation error returned by
// ProductUsagesReportFilter.Validate if the designated constraints aren't met.
type ProductUsagesReportFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsagesReportFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsagesReportFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsagesReportFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsagesReportFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsagesReportFilterValidationError) ErrorName() string {
	return "ProductUsagesReportFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ProductUsagesReportFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsagesReportFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsagesReportFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsagesReportFilterValidationError{}

// Validate checks the field values on ProductUsagesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductUsagesFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsagesFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductUsagesFilterMultiError, or nil if none found.
func (m *ProductUsagesFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsagesFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ProductId != nil {
		// no validation rules for ProductId
	}

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsagesFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsagesFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsagesFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsagesFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsagesFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsagesFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductUsagesFilterMultiError(errors)
	}

	return nil
}

// ProductUsagesFilterMultiError is an error wrapping multiple validation
// errors returned by ProductUsagesFilter.ValidateAll() if the designated
// constraints aren't met.
type ProductUsagesFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsagesFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsagesFilterMultiError) AllErrors() []error { return m }

// ProductUsagesFilterValidationError is the validation error returned by
// ProductUsagesFilter.Validate if the designated constraints aren't met.
type ProductUsagesFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsagesFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsagesFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsagesFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsagesFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsagesFilterValidationError) ErrorName() string {
	return "ProductUsagesFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ProductUsagesFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsagesFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsagesFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsagesFilterValidationError{}

// Validate checks the field values on UsagesFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UsagesFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UsagesFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UsagesFilterMultiError, or
// nil if none found.
func (m *UsagesFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *UsagesFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UsagesFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UsagesFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsagesFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UsagesFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UsagesFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsagesFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UsagesFilterMultiError(errors)
	}

	return nil
}

// UsagesFilterMultiError is an error wrapping multiple validation errors
// returned by UsagesFilter.ValidateAll() if the designated constraints aren't met.
type UsagesFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UsagesFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UsagesFilterMultiError) AllErrors() []error { return m }

// UsagesFilterValidationError is the validation error returned by
// UsagesFilter.Validate if the designated constraints aren't met.
type UsagesFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsagesFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsagesFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsagesFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsagesFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsagesFilterValidationError) ErrorName() string { return "UsagesFilterValidationError" }

// Error satisfies the builtin error interface
func (e UsagesFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsagesFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsagesFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsagesFilterValidationError{}

// Validate checks the field values on ProductUsage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductUsage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductUsageMultiError, or
// nil if none found.
func (m *ProductUsage) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CloudAccountId

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for Region

	// no validation rules for Quantity

	// no validation rules for Rate

	// no validation rules for UsageUnitType

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductUsageValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductUsageValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductUsageValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductUsageValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductUsageValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductUsageValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductUsageValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductUsageValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductUsageValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductUsageMultiError(errors)
	}

	return nil
}

// ProductUsageMultiError is an error wrapping multiple validation errors
// returned by ProductUsage.ValidateAll() if the designated constraints aren't met.
type ProductUsageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsageMultiError) AllErrors() []error { return m }

// ProductUsageValidationError is the validation error returned by
// ProductUsage.Validate if the designated constraints aren't met.
type ProductUsageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsageValidationError) ErrorName() string { return "ProductUsageValidationError" }

// Error satisfies the builtin error interface
func (e ProductUsageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsageValidationError{}

// Validate checks the field values on ReportProductUsage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportProductUsage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportProductUsage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportProductUsageMultiError, or nil if none found.
func (m *ReportProductUsage) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportProductUsage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProductUsageId

	// no validation rules for CloudAccountId

	// no validation rules for ProductId

	// no validation rules for ProductName

	// no validation rules for Quantity

	// no validation rules for Rate

	// no validation rules for UnReportedQuantity

	// no validation rules for UsageUnitType

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportProductUsageValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportProductUsageValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportProductUsageValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportProductUsageValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportProductUsageValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportProductUsageValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportProductUsageValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportProductUsageValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportProductUsageValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reported

	if len(errors) > 0 {
		return ReportProductUsageMultiError(errors)
	}

	return nil
}

// ReportProductUsageMultiError is an error wrapping multiple validation errors
// returned by ReportProductUsage.ValidateAll() if the designated constraints
// aren't met.
type ReportProductUsageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportProductUsageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportProductUsageMultiError) AllErrors() []error { return m }

// ReportProductUsageValidationError is the validation error returned by
// ReportProductUsage.Validate if the designated constraints aren't met.
type ReportProductUsageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportProductUsageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportProductUsageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportProductUsageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportProductUsageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportProductUsageValidationError) ErrorName() string {
	return "ReportProductUsageValidationError"
}

// Error satisfies the builtin error interface
func (e ReportProductUsageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportProductUsage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportProductUsageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportProductUsageValidationError{}

// Validate checks the field values on ProductUsages with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductUsages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUsages with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductUsagesMultiError, or
// nil if none found.
func (m *ProductUsages) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUsages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProductUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductUsagesValidationError{
						field:  fmt.Sprintf("ProductUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductUsagesValidationError{
						field:  fmt.Sprintf("ProductUsages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductUsagesValidationError{
					field:  fmt.Sprintf("ProductUsages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductUsagesMultiError(errors)
	}

	return nil
}

// ProductUsagesMultiError is an error wrapping multiple validation errors
// returned by ProductUsages.ValidateAll() if the designated constraints
// aren't met.
type ProductUsagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUsagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUsagesMultiError) AllErrors() []error { return m }

// ProductUsagesValidationError is the validation error returned by
// ProductUsages.Validate if the designated constraints aren't met.
type ProductUsagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUsagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUsagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUsagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUsagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUsagesValidationError) ErrorName() string { return "ProductUsagesValidationError" }

// Error satisfies the builtin error interface
func (e ProductUsagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUsages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUsagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUsagesValidationError{}

// Validate checks the field values on Usages with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Usages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Usages with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UsagesMultiError, or nil if none found.
func (m *Usages) ValidateAll() error {
	return m.validate(true)
}

func (m *Usages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalAmount

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UsagesValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UsagesValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UsagesValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Period

	// no validation rules for TotalQuantity

	for idx, item := range m.GetUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UsagesValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UsagesValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsagesValidationError{
					field:  fmt.Sprintf("Usages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UsagesMultiError(errors)
	}

	return nil
}

// UsagesMultiError is an error wrapping multiple validation errors returned by
// Usages.ValidateAll() if the designated constraints aren't met.
type UsagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UsagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UsagesMultiError) AllErrors() []error { return m }

// UsagesValidationError is the validation error returned by Usages.Validate if
// the designated constraints aren't met.
type UsagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsagesValidationError) ErrorName() string { return "UsagesValidationError" }

// Error satisfies the builtin error interface
func (e UsagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsagesValidationError{}

// Validate checks the field values on UsageV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UsageV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UsageV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UsageV2MultiError, or nil if none found.
func (m *UsageV2) ValidateAll() error {
	return m.validate(true)
}

func (m *UsageV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for ProductName

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UsageV2ValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UsageV2ValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UsageV2ValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UsageV2ValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UsageV2ValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UsageV2ValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	// no validation rules for Amount

	// no validation rules for Rate

	// no validation rules for Region

	// no validation rules for UsageUnitType

	if len(errors) > 0 {
		return UsageV2MultiError(errors)
	}

	return nil
}

// UsageV2MultiError is an error wrapping multiple validation errors returned
// by UsageV2.ValidateAll() if the designated constraints aren't met.
type UsageV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UsageV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UsageV2MultiError) AllErrors() []error { return m }

// UsageV2ValidationError is the validation error returned by UsageV2.Validate
// if the designated constraints aren't met.
type UsageV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsageV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsageV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsageV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsageV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsageV2ValidationError) ErrorName() string { return "UsageV2ValidationError" }

// Error satisfies the builtin error interface
func (e UsageV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsageV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsageV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsageV2ValidationError{}
