// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: iks_admin.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetClusterAdmin with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetClusterAdmin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterAdmin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterAdminMultiError, or nil if none found.
func (m *GetClusterAdmin) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterAdmin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Account

	// no validation rules for Provider

	// no validation rules for Region

	// no validation rules for K8Sversion

	for idx, item := range m.GetCertsexpiring() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Certsexpiring[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Certsexpiring[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterAdminValidationError{
					field:  fmt.Sprintf("Certsexpiring[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetNetwork()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterAdminValidationError{
					field:  "Network",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterAdminValidationError{
					field:  "Network",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetwork()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterAdminValidationError{
				field:  "Network",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNodegroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterAdminValidationError{
					field:  fmt.Sprintf("Nodegroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAddons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Addons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Addons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterAdminValidationError{
					field:  fmt.Sprintf("Addons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSnapshot() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Snapshot[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Snapshot[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterAdminValidationError{
					field:  fmt.Sprintf("Snapshot[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBackup() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Backup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Backup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterAdminValidationError{
					field:  fmt.Sprintf("Backup[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for K8Supgradeavailable

	// no validation rules for Storageenabled

	for idx, item := range m.GetStorages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Storages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClusterAdminValidationError{
						field:  fmt.Sprintf("Storages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClusterAdminValidationError{
					field:  fmt.Sprintf("Storages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Clustertype

	if len(errors) > 0 {
		return GetClusterAdminMultiError(errors)
	}

	return nil
}

// GetClusterAdminMultiError is an error wrapping multiple validation errors
// returned by GetClusterAdmin.ValidateAll() if the designated constraints
// aren't met.
type GetClusterAdminMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterAdminMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterAdminMultiError) AllErrors() []error { return m }

// GetClusterAdminValidationError is the validation error returned by
// GetClusterAdmin.Validate if the designated constraints aren't met.
type GetClusterAdminValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterAdminValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterAdminValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterAdminValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterAdminValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterAdminValidationError) ErrorName() string { return "GetClusterAdminValidationError" }

// Error satisfies the builtin error interface
func (e GetClusterAdminValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterAdmin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterAdminValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterAdminValidationError{}

// Validate checks the field values on GetClustersAdmin with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetClustersAdmin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClustersAdmin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClustersAdminMultiError, or nil if none found.
func (m *GetClustersAdmin) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClustersAdmin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClustersAdminValidationError{
						field:  fmt.Sprintf("Response[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClustersAdminValidationError{
						field:  fmt.Sprintf("Response[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClustersAdminValidationError{
					field:  fmt.Sprintf("Response[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetClustersAdminMultiError(errors)
	}

	return nil
}

// GetClustersAdminMultiError is an error wrapping multiple validation errors
// returned by GetClustersAdmin.ValidateAll() if the designated constraints
// aren't met.
type GetClustersAdminMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClustersAdminMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClustersAdminMultiError) AllErrors() []error { return m }

// GetClustersAdminValidationError is the validation error returned by
// GetClustersAdmin.Validate if the designated constraints aren't met.
type GetClustersAdminValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClustersAdminValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClustersAdminValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClustersAdminValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClustersAdminValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClustersAdminValidationError) ErrorName() string { return "GetClustersAdminValidationError" }

// Error satisfies the builtin error interface
func (e GetClustersAdminValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClustersAdmin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClustersAdminValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClustersAdminValidationError{}

// Validate checks the field values on ClustersResponseAdmin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClustersResponseAdmin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClustersResponseAdmin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClustersResponseAdminMultiError, or nil if none found.
func (m *ClustersResponseAdmin) ValidateAll() error {
	return m.validate(true)
}

func (m *ClustersResponseAdmin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for Account

	// no validation rules for Name

	// no validation rules for State

	// no validation rules for K8Sversion

	// no validation rules for Provider

	// no validation rules for Cpupgradeavailable

	// no validation rules for K8Supgradeavailable

	// no validation rules for Createddate

	// no validation rules for Clustertype

	for idx, item := range m.GetNodegroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClustersResponseAdminValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClustersResponseAdminValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClustersResponseAdminValidationError{
					field:  fmt.Sprintf("Nodegroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClustersResponseAdminMultiError(errors)
	}

	return nil
}

// ClustersResponseAdminMultiError is an error wrapping multiple validation
// errors returned by ClustersResponseAdmin.ValidateAll() if the designated
// constraints aren't met.
type ClustersResponseAdminMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClustersResponseAdminMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClustersResponseAdminMultiError) AllErrors() []error { return m }

// ClustersResponseAdminValidationError is the validation error returned by
// ClustersResponseAdmin.Validate if the designated constraints aren't met.
type ClustersResponseAdminValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClustersResponseAdminValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClustersResponseAdminValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClustersResponseAdminValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClustersResponseAdminValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClustersResponseAdminValidationError) ErrorName() string {
	return "ClustersResponseAdminValidationError"
}

// Error satisfies the builtin error interface
func (e ClustersResponseAdminValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClustersResponseAdmin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClustersResponseAdminValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClustersResponseAdminValidationError{}

// Validate checks the field values on ClusterCerts with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterCerts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterCerts with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterCertsMultiError, or
// nil if none found.
func (m *ClusterCerts) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterCerts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cpname

	// no validation rules for Certexpirydate

	if len(errors) > 0 {
		return ClusterCertsMultiError(errors)
	}

	return nil
}

// ClusterCertsMultiError is an error wrapping multiple validation errors
// returned by ClusterCerts.ValidateAll() if the designated constraints aren't met.
type ClusterCertsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterCertsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterCertsMultiError) AllErrors() []error { return m }

// ClusterCertsValidationError is the validation error returned by
// ClusterCerts.Validate if the designated constraints aren't met.
type ClusterCertsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterCertsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterCertsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterCertsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterCertsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterCertsValidationError) ErrorName() string { return "ClusterCertsValidationError" }

// Error satisfies the builtin error interface
func (e ClusterCertsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterCerts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterCertsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterCertsValidationError{}

// Validate checks the field values on NetworkAdmin with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetworkAdmin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkAdmin with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkAdminMultiError, or
// nil if none found.
func (m *NetworkAdmin) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkAdmin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Servicecidr

	// no validation rules for Clustercidr

	for idx, item := range m.GetLoadbalancer() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkAdminValidationError{
						field:  fmt.Sprintf("Loadbalancer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkAdminValidationError{
						field:  fmt.Sprintf("Loadbalancer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkAdminValidationError{
					field:  fmt.Sprintf("Loadbalancer[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NetworkAdminMultiError(errors)
	}

	return nil
}

// NetworkAdminMultiError is an error wrapping multiple validation errors
// returned by NetworkAdmin.ValidateAll() if the designated constraints aren't met.
type NetworkAdminMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkAdminMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkAdminMultiError) AllErrors() []error { return m }

// NetworkAdminValidationError is the validation error returned by
// NetworkAdmin.Validate if the designated constraints aren't met.
type NetworkAdminValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkAdminValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkAdminValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkAdminValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkAdminValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkAdminValidationError) ErrorName() string { return "NetworkAdminValidationError" }

// Error satisfies the builtin error interface
func (e NetworkAdminValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkAdmin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkAdminValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkAdminValidationError{}

// Validate checks the field values on Loadbalancer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Loadbalancer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Loadbalancer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadbalancerMultiError, or
// nil if none found.
func (m *Loadbalancer) ValidateAll() error {
	return m.validate(true)
}

func (m *Loadbalancer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lbname

	// no validation rules for Vip

	// no validation rules for Status

	// no validation rules for Viptype

	// no validation rules for Nodegrouptype

	// no validation rules for Createddate

	if len(errors) > 0 {
		return LoadbalancerMultiError(errors)
	}

	return nil
}

// LoadbalancerMultiError is an error wrapping multiple validation errors
// returned by Loadbalancer.ValidateAll() if the designated constraints aren't met.
type LoadbalancerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadbalancerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadbalancerMultiError) AllErrors() []error { return m }

// LoadbalancerValidationError is the validation error returned by
// Loadbalancer.Validate if the designated constraints aren't met.
type LoadbalancerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadbalancerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadbalancerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadbalancerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadbalancerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadbalancerValidationError) ErrorName() string { return "LoadbalancerValidationError" }

// Error satisfies the builtin error interface
func (e LoadbalancerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadbalancer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadbalancerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadbalancerValidationError{}

// Validate checks the field values on PostLoadbalancerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostLoadbalancerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostLoadbalancerRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostLoadbalancerRequestMultiError, or nil if none found.
func (m *PostLoadbalancerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostLoadbalancerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	if all {
		switch v := interface{}(m.GetLb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostLoadbalancerRequestValidationError{
					field:  "Lb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostLoadbalancerRequestValidationError{
					field:  "Lb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostLoadbalancerRequestValidationError{
				field:  "Lb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PostLoadbalancerRequestMultiError(errors)
	}

	return nil
}

// PostLoadbalancerRequestMultiError is an error wrapping multiple validation
// errors returned by PostLoadbalancerRequest.ValidateAll() if the designated
// constraints aren't met.
type PostLoadbalancerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostLoadbalancerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostLoadbalancerRequestMultiError) AllErrors() []error { return m }

// PostLoadbalancerRequestValidationError is the validation error returned by
// PostLoadbalancerRequest.Validate if the designated constraints aren't met.
type PostLoadbalancerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostLoadbalancerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostLoadbalancerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostLoadbalancerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostLoadbalancerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostLoadbalancerRequestValidationError) ErrorName() string {
	return "PostLoadbalancerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PostLoadbalancerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostLoadbalancerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostLoadbalancerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostLoadbalancerRequestValidationError{}

// Validate checks the field values on LoadbalancerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoadbalancerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadbalancerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoadbalancerResponseMultiError, or nil if none found.
func (m *LoadbalancerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadbalancerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lbid

	if all {
		switch v := interface{}(m.GetLb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadbalancerResponseValidationError{
					field:  "Lb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadbalancerResponseValidationError{
					field:  "Lb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadbalancerResponseValidationError{
				field:  "Lb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadbalancerResponseMultiError(errors)
	}

	return nil
}

// LoadbalancerResponseMultiError is an error wrapping multiple validation
// errors returned by LoadbalancerResponse.ValidateAll() if the designated
// constraints aren't met.
type LoadbalancerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadbalancerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadbalancerResponseMultiError) AllErrors() []error { return m }

// LoadbalancerResponseValidationError is the validation error returned by
// LoadbalancerResponse.Validate if the designated constraints aren't met.
type LoadbalancerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadbalancerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadbalancerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadbalancerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadbalancerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadbalancerResponseValidationError) ErrorName() string {
	return "LoadbalancerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e LoadbalancerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadbalancerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadbalancerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadbalancerResponseValidationError{}

// Validate checks the field values on LoadBalancers with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadBalancers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadBalancers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadBalancersMultiError, or
// nil if none found.
func (m *LoadBalancers) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadBalancers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLbresponses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoadBalancersValidationError{
						field:  fmt.Sprintf("Lbresponses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoadBalancersValidationError{
						field:  fmt.Sprintf("Lbresponses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancersValidationError{
					field:  fmt.Sprintf("Lbresponses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoadBalancersMultiError(errors)
	}

	return nil
}

// LoadBalancersMultiError is an error wrapping multiple validation errors
// returned by LoadBalancers.ValidateAll() if the designated constraints
// aren't met.
type LoadBalancersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadBalancersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadBalancersMultiError) AllErrors() []error { return m }

// LoadBalancersValidationError is the validation error returned by
// LoadBalancers.Validate if the designated constraints aren't met.
type LoadBalancersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadBalancersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadBalancersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancersValidationError) ErrorName() string { return "LoadBalancersValidationError" }

// Error satisfies the builtin error interface
func (e LoadBalancersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancersValidationError{}

// Validate checks the field values on PutLoadbalancerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutLoadbalancerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutLoadbalancerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutLoadbalancerRequestMultiError, or nil if none found.
func (m *PutLoadbalancerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutLoadbalancerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Lbid

	if all {
		switch v := interface{}(m.GetLb()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutLoadbalancerRequestValidationError{
					field:  "Lb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutLoadbalancerRequestValidationError{
					field:  "Lb",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLb()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutLoadbalancerRequestValidationError{
				field:  "Lb",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutLoadbalancerRequestMultiError(errors)
	}

	return nil
}

// PutLoadbalancerRequestMultiError is an error wrapping multiple validation
// errors returned by PutLoadbalancerRequest.ValidateAll() if the designated
// constraints aren't met.
type PutLoadbalancerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutLoadbalancerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutLoadbalancerRequestMultiError) AllErrors() []error { return m }

// PutLoadbalancerRequestValidationError is the validation error returned by
// PutLoadbalancerRequest.Validate if the designated constraints aren't met.
type PutLoadbalancerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutLoadbalancerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutLoadbalancerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutLoadbalancerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutLoadbalancerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutLoadbalancerRequestValidationError) ErrorName() string {
	return "PutLoadbalancerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutLoadbalancerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutLoadbalancerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutLoadbalancerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutLoadbalancerRequestValidationError{}

// Validate checks the field values on GetLbRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLbRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLbRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLbRequestMultiError, or
// nil if none found.
func (m *GetLbRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLbRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Lbid

	if len(errors) > 0 {
		return GetLbRequestMultiError(errors)
	}

	return nil
}

// GetLbRequestMultiError is an error wrapping multiple validation errors
// returned by GetLbRequest.ValidateAll() if the designated constraints aren't met.
type GetLbRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLbRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLbRequestMultiError) AllErrors() []error { return m }

// GetLbRequestValidationError is the validation error returned by
// GetLbRequest.Validate if the designated constraints aren't met.
type GetLbRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLbRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLbRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLbRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLbRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLbRequestValidationError) ErrorName() string { return "GetLbRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLbRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLbRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLbRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLbRequestValidationError{}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Ipaddress

	// no validation rules for Dnsname

	// no validation rules for Imi

	// no validation rules for State

	// no validation rules for Status

	// no validation rules for Createddate

	if all {
		switch v := interface{}(m.GetWekaStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeValidationError{
					field:  "WekaStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeValidationError{
					field:  "WekaStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWekaStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeValidationError{
				field:  "WekaStorage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on WekaStorageStatusAdmin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WekaStorageStatusAdmin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WekaStorageStatusAdmin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WekaStorageStatusAdminMultiError, or nil if none found.
func (m *WekaStorageStatusAdmin) ValidateAll() error {
	return m.validate(true)
}

func (m *WekaStorageStatusAdmin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	// no validation rules for Status

	// no validation rules for CustomStatus

	// no validation rules for Message

	if len(errors) > 0 {
		return WekaStorageStatusAdminMultiError(errors)
	}

	return nil
}

// WekaStorageStatusAdminMultiError is an error wrapping multiple validation
// errors returned by WekaStorageStatusAdmin.ValidateAll() if the designated
// constraints aren't met.
type WekaStorageStatusAdminMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WekaStorageStatusAdminMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WekaStorageStatusAdminMultiError) AllErrors() []error { return m }

// WekaStorageStatusAdminValidationError is the validation error returned by
// WekaStorageStatusAdmin.Validate if the designated constraints aren't met.
type WekaStorageStatusAdminValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WekaStorageStatusAdminValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WekaStorageStatusAdminValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WekaStorageStatusAdminValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WekaStorageStatusAdminValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WekaStorageStatusAdminValidationError) ErrorName() string {
	return "WekaStorageStatusAdminValidationError"
}

// Error satisfies the builtin error interface
func (e WekaStorageStatusAdminValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWekaStorageStatusAdmin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WekaStorageStatusAdminValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WekaStorageStatusAdminValidationError{}

// Validate checks the field values on Nodegroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Nodegroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Nodegroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodegroupMultiError, or nil
// if none found.
func (m *Nodegroup) ValidateAll() error {
	return m.validate(true)
}

func (m *Nodegroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Count

	// no validation rules for Releaseversion

	// no validation rules for Status

	// no validation rules for Imiupgradeavailable

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Imi

	// no validation rules for Instancetype

	for idx, item := range m.GetSshkey() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupValidationError{
						field:  fmt.Sprintf("Sshkey[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupValidationError{
						field:  fmt.Sprintf("Sshkey[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupValidationError{
					field:  fmt.Sprintf("Sshkey[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Nodegrouptype

	// no validation rules for Nodegrouptypename

	// no validation rules for Nodgroupuuid

	if m.Nodegroupsummary != nil {

		if all {
			switch v := interface{}(m.GetNodegroupsummary()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupValidationError{
						field:  "Nodegroupsummary",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupValidationError{
						field:  "Nodegroupsummary",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNodegroupsummary()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupValidationError{
					field:  "Nodegroupsummary",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodegroupMultiError(errors)
	}

	return nil
}

// NodegroupMultiError is an error wrapping multiple validation errors returned
// by Nodegroup.ValidateAll() if the designated constraints aren't met.
type NodegroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodegroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodegroupMultiError) AllErrors() []error { return m }

// NodegroupValidationError is the validation error returned by
// Nodegroup.Validate if the designated constraints aren't met.
type NodegroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodegroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodegroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodegroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodegroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodegroupValidationError) ErrorName() string { return "NodegroupValidationError" }

// Error satisfies the builtin error interface
func (e NodegroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodegroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodegroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodegroupValidationError{}

// Validate checks the field values on AddOnAdmin with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddOnAdmin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddOnAdmin with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddOnAdminMultiError, or
// nil if none found.
func (m *AddOnAdmin) ValidateAll() error {
	return m.validate(true)
}

func (m *AddOnAdmin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for State

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddOnAdminValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddOnAdminValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddOnAdminValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddOnAdminValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddOnAdminValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddOnAdminValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Artifact

	if len(errors) > 0 {
		return AddOnAdminMultiError(errors)
	}

	return nil
}

// AddOnAdminMultiError is an error wrapping multiple validation errors
// returned by AddOnAdmin.ValidateAll() if the designated constraints aren't met.
type AddOnAdminMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddOnAdminMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddOnAdminMultiError) AllErrors() []error { return m }

// AddOnAdminValidationError is the validation error returned by
// AddOnAdmin.Validate if the designated constraints aren't met.
type AddOnAdminValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddOnAdminValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddOnAdminValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddOnAdminValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddOnAdminValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddOnAdminValidationError) ErrorName() string { return "AddOnAdminValidationError" }

// Error satisfies the builtin error interface
func (e AddOnAdminValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddOnAdmin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddOnAdminValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddOnAdminValidationError{}

// Validate checks the field values on Snapshot with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Snapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Snapshot with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SnapshotMultiError, or nil
// if none found.
func (m *Snapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *Snapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for State

	// no validation rules for Created

	// no validation rules for Filename

	if len(errors) > 0 {
		return SnapshotMultiError(errors)
	}

	return nil
}

// SnapshotMultiError is an error wrapping multiple validation errors returned
// by Snapshot.ValidateAll() if the designated constraints aren't met.
type SnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnapshotMultiError) AllErrors() []error { return m }

// SnapshotValidationError is the validation error returned by
// Snapshot.Validate if the designated constraints aren't met.
type SnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnapshotValidationError) ErrorName() string { return "SnapshotValidationError" }

// Error satisfies the builtin error interface
func (e SnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnapshotValidationError{}

// Validate checks the field values on Backup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Backup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Backup with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BackupMultiError, or nil if none found.
func (m *Backup) ValidateAll() error {
	return m.validate(true)
}

func (m *Backup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Key

	// no validation rules for Folder

	// no validation rules for Region

	// no validation rules for Endpoint

	if len(errors) > 0 {
		return BackupMultiError(errors)
	}

	return nil
}

// BackupMultiError is an error wrapping multiple validation errors returned by
// Backup.ValidateAll() if the designated constraints aren't met.
type BackupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackupMultiError) AllErrors() []error { return m }

// BackupValidationError is the validation error returned by Backup.Validate if
// the designated constraints aren't met.
type BackupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackupValidationError) ErrorName() string { return "BackupValidationError" }

// Error satisfies the builtin error interface
func (e BackupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackupValidationError{}

// Validate checks the field values on AdminClusterID with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AdminClusterID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdminClusterID with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdminClusterIDMultiError,
// or nil if none found.
func (m *AdminClusterID) ValidateAll() error {
	return m.validate(true)
}

func (m *AdminClusterID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	if len(errors) > 0 {
		return AdminClusterIDMultiError(errors)
	}

	return nil
}

// AdminClusterIDMultiError is an error wrapping multiple validation errors
// returned by AdminClusterID.ValidateAll() if the designated constraints
// aren't met.
type AdminClusterIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdminClusterIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdminClusterIDMultiError) AllErrors() []error { return m }

// AdminClusterIDValidationError is the validation error returned by
// AdminClusterID.Validate if the designated constraints aren't met.
type AdminClusterIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdminClusterIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdminClusterIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdminClusterIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdminClusterIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdminClusterIDValidationError) ErrorName() string { return "AdminClusterIDValidationError" }

// Error satisfies the builtin error interface
func (e AdminClusterIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdminClusterID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdminClusterIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdminClusterIDValidationError{}

// Validate checks the field values on IMIRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IMIRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IMIRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IMIRequestMultiError, or
// nil if none found.
func (m *IMIRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IMIRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Upstreamreleasename

	// no validation rules for Provider

	// no validation rules for Type

	// no validation rules for Runtime

	// no validation rules for Os

	for idx, item := range m.GetComponents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IMIRequestValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IMIRequestValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IMIRequestValidationError{
					field:  fmt.Sprintf("Components[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Bootstraprepo

	// no validation rules for State

	// no validation rules for Artifact

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return IMIRequestMultiError(errors)
	}

	return nil
}

// IMIRequestMultiError is an error wrapping multiple validation errors
// returned by IMIRequest.ValidateAll() if the designated constraints aren't met.
type IMIRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IMIRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IMIRequestMultiError) AllErrors() []error { return m }

// IMIRequestValidationError is the validation error returned by
// IMIRequest.Validate if the designated constraints aren't met.
type IMIRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IMIRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IMIRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IMIRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IMIRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IMIRequestValidationError) ErrorName() string { return "IMIRequestValidationError" }

// Error satisfies the builtin error interface
func (e IMIRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIMIRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IMIRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IMIRequestValidationError{}

// Validate checks the field values on Component with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Component) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Component with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentMultiError, or nil
// if none found.
func (m *Component) ValidateAll() error {
	return m.validate(true)
}

func (m *Component) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Artifact

	if len(errors) > 0 {
		return ComponentMultiError(errors)
	}

	return nil
}

// ComponentMultiError is an error wrapping multiple validation errors returned
// by Component.ValidateAll() if the designated constraints aren't met.
type ComponentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentMultiError) AllErrors() []error { return m }

// ComponentValidationError is the validation error returned by
// Component.Validate if the designated constraints aren't met.
type ComponentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentValidationError) ErrorName() string { return "ComponentValidationError" }

// Error satisfies the builtin error interface
func (e ComponentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentValidationError{}

// Validate checks the field values on IMIResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IMIResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IMIResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IMIResponseMultiError, or
// nil if none found.
func (m *IMIResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IMIResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Upstreamreleasename

	// no validation rules for Provider

	// no validation rules for Type

	// no validation rules for Runtime

	// no validation rules for Os

	// no validation rules for State

	for idx, item := range m.GetComponents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IMIResponseValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IMIResponseValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IMIResponseValidationError{
					field:  fmt.Sprintf("Components[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Bootstraprepo

	// no validation rules for Artifact

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for Iscompatabilityactiveimi

	for idx, item := range m.GetInstanceTypeResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IMIResponseValidationError{
						field:  fmt.Sprintf("InstanceTypeResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IMIResponseValidationError{
						field:  fmt.Sprintf("InstanceTypeResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IMIResponseValidationError{
					field:  fmt.Sprintf("InstanceTypeResponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstacetypeimik8Scompatibilityresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IMIResponseValidationError{
						field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IMIResponseValidationError{
						field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IMIResponseValidationError{
					field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Isk8SActive

	if len(errors) > 0 {
		return IMIResponseMultiError(errors)
	}

	return nil
}

// IMIResponseMultiError is an error wrapping multiple validation errors
// returned by IMIResponse.ValidateAll() if the designated constraints aren't met.
type IMIResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IMIResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IMIResponseMultiError) AllErrors() []error { return m }

// IMIResponseValidationError is the validation error returned by
// IMIResponse.Validate if the designated constraints aren't met.
type IMIResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IMIResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IMIResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IMIResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IMIResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IMIResponseValidationError) ErrorName() string { return "IMIResponseValidationError" }

// Error satisfies the builtin error interface
func (e IMIResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIMIResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IMIResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IMIResponseValidationError{}

// Validate checks the field values on GetIMIResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetIMIResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIMIResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetIMIResponseMultiError,
// or nil if none found.
func (m *GetIMIResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIMIResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetImiresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIMIResponseValidationError{
						field:  fmt.Sprintf("Imiresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIMIResponseValidationError{
						field:  fmt.Sprintf("Imiresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIMIResponseValidationError{
					field:  fmt.Sprintf("Imiresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIMIResponseMultiError(errors)
	}

	return nil
}

// GetIMIResponseMultiError is an error wrapping multiple validation errors
// returned by GetIMIResponse.ValidateAll() if the designated constraints
// aren't met.
type GetIMIResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIMIResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIMIResponseMultiError) AllErrors() []error { return m }

// GetIMIResponseValidationError is the validation error returned by
// GetIMIResponse.Validate if the designated constraints aren't met.
type GetIMIResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIMIResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIMIResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIMIResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIMIResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIMIResponseValidationError) ErrorName() string { return "GetIMIResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetIMIResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIMIResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIMIResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIMIResponseValidationError{}

// Validate checks the field values on Runtimes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Runtimes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Runtimes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimesMultiError, or nil
// if none found.
func (m *Runtimes) ValidateAll() error {
	return m.validate(true)
}

func (m *Runtimes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Runtime

	if len(errors) > 0 {
		return RuntimesMultiError(errors)
	}

	return nil
}

// RuntimesMultiError is an error wrapping multiple validation errors returned
// by Runtimes.ValidateAll() if the designated constraints aren't met.
type RuntimesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimesMultiError) AllErrors() []error { return m }

// RuntimesValidationError is the validation error returned by
// Runtimes.Validate if the designated constraints aren't met.
type RuntimesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimesValidationError) ErrorName() string { return "RuntimesValidationError" }

// Error satisfies the builtin error interface
func (e RuntimesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimesValidationError{}

// Validate checks the field values on OSImages with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OSImages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OSImages with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OSImagesMultiError, or nil
// if none found.
func (m *OSImages) ValidateAll() error {
	return m.validate(true)
}

func (m *OSImages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Osimage

	if len(errors) > 0 {
		return OSImagesMultiError(errors)
	}

	return nil
}

// OSImagesMultiError is an error wrapping multiple validation errors returned
// by OSImages.ValidateAll() if the designated constraints aren't met.
type OSImagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OSImagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OSImagesMultiError) AllErrors() []error { return m }

// OSImagesValidationError is the validation error returned by
// OSImages.Validate if the designated constraints aren't met.
type OSImagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OSImagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OSImagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OSImagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OSImagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OSImagesValidationError) ErrorName() string { return "OSImagesValidationError" }

// Error satisfies the builtin error interface
func (e OSImagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOSImages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OSImagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OSImagesValidationError{}

// Validate checks the field values on Providers with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Providers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Providers with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProvidersMultiError, or nil
// if none found.
func (m *Providers) ValidateAll() error {
	return m.validate(true)
}

func (m *Providers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	if len(errors) > 0 {
		return ProvidersMultiError(errors)
	}

	return nil
}

// ProvidersMultiError is an error wrapping multiple validation errors returned
// by Providers.ValidateAll() if the designated constraints aren't met.
type ProvidersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvidersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvidersMultiError) AllErrors() []error { return m }

// ProvidersValidationError is the validation error returned by
// Providers.Validate if the designated constraints aren't met.
type ProvidersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvidersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvidersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvidersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvidersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvidersValidationError) ErrorName() string { return "ProvidersValidationError" }

// Error satisfies the builtin error interface
func (e ProvidersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProviders.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvidersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvidersValidationError{}

// Validate checks the field values on States with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *States) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on States with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StatesMultiError, or nil if none found.
func (m *States) ValidateAll() error {
	return m.validate(true)
}

func (m *States) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	if len(errors) > 0 {
		return StatesMultiError(errors)
	}

	return nil
}

// StatesMultiError is an error wrapping multiple validation errors returned by
// States.ValidateAll() if the designated constraints aren't met.
type StatesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatesMultiError) AllErrors() []error { return m }

// StatesValidationError is the validation error returned by States.Validate if
// the designated constraints aren't met.
type StatesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatesValidationError) ErrorName() string { return "StatesValidationError" }

// Error satisfies the builtin error interface
func (e StatesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStates.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatesValidationError{}

// Validate checks the field values on GetIMIsInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIMIsInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIMIsInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIMIsInfoResponseMultiError, or nil if none found.
func (m *GetIMIsInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIMIsInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRuntime() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("Runtime[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("Runtime[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIMIsInfoResponseValidationError{
					field:  fmt.Sprintf("Runtime[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOsimage() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("Osimage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("Osimage[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIMIsInfoResponseValidationError{
					field:  fmt.Sprintf("Osimage[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetProvider() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("Provider[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("Provider[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIMIsInfoResponseValidationError{
					field:  fmt.Sprintf("Provider[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetState() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("State[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIMIsInfoResponseValidationError{
						field:  fmt.Sprintf("State[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIMIsInfoResponseValidationError{
					field:  fmt.Sprintf("State[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIMIsInfoResponseMultiError(errors)
	}

	return nil
}

// GetIMIsInfoResponseMultiError is an error wrapping multiple validation
// errors returned by GetIMIsInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIMIsInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIMIsInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIMIsInfoResponseMultiError) AllErrors() []error { return m }

// GetIMIsInfoResponseValidationError is the validation error returned by
// GetIMIsInfoResponse.Validate if the designated constraints aren't met.
type GetIMIsInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIMIsInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIMIsInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIMIsInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIMIsInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIMIsInfoResponseValidationError) ErrorName() string {
	return "GetIMIsInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIMIsInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIMIsInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIMIsInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIMIsInfoResponseValidationError{}

// Validate checks the field values on UpdateIMIRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateIMIRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIMIRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIMIRequestMultiError, or nil if none found.
func (m *UpdateIMIRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIMIRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Upstreamreleasename

	// no validation rules for Provider

	// no validation rules for Type

	// no validation rules for Runtime

	// no validation rules for Os

	for idx, item := range m.GetComponents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIMIRequestValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIMIRequestValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIMIRequestValidationError{
					field:  fmt.Sprintf("Components[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Bootstraprepo

	// no validation rules for State

	// no validation rules for Artifact

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return UpdateIMIRequestMultiError(errors)
	}

	return nil
}

// UpdateIMIRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateIMIRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateIMIRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIMIRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIMIRequestMultiError) AllErrors() []error { return m }

// UpdateIMIRequestValidationError is the validation error returned by
// UpdateIMIRequest.Validate if the designated constraints aren't met.
type UpdateIMIRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIMIRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIMIRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIMIRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIMIRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIMIRequestValidationError) ErrorName() string { return "UpdateIMIRequestValidationError" }

// Error satisfies the builtin error interface
func (e UpdateIMIRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIMIRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIMIRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIMIRequestValidationError{}

// Validate checks the field values on GetIMIRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetIMIRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIMIRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetIMIRequestMultiError, or
// nil if none found.
func (m *GetIMIRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIMIRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return GetIMIRequestMultiError(errors)
	}

	return nil
}

// GetIMIRequestMultiError is an error wrapping multiple validation errors
// returned by GetIMIRequest.ValidateAll() if the designated constraints
// aren't met.
type GetIMIRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIMIRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIMIRequestMultiError) AllErrors() []error { return m }

// GetIMIRequestValidationError is the validation error returned by
// GetIMIRequest.Validate if the designated constraints aren't met.
type GetIMIRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIMIRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIMIRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIMIRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIMIRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIMIRequestValidationError) ErrorName() string { return "GetIMIRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetIMIRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIMIRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIMIRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIMIRequestValidationError{}

// Validate checks the field values on DeleteIMIRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteIMIRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIMIRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIMIRequestMultiError, or nil if none found.
func (m *DeleteIMIRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIMIRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return DeleteIMIRequestMultiError(errors)
	}

	return nil
}

// DeleteIMIRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteIMIRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteIMIRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIMIRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIMIRequestMultiError) AllErrors() []error { return m }

// DeleteIMIRequestValidationError is the validation error returned by
// DeleteIMIRequest.Validate if the designated constraints aren't met.
type DeleteIMIRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIMIRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIMIRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIMIRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIMIRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIMIRequestValidationError) ErrorName() string { return "DeleteIMIRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteIMIRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIMIRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIMIRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIMIRequestValidationError{}

// Validate checks the field values on IMIInstanceTypeK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IMIInstanceTypeK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IMIInstanceTypeK8SRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IMIInstanceTypeK8SRequestMultiError, or nil if none found.
func (m *IMIInstanceTypeK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IMIInstanceTypeK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Runtime

	// no validation rules for Upstreamreleasename

	// no validation rules for Os

	// no validation rules for Type

	// no validation rules for Provider

	// no validation rules for State

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return IMIInstanceTypeK8SRequestMultiError(errors)
	}

	return nil
}

// IMIInstanceTypeK8SRequestMultiError is an error wrapping multiple validation
// errors returned by IMIInstanceTypeK8SRequest.ValidateAll() if the
// designated constraints aren't met.
type IMIInstanceTypeK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IMIInstanceTypeK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IMIInstanceTypeK8SRequestMultiError) AllErrors() []error { return m }

// IMIInstanceTypeK8SRequestValidationError is the validation error returned by
// IMIInstanceTypeK8SRequest.Validate if the designated constraints aren't met.
type IMIInstanceTypeK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IMIInstanceTypeK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IMIInstanceTypeK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IMIInstanceTypeK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IMIInstanceTypeK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IMIInstanceTypeK8SRequestValidationError) ErrorName() string {
	return "IMIInstanceTypeK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IMIInstanceTypeK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIMIInstanceTypeK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IMIInstanceTypeK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IMIInstanceTypeK8SRequestValidationError{}

// Validate checks the field values on IMIInstanceTypeK8SResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IMIInstanceTypeK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IMIInstanceTypeK8SResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IMIInstanceTypeK8SResponseMultiError, or nil if none found.
func (m *IMIInstanceTypeK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IMIInstanceTypeK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Osimageinstance

	// no validation rules for Runtime

	// no validation rules for Upstreamreleasename

	// no validation rules for Os

	// no validation rules for Type

	// no validation rules for Provider

	// no validation rules for State

	if len(errors) > 0 {
		return IMIInstanceTypeK8SResponseMultiError(errors)
	}

	return nil
}

// IMIInstanceTypeK8SResponseMultiError is an error wrapping multiple
// validation errors returned by IMIInstanceTypeK8SResponse.ValidateAll() if
// the designated constraints aren't met.
type IMIInstanceTypeK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IMIInstanceTypeK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IMIInstanceTypeK8SResponseMultiError) AllErrors() []error { return m }

// IMIInstanceTypeK8SResponseValidationError is the validation error returned
// by IMIInstanceTypeK8SResponse.Validate if the designated constraints aren't met.
type IMIInstanceTypeK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IMIInstanceTypeK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IMIInstanceTypeK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IMIInstanceTypeK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IMIInstanceTypeK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IMIInstanceTypeK8SResponseValidationError) ErrorName() string {
	return "IMIInstanceTypeK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IMIInstanceTypeK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIMIInstanceTypeK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IMIInstanceTypeK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IMIInstanceTypeK8SResponseValidationError{}

// Validate checks the field values on InstanceTypeIMIK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceTypeIMIK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTypeIMIK8SRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTypeIMIK8SRequestMultiError, or nil if none found.
func (m *InstanceTypeIMIK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTypeIMIK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Nodeprovidername

	// no validation rules for Category

	// no validation rules for Family

	for idx, item := range m.GetInstacetypeimik8Scompatibilityresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTypeIMIK8SRequestValidationError{
						field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTypeIMIK8SRequestValidationError{
						field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTypeIMIK8SRequestValidationError{
					field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return InstanceTypeIMIK8SRequestMultiError(errors)
	}

	return nil
}

// InstanceTypeIMIK8SRequestMultiError is an error wrapping multiple validation
// errors returned by InstanceTypeIMIK8SRequest.ValidateAll() if the
// designated constraints aren't met.
type InstanceTypeIMIK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTypeIMIK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTypeIMIK8SRequestMultiError) AllErrors() []error { return m }

// InstanceTypeIMIK8SRequestValidationError is the validation error returned by
// InstanceTypeIMIK8SRequest.Validate if the designated constraints aren't met.
type InstanceTypeIMIK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTypeIMIK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTypeIMIK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTypeIMIK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTypeIMIK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTypeIMIK8SRequestValidationError) ErrorName() string {
	return "InstanceTypeIMIK8SRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceTypeIMIK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTypeIMIK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTypeIMIK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTypeIMIK8SRequestValidationError{}

// Validate checks the field values on InstanceTypeIMIK8SResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceTypeIMIK8SResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTypeIMIK8SResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTypeIMIK8SResponseMultiError, or nil if none found.
func (m *InstanceTypeIMIK8SResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTypeIMIK8SResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Nodeprovidername

	// no validation rules for Category

	// no validation rules for Family

	if len(errors) > 0 {
		return InstanceTypeIMIK8SResponseMultiError(errors)
	}

	return nil
}

// InstanceTypeIMIK8SResponseMultiError is an error wrapping multiple
// validation errors returned by InstanceTypeIMIK8SResponse.ValidateAll() if
// the designated constraints aren't met.
type InstanceTypeIMIK8SResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTypeIMIK8SResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTypeIMIK8SResponseMultiError) AllErrors() []error { return m }

// InstanceTypeIMIK8SResponseValidationError is the validation error returned
// by InstanceTypeIMIK8SResponse.Validate if the designated constraints aren't met.
type InstanceTypeIMIK8SResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTypeIMIK8SResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTypeIMIK8SResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTypeIMIK8SResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTypeIMIK8SResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTypeIMIK8SResponseValidationError) ErrorName() string {
	return "InstanceTypeIMIK8SResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceTypeIMIK8SResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTypeIMIK8SResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTypeIMIK8SResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTypeIMIK8SResponseValidationError{}

// Validate checks the field values on InstacetypeIMIK8SCompatibility with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstacetypeIMIK8SCompatibility) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstacetypeIMIK8SCompatibility with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InstacetypeIMIK8SCompatibilityMultiError, or nil if none found.
func (m *InstacetypeIMIK8SCompatibility) ValidateAll() error {
	return m.validate(true)
}

func (m *InstacetypeIMIK8SCompatibility) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Artifact

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for Name

	// no validation rules for Cposimageinstances

	// no validation rules for Upstreamreleasename

	// no validation rules for Runtime

	// no validation rules for Provider

	// no validation rules for Type

	// no validation rules for Os

	if len(errors) > 0 {
		return InstacetypeIMIK8SCompatibilityMultiError(errors)
	}

	return nil
}

// InstacetypeIMIK8SCompatibilityMultiError is an error wrapping multiple
// validation errors returned by InstacetypeIMIK8SCompatibility.ValidateAll()
// if the designated constraints aren't met.
type InstacetypeIMIK8SCompatibilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstacetypeIMIK8SCompatibilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstacetypeIMIK8SCompatibilityMultiError) AllErrors() []error { return m }

// InstacetypeIMIK8SCompatibilityValidationError is the validation error
// returned by InstacetypeIMIK8SCompatibility.Validate if the designated
// constraints aren't met.
type InstacetypeIMIK8SCompatibilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstacetypeIMIK8SCompatibilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstacetypeIMIK8SCompatibilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstacetypeIMIK8SCompatibilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstacetypeIMIK8SCompatibilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstacetypeIMIK8SCompatibilityValidationError) ErrorName() string {
	return "InstacetypeIMIK8SCompatibilityValidationError"
}

// Error satisfies the builtin error interface
func (e InstacetypeIMIK8SCompatibilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstacetypeIMIK8SCompatibility.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstacetypeIMIK8SCompatibilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstacetypeIMIK8SCompatibilityValidationError{}

// Validate checks the field values on Createk8SversionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Createk8SversionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Createk8SversionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Createk8SversionRequestMultiError, or nil if none found.
func (m *Createk8SversionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *Createk8SversionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Runtime

	// no validation rules for Provider

	// no validation rules for Cpimi

	// no validation rules for Workimi

	if len(errors) > 0 {
		return Createk8SversionRequestMultiError(errors)
	}

	return nil
}

// Createk8SversionRequestMultiError is an error wrapping multiple validation
// errors returned by Createk8SversionRequest.ValidateAll() if the designated
// constraints aren't met.
type Createk8SversionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Createk8SversionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Createk8SversionRequestMultiError) AllErrors() []error { return m }

// Createk8SversionRequestValidationError is the validation error returned by
// Createk8SversionRequest.Validate if the designated constraints aren't met.
type Createk8SversionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Createk8SversionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Createk8SversionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Createk8SversionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Createk8SversionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Createk8SversionRequestValidationError) ErrorName() string {
	return "Createk8SversionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e Createk8SversionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatek8SversionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Createk8SversionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Createk8SversionRequestValidationError{}

// Validate checks the field values on K8SversionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *K8SversionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SversionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SversionResponseMultiError, or nil if none found.
func (m *K8SversionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SversionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Runtime

	// no validation rules for Releasename

	// no validation rules for Provider

	// no validation rules for Cpimi

	// no validation rules for Workimi

	// no validation rules for State

	// no validation rules for Minor

	// no validation rules for Major

	if len(errors) > 0 {
		return K8SversionResponseMultiError(errors)
	}

	return nil
}

// K8SversionResponseMultiError is an error wrapping multiple validation errors
// returned by K8SversionResponse.ValidateAll() if the designated constraints
// aren't met.
type K8SversionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SversionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SversionResponseMultiError) AllErrors() []error { return m }

// K8SversionResponseValidationError is the validation error returned by
// K8SversionResponse.Validate if the designated constraints aren't met.
type K8SversionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SversionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SversionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SversionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SversionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SversionResponseValidationError) ErrorName() string {
	return "K8SversionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e K8SversionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SversionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SversionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SversionResponseValidationError{}

// Validate checks the field values on GetK8SRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetK8SRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetK8SRequestMultiError, or
// nil if none found.
func (m *GetK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return GetK8SRequestMultiError(errors)
	}

	return nil
}

// GetK8SRequestMultiError is an error wrapping multiple validation errors
// returned by GetK8SRequest.ValidateAll() if the designated constraints
// aren't met.
type GetK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetK8SRequestMultiError) AllErrors() []error { return m }

// GetK8SRequestValidationError is the validation error returned by
// GetK8SRequest.Validate if the designated constraints aren't met.
type GetK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetK8SRequestValidationError) ErrorName() string { return "GetK8SRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetK8SRequestValidationError{}

// Validate checks the field values on GetK8SVersionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetK8SVersionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetK8SVersionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetK8SVersionResponseMultiError, or nil if none found.
func (m *GetK8SVersionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetK8SVersionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetK8Sversions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetK8SVersionResponseValidationError{
						field:  fmt.Sprintf("K8Sversions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetK8SVersionResponseValidationError{
						field:  fmt.Sprintf("K8Sversions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetK8SVersionResponseValidationError{
					field:  fmt.Sprintf("K8Sversions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetK8SVersionResponseMultiError(errors)
	}

	return nil
}

// GetK8SVersionResponseMultiError is an error wrapping multiple validation
// errors returned by GetK8SVersionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetK8SVersionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetK8SVersionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetK8SVersionResponseMultiError) AllErrors() []error { return m }

// GetK8SVersionResponseValidationError is the validation error returned by
// GetK8SVersionResponse.Validate if the designated constraints aren't met.
type GetK8SVersionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetK8SVersionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetK8SVersionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetK8SVersionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetK8SVersionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetK8SVersionResponseValidationError) ErrorName() string {
	return "GetK8SVersionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetK8SVersionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetK8SVersionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetK8SVersionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetK8SVersionResponseValidationError{}

// Validate checks the field values on UpdateK8SRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateK8SRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateK8SRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateK8SRequestMultiError, or nil if none found.
func (m *UpdateK8SRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateK8SRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Cpimi

	// no validation rules for Workimi

	// no validation rules for State

	if len(errors) > 0 {
		return UpdateK8SRequestMultiError(errors)
	}

	return nil
}

// UpdateK8SRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateK8SRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateK8SRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateK8SRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateK8SRequestMultiError) AllErrors() []error { return m }

// UpdateK8SRequestValidationError is the validation error returned by
// UpdateK8SRequest.Validate if the designated constraints aren't met.
type UpdateK8SRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateK8SRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateK8SRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateK8SRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateK8SRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateK8SRequestValidationError) ErrorName() string { return "UpdateK8SRequestValidationError" }

// Error satisfies the builtin error interface
func (e UpdateK8SRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateK8SRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateK8SRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateK8SRequestValidationError{}

// Validate checks the field values on CreateAddonAdminRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAddonAdminRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAddonAdminRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAddonAdminRequestMultiError, or nil if none found.
func (m *CreateAddonAdminRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAddonAdminRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for K8Sversion

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAddonAdminRequestValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAddonAdminRequestValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAddonAdminRequestValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAddonAdminRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAddonAdminRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAddonAdminRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Adminonly

	// no validation rules for State

	// no validation rules for Type

	// no validation rules for Upgradeavailable

	if len(errors) > 0 {
		return CreateAddonAdminRequestMultiError(errors)
	}

	return nil
}

// CreateAddonAdminRequestMultiError is an error wrapping multiple validation
// errors returned by CreateAddonAdminRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateAddonAdminRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAddonAdminRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAddonAdminRequestMultiError) AllErrors() []error { return m }

// CreateAddonAdminRequestValidationError is the validation error returned by
// CreateAddonAdminRequest.Validate if the designated constraints aren't met.
type CreateAddonAdminRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAddonAdminRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAddonAdminRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAddonAdminRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAddonAdminRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAddonAdminRequestValidationError) ErrorName() string {
	return "CreateAddonAdminRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAddonAdminRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAddonAdminRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAddonAdminRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAddonAdminRequestValidationError{}

// Validate checks the field values on Keyvaluepair with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Keyvaluepair) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Keyvaluepair with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyvaluepairMultiError, or
// nil if none found.
func (m *Keyvaluepair) ValidateAll() error {
	return m.validate(true)
}

func (m *Keyvaluepair) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return KeyvaluepairMultiError(errors)
	}

	return nil
}

// KeyvaluepairMultiError is an error wrapping multiple validation errors
// returned by Keyvaluepair.ValidateAll() if the designated constraints aren't met.
type KeyvaluepairMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyvaluepairMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyvaluepairMultiError) AllErrors() []error { return m }

// KeyvaluepairValidationError is the validation error returned by
// Keyvaluepair.Validate if the designated constraints aren't met.
type KeyvaluepairValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyvaluepairValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyvaluepairValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyvaluepairValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyvaluepairValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyvaluepairValidationError) ErrorName() string { return "KeyvaluepairValidationError" }

// Error satisfies the builtin error interface
func (e KeyvaluepairValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyvaluepair.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyvaluepairValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyvaluepairValidationError{}

// Validate checks the field values on AddonResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddonResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddonResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddonResponseMultiError, or
// nil if none found.
func (m *AddonResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddonResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for K8Sversion

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddonResponseValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddonResponseValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddonResponseValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddonResponseValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddonResponseValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddonResponseValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for State

	// no validation rules for Adminonly

	// no validation rules for Type

	// no validation rules for Upgradeavailable

	if len(errors) > 0 {
		return AddonResponseMultiError(errors)
	}

	return nil
}

// AddonResponseMultiError is an error wrapping multiple validation errors
// returned by AddonResponse.ValidateAll() if the designated constraints
// aren't met.
type AddonResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddonResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddonResponseMultiError) AllErrors() []error { return m }

// AddonResponseValidationError is the validation error returned by
// AddonResponse.Validate if the designated constraints aren't met.
type AddonResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddonResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddonResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddonResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddonResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddonResponseValidationError) ErrorName() string { return "AddonResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddonResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddonResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddonResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddonResponseValidationError{}

// Validate checks the field values on GetAddOnResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAddOnResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAddOnResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAddOnResponseMultiError, or nil if none found.
func (m *GetAddOnResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAddOnResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAddonresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAddOnResponseValidationError{
						field:  fmt.Sprintf("Addonresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAddOnResponseValidationError{
						field:  fmt.Sprintf("Addonresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAddOnResponseValidationError{
					field:  fmt.Sprintf("Addonresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAddOnResponseMultiError(errors)
	}

	return nil
}

// GetAddOnResponseMultiError is an error wrapping multiple validation errors
// returned by GetAddOnResponse.ValidateAll() if the designated constraints
// aren't met.
type GetAddOnResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddOnResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddOnResponseMultiError) AllErrors() []error { return m }

// GetAddOnResponseValidationError is the validation error returned by
// GetAddOnResponse.Validate if the designated constraints aren't met.
type GetAddOnResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddOnResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddOnResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddOnResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddOnResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddOnResponseValidationError) ErrorName() string { return "GetAddOnResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetAddOnResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddOnResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddOnResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddOnResponseValidationError{}

// Validate checks the field values on GetAddOnAdminRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAddOnAdminRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAddOnAdminRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAddOnAdminRequestMultiError, or nil if none found.
func (m *GetAddOnAdminRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAddOnAdminRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return GetAddOnAdminRequestMultiError(errors)
	}

	return nil
}

// GetAddOnAdminRequestMultiError is an error wrapping multiple validation
// errors returned by GetAddOnAdminRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAddOnAdminRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddOnAdminRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddOnAdminRequestMultiError) AllErrors() []error { return m }

// GetAddOnAdminRequestValidationError is the validation error returned by
// GetAddOnAdminRequest.Validate if the designated constraints aren't met.
type GetAddOnAdminRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddOnAdminRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddOnAdminRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddOnAdminRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddOnAdminRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddOnAdminRequestValidationError) ErrorName() string {
	return "GetAddOnAdminRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddOnAdminRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddOnAdminRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddOnAdminRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddOnAdminRequestValidationError{}

// Validate checks the field values on UpdateAddOnAdminRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAddOnAdminRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAddOnAdminRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateAddOnAdminRequestMultiError, or nil if none found.
func (m *UpdateAddOnAdminRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAddOnAdminRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for K8Sversion

	// no validation rules for Artifact

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateAddOnAdminRequestValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateAddOnAdminRequestValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateAddOnAdminRequestValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateAddOnAdminRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateAddOnAdminRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateAddOnAdminRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Adminonly

	// no validation rules for State

	// no validation rules for Type

	if len(errors) > 0 {
		return UpdateAddOnAdminRequestMultiError(errors)
	}

	return nil
}

// UpdateAddOnAdminRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateAddOnAdminRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateAddOnAdminRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAddOnAdminRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAddOnAdminRequestMultiError) AllErrors() []error { return m }

// UpdateAddOnAdminRequestValidationError is the validation error returned by
// UpdateAddOnAdminRequest.Validate if the designated constraints aren't met.
type UpdateAddOnAdminRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAddOnAdminRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAddOnAdminRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAddOnAdminRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAddOnAdminRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAddOnAdminRequestValidationError) ErrorName() string {
	return "UpdateAddOnAdminRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAddOnAdminRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAddOnAdminRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAddOnAdminRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAddOnAdminRequestValidationError{}

// Validate checks the field values on PutNodegroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutNodegroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutNodegroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutNodegroupRequestMultiError, or nil if none found.
func (m *PutNodegroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutNodegroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	// no validation rules for Name

	// no validation rules for Count

	// no validation rules for Releaseversion

	// no validation rules for Status

	if len(errors) > 0 {
		return PutNodegroupRequestMultiError(errors)
	}

	return nil
}

// PutNodegroupRequestMultiError is an error wrapping multiple validation
// errors returned by PutNodegroupRequest.ValidateAll() if the designated
// constraints aren't met.
type PutNodegroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutNodegroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutNodegroupRequestMultiError) AllErrors() []error { return m }

// PutNodegroupRequestValidationError is the validation error returned by
// PutNodegroupRequest.Validate if the designated constraints aren't met.
type PutNodegroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutNodegroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutNodegroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutNodegroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutNodegroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutNodegroupRequestValidationError) ErrorName() string {
	return "PutNodegroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutNodegroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutNodegroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutNodegroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutNodegroupRequestValidationError{}

// Validate checks the field values on UpgradeControlPlaneRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeControlPlaneRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeControlPlaneRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeControlPlaneRequestMultiError, or nil if none found.
func (m *UpgradeControlPlaneRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeControlPlaneRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	if m.K8Sversionname != nil {
		// no validation rules for K8Sversionname
	}

	if len(errors) > 0 {
		return UpgradeControlPlaneRequestMultiError(errors)
	}

	return nil
}

// UpgradeControlPlaneRequestMultiError is an error wrapping multiple
// validation errors returned by UpgradeControlPlaneRequest.ValidateAll() if
// the designated constraints aren't met.
type UpgradeControlPlaneRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeControlPlaneRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeControlPlaneRequestMultiError) AllErrors() []error { return m }

// UpgradeControlPlaneRequestValidationError is the validation error returned
// by UpgradeControlPlaneRequest.Validate if the designated constraints aren't met.
type UpgradeControlPlaneRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeControlPlaneRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeControlPlaneRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeControlPlaneRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeControlPlaneRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeControlPlaneRequestValidationError) ErrorName() string {
	return "UpgradeControlPlaneRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeControlPlaneRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeControlPlaneRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeControlPlaneRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeControlPlaneRequestValidationError{}

// Validate checks the field values on GetNodegroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodegroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodegroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodegroupResponseMultiError, or nil if none found.
func (m *GetNodegroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodegroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodegroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNodegroupResponseValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNodegroupResponseValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNodegroupResponseValidationError{
					field:  fmt.Sprintf("Nodegroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNodegroupResponseMultiError(errors)
	}

	return nil
}

// GetNodegroupResponseMultiError is an error wrapping multiple validation
// errors returned by GetNodegroupResponse.ValidateAll() if the designated
// constraints aren't met.
type GetNodegroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodegroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodegroupResponseMultiError) AllErrors() []error { return m }

// GetNodegroupResponseValidationError is the validation error returned by
// GetNodegroupResponse.Validate if the designated constraints aren't met.
type GetNodegroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodegroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodegroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodegroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodegroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodegroupResponseValidationError) ErrorName() string {
	return "GetNodegroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodegroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodegroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodegroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodegroupResponseValidationError{}

// Validate checks the field values on GetEventResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetEventResponseMultiError, or nil if none found.
func (m *GetEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Details

	// no validation rules for Createdby

	// no validation rules for Createddate

	if len(errors) > 0 {
		return GetEventResponseMultiError(errors)
	}

	return nil
}

// GetEventResponseMultiError is an error wrapping multiple validation errors
// returned by GetEventResponse.ValidateAll() if the designated constraints
// aren't met.
type GetEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEventResponseMultiError) AllErrors() []error { return m }

// GetEventResponseValidationError is the validation error returned by
// GetEventResponse.Validate if the designated constraints aren't met.
type GetEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEventResponseValidationError) ErrorName() string { return "GetEventResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEventResponseValidationError{}

// Validate checks the field values on PostSnapshotRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostSnapshotRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostSnapshotRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostSnapshotRequestMultiError, or nil if none found.
func (m *PostSnapshotRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostSnapshotRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Name

	if len(errors) > 0 {
		return PostSnapshotRequestMultiError(errors)
	}

	return nil
}

// PostSnapshotRequestMultiError is an error wrapping multiple validation
// errors returned by PostSnapshotRequest.ValidateAll() if the designated
// constraints aren't met.
type PostSnapshotRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostSnapshotRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostSnapshotRequestMultiError) AllErrors() []error { return m }

// PostSnapshotRequestValidationError is the validation error returned by
// PostSnapshotRequest.Validate if the designated constraints aren't met.
type PostSnapshotRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostSnapshotRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostSnapshotRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostSnapshotRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostSnapshotRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostSnapshotRequestValidationError) ErrorName() string {
	return "PostSnapshotRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PostSnapshotRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostSnapshotRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostSnapshotRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostSnapshotRequestValidationError{}

// Validate checks the field values on PostSnapshotResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostSnapshotResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostSnapshotResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostSnapshotResponseMultiError, or nil if none found.
func (m *PostSnapshotResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PostSnapshotResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Name

	// no validation rules for Status

	if len(errors) > 0 {
		return PostSnapshotResponseMultiError(errors)
	}

	return nil
}

// PostSnapshotResponseMultiError is an error wrapping multiple validation
// errors returned by PostSnapshotResponse.ValidateAll() if the designated
// constraints aren't met.
type PostSnapshotResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostSnapshotResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostSnapshotResponseMultiError) AllErrors() []error { return m }

// PostSnapshotResponseValidationError is the validation error returned by
// PostSnapshotResponse.Validate if the designated constraints aren't met.
type PostSnapshotResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostSnapshotResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostSnapshotResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostSnapshotResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostSnapshotResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostSnapshotResponseValidationError) ErrorName() string {
	return "PostSnapshotResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PostSnapshotResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostSnapshotResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostSnapshotResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostSnapshotResponseValidationError{}

// Validate checks the field values on ClusterSSHKeys with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterSSHKeys) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterSSHKeys with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterSSHKeysMultiError,
// or nil if none found.
func (m *ClusterSSHKeys) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterSSHKeys) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusterid

	// no validation rules for Sshprivatekey

	// no validation rules for Sshpublickey

	if len(errors) > 0 {
		return ClusterSSHKeysMultiError(errors)
	}

	return nil
}

// ClusterSSHKeysMultiError is an error wrapping multiple validation errors
// returned by ClusterSSHKeys.ValidateAll() if the designated constraints
// aren't met.
type ClusterSSHKeysMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterSSHKeysMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterSSHKeysMultiError) AllErrors() []error { return m }

// ClusterSSHKeysValidationError is the validation error returned by
// ClusterSSHKeys.Validate if the designated constraints aren't met.
type ClusterSSHKeysValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterSSHKeysValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterSSHKeysValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterSSHKeysValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterSSHKeysValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterSSHKeysValidationError) ErrorName() string { return "ClusterSSHKeysValidationError" }

// Error satisfies the builtin error interface
func (e ClusterSSHKeysValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterSSHKeys.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterSSHKeysValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterSSHKeysValidationError{}

// Validate checks the field values on CloudAccountApproveListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CloudAccountApproveListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccountApproveListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CloudAccountApproveListResponseMultiError, or nil if none found.
func (m *CloudAccountApproveListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccountApproveListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetApproveListResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloudAccountApproveListResponseValidationError{
						field:  fmt.Sprintf("ApproveListResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloudAccountApproveListResponseValidationError{
						field:  fmt.Sprintf("ApproveListResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloudAccountApproveListResponseValidationError{
					field:  fmt.Sprintf("ApproveListResponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetExistingresourcelimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CloudAccountApproveListResponseValidationError{
					field:  "Existingresourcelimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CloudAccountApproveListResponseValidationError{
					field:  "Existingresourcelimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExistingresourcelimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CloudAccountApproveListResponseValidationError{
				field:  "Existingresourcelimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CloudAccountApproveListResponseMultiError(errors)
	}

	return nil
}

// CloudAccountApproveListResponseMultiError is an error wrapping multiple
// validation errors returned by CloudAccountApproveListResponse.ValidateAll()
// if the designated constraints aren't met.
type CloudAccountApproveListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountApproveListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountApproveListResponseMultiError) AllErrors() []error { return m }

// CloudAccountApproveListResponseValidationError is the validation error
// returned by CloudAccountApproveListResponse.Validate if the designated
// constraints aren't met.
type CloudAccountApproveListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountApproveListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountApproveListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountApproveListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountApproveListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountApproveListResponseValidationError) ErrorName() string {
	return "CloudAccountApproveListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CloudAccountApproveListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccountApproveListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountApproveListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountApproveListResponseValidationError{}

// Validate checks the field values on CloudAccountApproveList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CloudAccountApproveList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccountApproveList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloudAccountApproveListMultiError, or nil if none found.
func (m *CloudAccountApproveList) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccountApproveList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	// no validation rules for Providername

	// no validation rules for Status

	// no validation rules for EnableStorage

	// no validation rules for MaxclustersOverride

	// no validation rules for MaxclusterngOverride

	// no validation rules for MaxclusterilbOverride

	// no validation rules for MaxnodegroupvmOverride

	// no validation rules for MaxclustervmOverride

	if len(errors) > 0 {
		return CloudAccountApproveListMultiError(errors)
	}

	return nil
}

// CloudAccountApproveListMultiError is an error wrapping multiple validation
// errors returned by CloudAccountApproveList.ValidateAll() if the designated
// constraints aren't met.
type CloudAccountApproveListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountApproveListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountApproveListMultiError) AllErrors() []error { return m }

// CloudAccountApproveListValidationError is the validation error returned by
// CloudAccountApproveList.Validate if the designated constraints aren't met.
type CloudAccountApproveListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountApproveListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountApproveListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountApproveListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountApproveListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountApproveListValidationError) ErrorName() string {
	return "CloudAccountApproveListValidationError"
}

// Error satisfies the builtin error interface
func (e CloudAccountApproveListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccountApproveList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountApproveListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountApproveListValidationError{}

// Validate checks the field values on CloudAccountApproveListRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CloudAccountApproveListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloudAccountApproveListRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CloudAccountApproveListRequestMultiError, or nil if none found.
func (m *CloudAccountApproveListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CloudAccountApproveListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for Status

	// no validation rules for EnableStorage

	if val := m.GetMaxclustersOverride(); val < 0 || val > 20 {
		err := CloudAccountApproveListRequestValidationError{
			field:  "MaxclustersOverride",
			reason: "value must be inside range [0, 20]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxclusterngOverride(); val < 0 || val > 50 {
		err := CloudAccountApproveListRequestValidationError{
			field:  "MaxclusterngOverride",
			reason: "value must be inside range [0, 50]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxclusterilbOverride(); val < 0 || val > 20 {
		err := CloudAccountApproveListRequestValidationError{
			field:  "MaxclusterilbOverride",
			reason: "value must be inside range [0, 20]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxnodegroupvmOverride(); val < 0 || val > 512 {
		err := CloudAccountApproveListRequestValidationError{
			field:  "MaxnodegroupvmOverride",
			reason: "value must be inside range [0, 512]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetMaxclustervmOverride(); val < 0 || val > 512 {
		err := CloudAccountApproveListRequestValidationError{
			field:  "MaxclustervmOverride",
			reason: "value must be inside range [0, 512]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return CloudAccountApproveListRequestMultiError(errors)
	}

	return nil
}

// CloudAccountApproveListRequestMultiError is an error wrapping multiple
// validation errors returned by CloudAccountApproveListRequest.ValidateAll()
// if the designated constraints aren't met.
type CloudAccountApproveListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloudAccountApproveListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloudAccountApproveListRequestMultiError) AllErrors() []error { return m }

// CloudAccountApproveListRequestValidationError is the validation error
// returned by CloudAccountApproveListRequest.Validate if the designated
// constraints aren't met.
type CloudAccountApproveListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloudAccountApproveListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloudAccountApproveListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloudAccountApproveListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloudAccountApproveListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloudAccountApproveListRequestValidationError) ErrorName() string {
	return "CloudAccountApproveListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CloudAccountApproveListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloudAccountApproveListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloudAccountApproveListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloudAccountApproveListRequestValidationError{}

// Validate checks the field values on UserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRequestMultiError, or
// nil if none found.
func (m *UserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return UserRequestMultiError(errors)
	}

	return nil
}

// UserRequestMultiError is an error wrapping multiple validation errors
// returned by UserRequest.ValidateAll() if the designated constraints aren't met.
type UserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRequestMultiError) AllErrors() []error { return m }

// UserRequestValidationError is the validation error returned by
// UserRequest.Validate if the designated constraints aren't met.
type UserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRequestValidationError) ErrorName() string { return "UserRequestValidationError" }

// Error satisfies the builtin error interface
func (e UserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRequestValidationError{}

// Validate checks the field values on UserResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserResponseMultiError, or
// nil if none found.
func (m *UserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsAuthenticatedUser

	if len(errors) > 0 {
		return UserResponseMultiError(errors)
	}

	return nil
}

// UserResponseMultiError is an error wrapping multiple validation errors
// returned by UserResponse.ValidateAll() if the designated constraints aren't met.
type UserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserResponseMultiError) AllErrors() []error { return m }

// UserResponseValidationError is the validation error returned by
// UserResponse.Validate if the designated constraints aren't met.
type UserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserResponseValidationError) ErrorName() string { return "UserResponseValidationError" }

// Error satisfies the builtin error interface
func (e UserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserResponseValidationError{}

// Validate checks the field values on CreateInstanceTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInstanceTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInstanceTypeRequestMultiError, or nil if none found.
func (m *CreateInstanceTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInstanceTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Instancetypename

	// no validation rules for Memory

	// no validation rules for Cpu

	// no validation rules for Nodeprovidername

	// no validation rules for Storage

	// no validation rules for Status

	// no validation rules for Displayname

	// no validation rules for Imioverride

	// no validation rules for Description

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for AllowManualInsert

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return CreateInstanceTypeRequestMultiError(errors)
	}

	return nil
}

// CreateInstanceTypeRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInstanceTypeRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateInstanceTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInstanceTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInstanceTypeRequestMultiError) AllErrors() []error { return m }

// CreateInstanceTypeRequestValidationError is the validation error returned by
// CreateInstanceTypeRequest.Validate if the designated constraints aren't met.
type CreateInstanceTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInstanceTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInstanceTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInstanceTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInstanceTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInstanceTypeRequestValidationError) ErrorName() string {
	return "CreateInstanceTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInstanceTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInstanceTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInstanceTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInstanceTypeRequestValidationError{}

// Validate checks the field values on GetInstanceTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceTypeRequestMultiError, or nil if none found.
func (m *GetInstanceTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return GetInstanceTypeRequestMultiError(errors)
	}

	return nil
}

// GetInstanceTypeRequestMultiError is an error wrapping multiple validation
// errors returned by GetInstanceTypeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetInstanceTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceTypeRequestMultiError) AllErrors() []error { return m }

// GetInstanceTypeRequestValidationError is the validation error returned by
// GetInstanceTypeRequest.Validate if the designated constraints aren't met.
type GetInstanceTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceTypeRequestValidationError) ErrorName() string {
	return "GetInstanceTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceTypeRequestValidationError{}

// Validate checks the field values on DeleteInstanceTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteInstanceTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteInstanceTypeRequestMultiError, or nil if none found.
func (m *DeleteInstanceTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteInstanceTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return DeleteInstanceTypeRequestMultiError(errors)
	}

	return nil
}

// DeleteInstanceTypeRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteInstanceTypeRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteInstanceTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteInstanceTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteInstanceTypeRequestMultiError) AllErrors() []error { return m }

// DeleteInstanceTypeRequestValidationError is the validation error returned by
// DeleteInstanceTypeRequest.Validate if the designated constraints aren't met.
type DeleteInstanceTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInstanceTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInstanceTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInstanceTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInstanceTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInstanceTypeRequestValidationError) ErrorName() string {
	return "DeleteInstanceTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInstanceTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInstanceTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInstanceTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInstanceTypeRequestValidationError{}

// Validate checks the field values on UpdateInstanceTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateInstanceTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateInstanceTypeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateInstanceTypeRequestMultiError, or nil if none found.
func (m *UpdateInstanceTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInstanceTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Memory

	// no validation rules for Cpu

	// no validation rules for Nodeprovidername

	// no validation rules for Storage

	// no validation rules for Status

	// no validation rules for Displayname

	// no validation rules for Imioverride

	// no validation rules for Description

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for Iksadminkey

	if len(errors) > 0 {
		return UpdateInstanceTypeRequestMultiError(errors)
	}

	return nil
}

// UpdateInstanceTypeRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateInstanceTypeRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateInstanceTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInstanceTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInstanceTypeRequestMultiError) AllErrors() []error { return m }

// UpdateInstanceTypeRequestValidationError is the validation error returned by
// UpdateInstanceTypeRequest.Validate if the designated constraints aren't met.
type UpdateInstanceTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInstanceTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInstanceTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInstanceTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInstanceTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInstanceTypeRequestValidationError) ErrorName() string {
	return "UpdateInstanceTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInstanceTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInstanceTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInstanceTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInstanceTypeRequestValidationError{}

// Validate checks the field values on GetInstanceTypesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceTypesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceTypesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceTypesResponseMultiError, or nil if none found.
func (m *GetInstanceTypesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceTypesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstanceTypeResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInstanceTypesResponseValidationError{
						field:  fmt.Sprintf("InstanceTypeResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInstanceTypesResponseValidationError{
						field:  fmt.Sprintf("InstanceTypeResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInstanceTypesResponseValidationError{
					field:  fmt.Sprintf("InstanceTypeResponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetInstanceTypesResponseMultiError(errors)
	}

	return nil
}

// GetInstanceTypesResponseMultiError is an error wrapping multiple validation
// errors returned by GetInstanceTypesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInstanceTypesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceTypesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceTypesResponseMultiError) AllErrors() []error { return m }

// GetInstanceTypesResponseValidationError is the validation error returned by
// GetInstanceTypesResponse.Validate if the designated constraints aren't met.
type GetInstanceTypesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceTypesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceTypesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceTypesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceTypesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceTypesResponseValidationError) ErrorName() string {
	return "GetInstanceTypesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceTypesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceTypesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceTypesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceTypesResponseValidationError{}

// Validate checks the field values on GetInstanceTypeInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceTypeInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceTypeInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceTypeInfoResponseMultiError, or nil if none found.
func (m *GetInstanceTypeInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceTypeInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetComputeResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInstanceTypeInfoResponseValidationError{
						field:  fmt.Sprintf("ComputeResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInstanceTypeInfoResponseValidationError{
						field:  fmt.Sprintf("ComputeResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInstanceTypeInfoResponseValidationError{
					field:  fmt.Sprintf("ComputeResponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetInstanceTypeInfoResponseMultiError(errors)
	}

	return nil
}

// GetInstanceTypeInfoResponseMultiError is an error wrapping multiple
// validation errors returned by GetInstanceTypeInfoResponse.ValidateAll() if
// the designated constraints aren't met.
type GetInstanceTypeInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceTypeInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceTypeInfoResponseMultiError) AllErrors() []error { return m }

// GetInstanceTypeInfoResponseValidationError is the validation error returned
// by GetInstanceTypeInfoResponse.Validate if the designated constraints
// aren't met.
type GetInstanceTypeInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceTypeInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceTypeInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceTypeInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceTypeInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceTypeInfoResponseValidationError) ErrorName() string {
	return "GetInstanceTypeInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceTypeInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceTypeInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceTypeInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceTypeInfoResponseValidationError{}

// Validate checks the field values on GetInstanceTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceTypeResponseMultiError, or nil if none found.
func (m *GetInstanceTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIksInstanceType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInstanceTypeResponseValidationError{
					field:  "IksInstanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInstanceTypeResponseValidationError{
					field:  "IksInstanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIksInstanceType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInstanceTypeResponseValidationError{
				field:  "IksInstanceType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetComputeInstanceType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInstanceTypeResponseValidationError{
					field:  "ComputeInstanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInstanceTypeResponseValidationError{
					field:  "ComputeInstanceType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComputeInstanceType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInstanceTypeResponseValidationError{
				field:  "ComputeInstanceType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInstanceTypeResponseMultiError(errors)
	}

	return nil
}

// GetInstanceTypeResponseMultiError is an error wrapping multiple validation
// errors returned by GetInstanceTypeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInstanceTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceTypeResponseMultiError) AllErrors() []error { return m }

// GetInstanceTypeResponseValidationError is the validation error returned by
// GetInstanceTypeResponse.Validate if the designated constraints aren't met.
type GetInstanceTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceTypeResponseValidationError) ErrorName() string {
	return "GetInstanceTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceTypeResponseValidationError{}

// Validate checks the field values on InstanceTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTypeResponseMultiError, or nil if none found.
func (m *InstanceTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Instancetypename

	// no validation rules for Memory

	// no validation rules for Cpu

	// no validation rules for Nodeprovidername

	// no validation rules for Storage

	// no validation rules for Status

	// no validation rules for Displayname

	// no validation rules for Imioverride

	// no validation rules for Description

	// no validation rules for Category

	// no validation rules for Family

	// no validation rules for IksDB

	for idx, item := range m.GetImiResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTypeResponseValidationError{
						field:  fmt.Sprintf("ImiResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTypeResponseValidationError{
						field:  fmt.Sprintf("ImiResponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTypeResponseValidationError{
					field:  fmt.Sprintf("ImiResponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstacetypeimik8Scompatibilityresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTypeResponseValidationError{
						field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTypeResponseValidationError{
						field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTypeResponseValidationError{
					field:  fmt.Sprintf("Instacetypeimik8Scompatibilityresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Iscompatabilityactiveinstance

	if len(errors) > 0 {
		return InstanceTypeResponseMultiError(errors)
	}

	return nil
}

// InstanceTypeResponseMultiError is an error wrapping multiple validation
// errors returned by InstanceTypeResponse.ValidateAll() if the designated
// constraints aren't met.
type InstanceTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTypeResponseMultiError) AllErrors() []error { return m }

// InstanceTypeResponseValidationError is the validation error returned by
// InstanceTypeResponse.Validate if the designated constraints aren't met.
type InstanceTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTypeResponseValidationError) ErrorName() string {
	return "InstanceTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTypeResponseValidationError{}

// Validate checks the field values on AdminFirewallRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdminFirewallRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdminFirewallRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdminFirewallRuleResponseMultiError, or nil if none found.
func (m *AdminFirewallRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AdminFirewallRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	// no validation rules for Destinationip

	// no validation rules for Port

	// no validation rules for Vipid

	// no validation rules for Vipname

	// no validation rules for Viptype

	// no validation rules for Internalport

	if len(errors) > 0 {
		return AdminFirewallRuleResponseMultiError(errors)
	}

	return nil
}

// AdminFirewallRuleResponseMultiError is an error wrapping multiple validation
// errors returned by AdminFirewallRuleResponse.ValidateAll() if the
// designated constraints aren't met.
type AdminFirewallRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdminFirewallRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdminFirewallRuleResponseMultiError) AllErrors() []error { return m }

// AdminFirewallRuleResponseValidationError is the validation error returned by
// AdminFirewallRuleResponse.Validate if the designated constraints aren't met.
type AdminFirewallRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdminFirewallRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdminFirewallRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdminFirewallRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdminFirewallRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdminFirewallRuleResponseValidationError) ErrorName() string {
	return "AdminFirewallRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AdminFirewallRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdminFirewallRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdminFirewallRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdminFirewallRuleResponseValidationError{}

// Validate checks the field values on GetAdminFirewallRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAdminFirewallRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAdminFirewallRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAdminFirewallRuleResponseMultiError, or nil if none found.
func (m *GetAdminFirewallRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAdminFirewallRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGetfirewallresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAdminFirewallRuleResponseValidationError{
						field:  fmt.Sprintf("Getfirewallresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAdminFirewallRuleResponseValidationError{
						field:  fmt.Sprintf("Getfirewallresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAdminFirewallRuleResponseValidationError{
					field:  fmt.Sprintf("Getfirewallresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAdminFirewallRuleResponseMultiError(errors)
	}

	return nil
}

// GetAdminFirewallRuleResponseMultiError is an error wrapping multiple
// validation errors returned by GetAdminFirewallRuleResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAdminFirewallRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAdminFirewallRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAdminFirewallRuleResponseMultiError) AllErrors() []error { return m }

// GetAdminFirewallRuleResponseValidationError is the validation error returned
// by GetAdminFirewallRuleResponse.Validate if the designated constraints
// aren't met.
type GetAdminFirewallRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAdminFirewallRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAdminFirewallRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAdminFirewallRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAdminFirewallRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAdminFirewallRuleResponseValidationError) ErrorName() string {
	return "GetAdminFirewallRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAdminFirewallRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAdminFirewallRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAdminFirewallRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAdminFirewallRuleResponseValidationError{}
