// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: security-insights.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ComponentList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComponentList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentListMultiError, or
// nil if none found.
func (m *ComponentList) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetComponents()))
		i := 0
		for key := range m.GetComponents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetComponents()[key]
			_ = val

			// no validation rules for Components[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ComponentListValidationError{
							field:  fmt.Sprintf("Components[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ComponentListValidationError{
							field:  fmt.Sprintf("Components[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ComponentListValidationError{
						field:  fmt.Sprintf("Components[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ComponentListMultiError(errors)
	}

	return nil
}

// ComponentListMultiError is an error wrapping multiple validation errors
// returned by ComponentList.ValidateAll() if the designated constraints
// aren't met.
type ComponentListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentListMultiError) AllErrors() []error { return m }

// ComponentListValidationError is the validation error returned by
// ComponentList.Validate if the designated constraints aren't met.
type ComponentListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentListValidationError) ErrorName() string { return "ComponentListValidationError" }

// Error satisfies the builtin error interface
func (e ComponentListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentListValidationError{}

// Validate checks the field values on Releases with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Releases) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Releases with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleasesMultiError, or nil
// if none found.
func (m *Releases) ValidateAll() error {
	return m.validate(true)
}

func (m *Releases) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReleasesMultiError(errors)
	}

	return nil
}

// ReleasesMultiError is an error wrapping multiple validation errors returned
// by Releases.ValidateAll() if the designated constraints aren't met.
type ReleasesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleasesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleasesMultiError) AllErrors() []error { return m }

// ReleasesValidationError is the validation error returned by
// Releases.Validate if the designated constraints aren't met.
type ReleasesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleasesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleasesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleasesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleasesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleasesValidationError) ErrorName() string { return "ReleasesValidationError" }

// Error satisfies the builtin error interface
func (e ReleasesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleases.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleasesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleasesValidationError{}

// Validate checks the field values on K8SReleaseMD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *K8SReleaseMD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SReleaseMD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in K8SReleaseMDMultiError, or
// nil if none found.
func (m *K8SReleaseMD) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SReleaseMD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	// no validation rules for Vendor

	// no validation rules for License

	// no validation rules for Purl

	if all {
		switch v := interface{}(m.GetReleaseTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SReleaseMDValidationError{
					field:  "ReleaseTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SReleaseMDValidationError{
					field:  "ReleaseTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SReleaseMDValidationError{
				field:  "ReleaseTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEosTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SReleaseMDValidationError{
					field:  "EosTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SReleaseMDValidationError{
					field:  "EosTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEosTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SReleaseMDValidationError{
				field:  "EosTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEolTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, K8SReleaseMDValidationError{
					field:  "EolTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, K8SReleaseMDValidationError{
					field:  "EolTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEolTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return K8SReleaseMDValidationError{
				field:  "EolTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Properties

	for idx, item := range m.GetComponents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, K8SReleaseMDValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, K8SReleaseMDValidationError{
						field:  fmt.Sprintf("Components[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return K8SReleaseMDValidationError{
					field:  fmt.Sprintf("Components[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return K8SReleaseMDMultiError(errors)
	}

	return nil
}

// K8SReleaseMDMultiError is an error wrapping multiple validation errors
// returned by K8SReleaseMD.ValidateAll() if the designated constraints aren't met.
type K8SReleaseMDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SReleaseMDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SReleaseMDMultiError) AllErrors() []error { return m }

// K8SReleaseMDValidationError is the validation error returned by
// K8SReleaseMD.Validate if the designated constraints aren't met.
type K8SReleaseMDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SReleaseMDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SReleaseMDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SReleaseMDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SReleaseMDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SReleaseMDValidationError) ErrorName() string { return "K8SReleaseMDValidationError" }

// Error satisfies the builtin error interface
func (e K8SReleaseMDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SReleaseMD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SReleaseMDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SReleaseMDValidationError{}

// Validate checks the field values on K8SReleaseMDList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *K8SReleaseMDList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SReleaseMDList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// K8SReleaseMDListMultiError, or nil if none found.
func (m *K8SReleaseMDList) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SReleaseMDList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReleases() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, K8SReleaseMDListValidationError{
						field:  fmt.Sprintf("Releases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, K8SReleaseMDListValidationError{
						field:  fmt.Sprintf("Releases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return K8SReleaseMDListValidationError{
					field:  fmt.Sprintf("Releases[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return K8SReleaseMDListMultiError(errors)
	}

	return nil
}

// K8SReleaseMDListMultiError is an error wrapping multiple validation errors
// returned by K8SReleaseMDList.ValidateAll() if the designated constraints
// aren't met.
type K8SReleaseMDListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SReleaseMDListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SReleaseMDListMultiError) AllErrors() []error { return m }

// K8SReleaseMDListValidationError is the validation error returned by
// K8SReleaseMDList.Validate if the designated constraints aren't met.
type K8SReleaseMDListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SReleaseMDListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SReleaseMDListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SReleaseMDListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SReleaseMDListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SReleaseMDListValidationError) ErrorName() string { return "K8SReleaseMDListValidationError" }

// Error satisfies the builtin error interface
func (e K8SReleaseMDListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SReleaseMDList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SReleaseMDListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SReleaseMDListValidationError{}

// Validate checks the field values on ReleaseComponents with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReleaseComponents) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseComponents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseComponentsMultiError, or nil if none found.
func (m *ReleaseComponents) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseComponents) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	// no validation rules for Vendor

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Purl

	// no validation rules for Sha256

	// no validation rules for License

	if all {
		switch v := interface{}(m.GetReleaseTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseComponentsValidationError{
					field:  "ReleaseTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseComponentsValidationError{
					field:  "ReleaseTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleaseTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseComponentsValidationError{
				field:  "ReleaseTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if len(errors) > 0 {
		return ReleaseComponentsMultiError(errors)
	}

	return nil
}

// ReleaseComponentsMultiError is an error wrapping multiple validation errors
// returned by ReleaseComponents.ValidateAll() if the designated constraints
// aren't met.
type ReleaseComponentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseComponentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseComponentsMultiError) AllErrors() []error { return m }

// ReleaseComponentsValidationError is the validation error returned by
// ReleaseComponents.Validate if the designated constraints aren't met.
type ReleaseComponentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseComponentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseComponentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseComponentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseComponentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseComponentsValidationError) ErrorName() string {
	return "ReleaseComponentsValidationError"
}

// Error satisfies the builtin error interface
func (e ReleaseComponentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseComponents.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseComponentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseComponentsValidationError{}

// Validate checks the field values on GetReleaseRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetReleaseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReleaseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReleaseRequestMultiError, or nil if none found.
func (m *GetReleaseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReleaseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetReleaseRequest_ReleaseId_Pattern.MatchString(m.GetReleaseId()) {
		err := GetReleaseRequestValidationError{
			field:  "ReleaseId",
			reason: "value does not match regex pattern \"^v[0-9]+\\\\.[0-9]+\\\\.[0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ReleaseComponent_name[int32(m.GetComponent())]; !ok {
		err := GetReleaseRequestValidationError{
			field:  "Component",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetReleaseRequestMultiError(errors)
	}

	return nil
}

// GetReleaseRequestMultiError is an error wrapping multiple validation errors
// returned by GetReleaseRequest.ValidateAll() if the designated constraints
// aren't met.
type GetReleaseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReleaseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReleaseRequestMultiError) AllErrors() []error { return m }

// GetReleaseRequestValidationError is the validation error returned by
// GetReleaseRequest.Validate if the designated constraints aren't met.
type GetReleaseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReleaseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReleaseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReleaseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReleaseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReleaseRequestValidationError) ErrorName() string {
	return "GetReleaseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReleaseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReleaseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReleaseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReleaseRequestValidationError{}

var _GetReleaseRequest_ReleaseId_Pattern = regexp.MustCompile("^v[0-9]+\\.[0-9]+\\.[0-9]+$")

// Validate checks the field values on ReleaseFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseFilterMultiError, or
// nil if none found.
func (m *ReleaseFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Top

	if _, ok := ReleaseComponent_name[int32(m.GetComponent())]; !ok {
		err := ReleaseFilterValidationError{
			field:  "Component",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReleaseFilterMultiError(errors)
	}

	return nil
}

// ReleaseFilterMultiError is an error wrapping multiple validation errors
// returned by ReleaseFilter.ValidateAll() if the designated constraints
// aren't met.
type ReleaseFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseFilterMultiError) AllErrors() []error { return m }

// ReleaseFilterValidationError is the validation error returned by
// ReleaseFilter.Validate if the designated constraints aren't met.
type ReleaseFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseFilterValidationError) ErrorName() string { return "ReleaseFilterValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseFilterValidationError{}

// Validate checks the field values on ReleaseSBOM with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReleaseSBOM) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseSBOM with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReleaseSBOMMultiError, or
// nil if none found.
func (m *ReleaseSBOM) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseSBOM) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	if all {
		switch v := interface{}(m.GetSbom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReleaseSBOMValidationError{
					field:  "Sbom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReleaseSBOMValidationError{
					field:  "Sbom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSbom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReleaseSBOMValidationError{
				field:  "Sbom",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReleaseSBOMMultiError(errors)
	}

	return nil
}

// ReleaseSBOMMultiError is an error wrapping multiple validation errors
// returned by ReleaseSBOM.ValidateAll() if the designated constraints aren't met.
type ReleaseSBOMMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseSBOMMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseSBOMMultiError) AllErrors() []error { return m }

// ReleaseSBOMValidationError is the validation error returned by
// ReleaseSBOM.Validate if the designated constraints aren't met.
type ReleaseSBOMValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseSBOMValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseSBOMValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseSBOMValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseSBOMValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseSBOMValidationError) ErrorName() string { return "ReleaseSBOMValidationError" }

// Error satisfies the builtin error interface
func (e ReleaseSBOMValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseSBOM.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseSBOMValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseSBOMValidationError{}

// Validate checks the field values on SBOM with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *SBOM) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SBOM with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SBOMMultiError, or nil if none found.
func (m *SBOM) ValidateAll() error {
	return m.validate(true)
}

func (m *SBOM) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sbom

	// no validation rules for Format

	if all {
		switch v := interface{}(m.GetCreateTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SBOMValidationError{
					field:  "CreateTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SBOMValidationError{
					field:  "CreateTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SBOMValidationError{
				field:  "CreateTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SBOMMultiError(errors)
	}

	return nil
}

// SBOMMultiError is an error wrapping multiple validation errors returned by
// SBOM.ValidateAll() if the designated constraints aren't met.
type SBOMMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SBOMMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SBOMMultiError) AllErrors() []error { return m }

// SBOMValidationError is the validation error returned by SBOM.Validate if the
// designated constraints aren't met.
type SBOMValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SBOMValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SBOMValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SBOMValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SBOMValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SBOMValidationError) ErrorName() string { return "SBOMValidationError" }

// Error satisfies the builtin error interface
func (e SBOMValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSBOM.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SBOMValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SBOMValidationError{}

// Validate checks the field values on VulnerabilityReport with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilityReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilityReport with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VulnerabilityReportMultiError, or nil if none found.
func (m *VulnerabilityReport) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilityReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	// no validation rules for ComponentName

	// no validation rules for ComponentVersion

	// no validation rules for ComponentSHA256

	if all {
		switch v := interface{}(m.GetScanTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityReportValidationError{
					field:  "ScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityReportValidationError{
					field:  "ScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScanTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityReportValidationError{
				field:  "ScanTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScanTool

	for idx, item := range m.GetVulnerabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VulnerabilityReportValidationError{
						field:  fmt.Sprintf("Vulnerabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VulnerabilityReportValidationError{
						field:  fmt.Sprintf("Vulnerabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VulnerabilityReportValidationError{
					field:  fmt.Sprintf("Vulnerabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VulnerabilityReportMultiError(errors)
	}

	return nil
}

// VulnerabilityReportMultiError is an error wrapping multiple validation
// errors returned by VulnerabilityReport.ValidateAll() if the designated
// constraints aren't met.
type VulnerabilityReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilityReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilityReportMultiError) AllErrors() []error { return m }

// VulnerabilityReportValidationError is the validation error returned by
// VulnerabilityReport.Validate if the designated constraints aren't met.
type VulnerabilityReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilityReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilityReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilityReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilityReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilityReportValidationError) ErrorName() string {
	return "VulnerabilityReportValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilityReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilityReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilityReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilityReportValidationError{}

// Validate checks the field values on VulnerabilitySummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilitySummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilitySummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VulnerabilitySummaryMultiError, or nil if none found.
func (m *VulnerabilitySummary) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilitySummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	// no validation rules for ComponentName

	// no validation rules for ComponentVersion

	// no validation rules for ComponentSHA256

	if all {
		switch v := interface{}(m.GetScanTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilitySummaryValidationError{
					field:  "ScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilitySummaryValidationError{
					field:  "ScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScanTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilitySummaryValidationError{
				field:  "ScanTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScanTool

	// no validation rules for VulnerabilityCount

	if len(errors) > 0 {
		return VulnerabilitySummaryMultiError(errors)
	}

	return nil
}

// VulnerabilitySummaryMultiError is an error wrapping multiple validation
// errors returned by VulnerabilitySummary.ValidateAll() if the designated
// constraints aren't met.
type VulnerabilitySummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilitySummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilitySummaryMultiError) AllErrors() []error { return m }

// VulnerabilitySummaryValidationError is the validation error returned by
// VulnerabilitySummary.Validate if the designated constraints aren't met.
type VulnerabilitySummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilitySummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilitySummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilitySummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilitySummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilitySummaryValidationError) ErrorName() string {
	return "VulnerabilitySummaryValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilitySummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilitySummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilitySummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilitySummaryValidationError{}

// Validate checks the field values on VulnerabilitiesResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilitiesResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilitiesResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VulnerabilitiesResultMultiError, or nil if none found.
func (m *VulnerabilitiesResult) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilitiesResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReport() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VulnerabilitiesResultValidationError{
						field:  fmt.Sprintf("Report[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VulnerabilitiesResultValidationError{
						field:  fmt.Sprintf("Report[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VulnerabilitiesResultValidationError{
					field:  fmt.Sprintf("Report[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VulnerabilitiesResultMultiError(errors)
	}

	return nil
}

// VulnerabilitiesResultMultiError is an error wrapping multiple validation
// errors returned by VulnerabilitiesResult.ValidateAll() if the designated
// constraints aren't met.
type VulnerabilitiesResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilitiesResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilitiesResultMultiError) AllErrors() []error { return m }

// VulnerabilitiesResultValidationError is the validation error returned by
// VulnerabilitiesResult.Validate if the designated constraints aren't met.
type VulnerabilitiesResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilitiesResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilitiesResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilitiesResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilitiesResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilitiesResultValidationError) ErrorName() string {
	return "VulnerabilitiesResultValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilitiesResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilitiesResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilitiesResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilitiesResultValidationError{}

// Validate checks the field values on CISReport with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CISReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CISReport with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CISReportMultiError, or nil
// if none found.
func (m *CISReport) ValidateAll() error {
	return m.validate(true)
}

func (m *CISReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	if all {
		switch v := interface{}(m.GetScanTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CISReportValidationError{
					field:  "ScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CISReportValidationError{
					field:  "ScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScanTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CISReportValidationError{
				field:  "ScanTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScanTool

	if all {
		switch v := interface{}(m.GetVulnerabilities()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CISReportValidationError{
					field:  "Vulnerabilities",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CISReportValidationError{
					field:  "Vulnerabilities",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVulnerabilities()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CISReportValidationError{
				field:  "Vulnerabilities",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CISReportMultiError(errors)
	}

	return nil
}

// CISReportMultiError is an error wrapping multiple validation errors returned
// by CISReport.ValidateAll() if the designated constraints aren't met.
type CISReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CISReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CISReportMultiError) AllErrors() []error { return m }

// CISReportValidationError is the validation error returned by
// CISReport.Validate if the designated constraints aren't met.
type CISReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CISReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CISReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CISReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CISReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CISReportValidationError) ErrorName() string { return "CISReportValidationError" }

// Error satisfies the builtin error interface
func (e CISReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCISReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CISReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CISReportValidationError{}

// Validate checks the field values on Vulnerability with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Vulnerability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Vulnerability with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VulnerabilityMultiError, or
// nil if none found.
func (m *Vulnerability) ValidateAll() error {
	return m.validate(true)
}

func (m *Vulnerability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for AffectedPackage

	// no validation rules for AffectedVersions

	// no validation rules for FixedVersion

	// no validation rules for Severity

	if all {
		switch v := interface{}(m.GetPublishedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityValidationError{
					field:  "PublishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityValidationError{
					field:  "PublishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPublishedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityValidationError{
				field:  "PublishedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VulnerabilityMultiError(errors)
	}

	return nil
}

// VulnerabilityMultiError is an error wrapping multiple validation errors
// returned by Vulnerability.ValidateAll() if the designated constraints
// aren't met.
type VulnerabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilityMultiError) AllErrors() []error { return m }

// VulnerabilityValidationError is the validation error returned by
// Vulnerability.Validate if the designated constraints aren't met.
type VulnerabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilityValidationError) ErrorName() string { return "VulnerabilityValidationError" }

// Error satisfies the builtin error interface
func (e VulnerabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilityValidationError{}

// Validate checks the field values on RecommendationPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecommendationPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecommendationPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecommendationPolicyMultiError, or nil if none found.
func (m *RecommendationPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *RecommendationPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecommendationPolicyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecommendationPolicyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecommendationPolicyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecommendationPolicyValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecommendationPolicyValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecommendationPolicyValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Active

	if len(errors) > 0 {
		return RecommendationPolicyMultiError(errors)
	}

	return nil
}

// RecommendationPolicyMultiError is an error wrapping multiple validation
// errors returned by RecommendationPolicy.ValidateAll() if the designated
// constraints aren't met.
type RecommendationPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecommendationPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecommendationPolicyMultiError) AllErrors() []error { return m }

// RecommendationPolicyValidationError is the validation error returned by
// RecommendationPolicy.Validate if the designated constraints aren't met.
type RecommendationPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecommendationPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecommendationPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecommendationPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecommendationPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecommendationPolicyValidationError) ErrorName() string {
	return "RecommendationPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e RecommendationPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecommendationPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecommendationPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecommendationPolicyValidationError{}

// Validate checks the field values on PolicyId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyIdMultiError, or nil
// if none found.
func (m *PolicyId) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	if len(errors) > 0 {
		return PolicyIdMultiError(errors)
	}

	return nil
}

// PolicyIdMultiError is an error wrapping multiple validation errors returned
// by PolicyId.ValidateAll() if the designated constraints aren't met.
type PolicyIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyIdMultiError) AllErrors() []error { return m }

// PolicyIdValidationError is the validation error returned by
// PolicyId.Validate if the designated constraints aren't met.
type PolicyIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyIdValidationError) ErrorName() string { return "PolicyIdValidationError" }

// Error satisfies the builtin error interface
func (e PolicyIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyIdValidationError{}

// Validate checks the field values on AllPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AllPoliciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AllPoliciesResponseMultiError, or nil if none found.
func (m *AllPoliciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AllPoliciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPolicies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AllPoliciesResponseValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AllPoliciesResponseValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AllPoliciesResponseValidationError{
					field:  fmt.Sprintf("Policies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AllPoliciesResponseMultiError(errors)
	}

	return nil
}

// AllPoliciesResponseMultiError is an error wrapping multiple validation
// errors returned by AllPoliciesResponse.ValidateAll() if the designated
// constraints aren't met.
type AllPoliciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllPoliciesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllPoliciesResponseMultiError) AllErrors() []error { return m }

// AllPoliciesResponseValidationError is the validation error returned by
// AllPoliciesResponse.Validate if the designated constraints aren't met.
type AllPoliciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllPoliciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllPoliciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllPoliciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllPoliciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllPoliciesResponseValidationError) ErrorName() string {
	return "AllPoliciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AllPoliciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllPoliciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllPoliciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllPoliciesResponseValidationError{}

// Validate checks the field values on PolicyMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyMetadataMultiError,
// or nil if none found.
func (m *PolicyMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	// no validation rules for Name

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyMetadataValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Active

	if len(errors) > 0 {
		return PolicyMetadataMultiError(errors)
	}

	return nil
}

// PolicyMetadataMultiError is an error wrapping multiple validation errors
// returned by PolicyMetadata.ValidateAll() if the designated constraints
// aren't met.
type PolicyMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyMetadataMultiError) AllErrors() []error { return m }

// PolicyMetadataValidationError is the validation error returned by
// PolicyMetadata.Validate if the designated constraints aren't met.
type PolicyMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyMetadataValidationError) ErrorName() string { return "PolicyMetadataValidationError" }

// Error satisfies the builtin error interface
func (e PolicyMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyMetadataValidationError{}

// Validate checks the field values on PolicyDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyDetailsMultiError, or
// nil if none found.
func (m *PolicyDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPolicyMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyDetailsValidationError{
					field:  "PolicyMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyDetailsValidationError{
					field:  "PolicyMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicyMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyDetailsValidationError{
				field:  "PolicyMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyDetailsValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyDetailsValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyDetailsValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PolicyDetailsMultiError(errors)
	}

	return nil
}

// PolicyDetailsMultiError is an error wrapping multiple validation errors
// returned by PolicyDetails.ValidateAll() if the designated constraints
// aren't met.
type PolicyDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyDetailsMultiError) AllErrors() []error { return m }

// PolicyDetailsValidationError is the validation error returned by
// PolicyDetails.Validate if the designated constraints aren't met.
type PolicyDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyDetailsValidationError) ErrorName() string { return "PolicyDetailsValidationError" }

// Error satisfies the builtin error interface
func (e PolicyDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyDetailsValidationError{}

// Validate checks the field values on PolicyFilters with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyFilters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyFilters with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyFiltersMultiError, or
// nil if none found.
func (m *PolicyFilters) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyFilters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Active

	if len(errors) > 0 {
		return PolicyFiltersMultiError(errors)
	}

	return nil
}

// PolicyFiltersMultiError is an error wrapping multiple validation errors
// returned by PolicyFilters.ValidateAll() if the designated constraints
// aren't met.
type PolicyFiltersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyFiltersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyFiltersMultiError) AllErrors() []error { return m }

// PolicyFiltersValidationError is the validation error returned by
// PolicyFilters.Validate if the designated constraints aren't met.
type PolicyFiltersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyFiltersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyFiltersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyFiltersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyFiltersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyFiltersValidationError) ErrorName() string { return "PolicyFiltersValidationError" }

// Error satisfies the builtin error interface
func (e PolicyFiltersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyFilters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyFiltersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyFiltersValidationError{}

// Validate checks the field values on RecommendationFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecommendationFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecommendationFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecommendationFilterMultiError, or nil if none found.
func (m *RecommendationFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *RecommendationFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	// no validation rules for CurrentVersion

	// no validation rules for Vendor

	// no validation rules for Topk

	if len(errors) > 0 {
		return RecommendationFilterMultiError(errors)
	}

	return nil
}

// RecommendationFilterMultiError is an error wrapping multiple validation
// errors returned by RecommendationFilter.ValidateAll() if the designated
// constraints aren't met.
type RecommendationFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecommendationFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecommendationFilterMultiError) AllErrors() []error { return m }

// RecommendationFilterValidationError is the validation error returned by
// RecommendationFilter.Validate if the designated constraints aren't met.
type RecommendationFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecommendationFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecommendationFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecommendationFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecommendationFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecommendationFilterValidationError) ErrorName() string {
	return "RecommendationFilterValidationError"
}

// Error satisfies the builtin error interface
func (e RecommendationFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecommendationFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecommendationFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecommendationFilterValidationError{}

// Validate checks the field values on UpdateRecommendations with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRecommendations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRecommendations with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRecommendationsMultiError, or nil if none found.
func (m *UpdateRecommendations) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRecommendations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	// no validation rules for CurrentVersion

	// no validation rules for Vendor

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateRecommendationsValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateRecommendationsValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateRecommendationsValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateRecommendationsMultiError(errors)
	}

	return nil
}

// UpdateRecommendationsMultiError is an error wrapping multiple validation
// errors returned by UpdateRecommendations.ValidateAll() if the designated
// constraints aren't met.
type UpdateRecommendationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRecommendationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRecommendationsMultiError) AllErrors() []error { return m }

// UpdateRecommendationsValidationError is the validation error returned by
// UpdateRecommendations.Validate if the designated constraints aren't met.
type UpdateRecommendationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRecommendationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRecommendationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRecommendationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRecommendationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRecommendationsValidationError) ErrorName() string {
	return "UpdateRecommendationsValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRecommendationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRecommendations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRecommendationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRecommendationsValidationError{}

// Validate checks the field values on RecommendedVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecommendedVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecommendedVersion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecommendedVersionMultiError, or nil if none found.
func (m *RecommendedVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *RecommendedVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for CreatedAt

	if all {
		switch v := interface{}(m.GetReason()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecommendedVersionValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecommendedVersionValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReason()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecommendedVersionValidationError{
				field:  "Reason",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RecommendedVersionMultiError(errors)
	}

	return nil
}

// RecommendedVersionMultiError is an error wrapping multiple validation errors
// returned by RecommendedVersion.ValidateAll() if the designated constraints
// aren't met.
type RecommendedVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecommendedVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecommendedVersionMultiError) AllErrors() []error { return m }

// RecommendedVersionValidationError is the validation error returned by
// RecommendedVersion.Validate if the designated constraints aren't met.
type RecommendedVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecommendedVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecommendedVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecommendedVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecommendedVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecommendedVersionValidationError) ErrorName() string {
	return "RecommendedVersionValidationError"
}

// Error satisfies the builtin error interface
func (e RecommendedVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecommendedVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecommendedVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecommendedVersionValidationError{}

// Validate checks the field values on GetCISRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetCISRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCISRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetCISRequestMultiError, or
// nil if none found.
func (m *GetCISRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCISRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	if len(errors) > 0 {
		return GetCISRequestMultiError(errors)
	}

	return nil
}

// GetCISRequestMultiError is an error wrapping multiple validation errors
// returned by GetCISRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCISRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCISRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCISRequestMultiError) AllErrors() []error { return m }

// GetCISRequestValidationError is the validation error returned by
// GetCISRequest.Validate if the designated constraints aren't met.
type GetCISRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCISRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCISRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCISRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCISRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCISRequestValidationError) ErrorName() string { return "GetCISRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetCISRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCISRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCISRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCISRequestValidationError{}

// Validate checks the field values on SecuritySummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SecuritySummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecuritySummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecuritySummaryMultiError, or nil if none found.
func (m *SecuritySummary) ValidateAll() error {
	return m.validate(true)
}

func (m *SecuritySummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseId

	for idx, item := range m.GetVulnerabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecuritySummaryValidationError{
						field:  fmt.Sprintf("Vulnerabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecuritySummaryValidationError{
						field:  fmt.Sprintf("Vulnerabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecuritySummaryValidationError{
					field:  fmt.Sprintf("Vulnerabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCisReport()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecuritySummaryValidationError{
					field:  "CisReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecuritySummaryValidationError{
					field:  "CisReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCisReport()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecuritySummaryValidationError{
				field:  "CisReport",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SecuritySummaryMultiError(errors)
	}

	return nil
}

// SecuritySummaryMultiError is an error wrapping multiple validation errors
// returned by SecuritySummary.ValidateAll() if the designated constraints
// aren't met.
type SecuritySummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecuritySummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecuritySummaryMultiError) AllErrors() []error { return m }

// SecuritySummaryValidationError is the validation error returned by
// SecuritySummary.Validate if the designated constraints aren't met.
type SecuritySummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecuritySummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecuritySummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecuritySummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecuritySummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecuritySummaryValidationError) ErrorName() string { return "SecuritySummaryValidationError" }

// Error satisfies the builtin error interface
func (e SecuritySummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecuritySummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecuritySummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecuritySummaryValidationError{}

// Validate checks the field values on ReleaseComparisonFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReleaseComparisonFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReleaseComparisonFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReleaseComparisonFilterMultiError, or nil if none found.
func (m *ReleaseComparisonFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReleaseComparisonFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := ReleaseComponent_name[int32(m.GetComponentName())]; !ok {
		err := ReleaseComparisonFilterValidationError{
			field:  "ComponentName",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ReleaseComparisonFilter_CurrReleaseId_Pattern.MatchString(m.GetCurrReleaseId()) {
		err := ReleaseComparisonFilterValidationError{
			field:  "CurrReleaseId",
			reason: "value does not match regex pattern \"^v[0-9]+\\\\.[0-9]+\\\\.[0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ReleaseComparisonFilter_NewReleaseId_Pattern.MatchString(m.GetNewReleaseId()) {
		err := ReleaseComparisonFilterValidationError{
			field:  "NewReleaseId",
			reason: "value does not match regex pattern \"^v[0-9]+\\\\.[0-9]+\\\\.[0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReleaseComparisonFilterMultiError(errors)
	}

	return nil
}

// ReleaseComparisonFilterMultiError is an error wrapping multiple validation
// errors returned by ReleaseComparisonFilter.ValidateAll() if the designated
// constraints aren't met.
type ReleaseComparisonFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReleaseComparisonFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReleaseComparisonFilterMultiError) AllErrors() []error { return m }

// ReleaseComparisonFilterValidationError is the validation error returned by
// ReleaseComparisonFilter.Validate if the designated constraints aren't met.
type ReleaseComparisonFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReleaseComparisonFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReleaseComparisonFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReleaseComparisonFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReleaseComparisonFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReleaseComparisonFilterValidationError) ErrorName() string {
	return "ReleaseComparisonFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ReleaseComparisonFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReleaseComparisonFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReleaseComparisonFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReleaseComparisonFilterValidationError{}

var _ReleaseComparisonFilter_CurrReleaseId_Pattern = regexp.MustCompile("^v[0-9]+\\.[0-9]+\\.[0-9]+$")

var _ReleaseComparisonFilter_NewReleaseId_Pattern = regexp.MustCompile("^v[0-9]+\\.[0-9]+\\.[0-9]+$")

// Validate checks the field values on VulnerabilityComparisonReport with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilityComparisonReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilityComparisonReport with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// VulnerabilityComparisonReportMultiError, or nil if none found.
func (m *VulnerabilityComparisonReport) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilityComparisonReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSummary() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VulnerabilityComparisonReportValidationError{
						field:  fmt.Sprintf("Summary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VulnerabilityComparisonReportValidationError{
						field:  fmt.Sprintf("Summary[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VulnerabilityComparisonReportValidationError{
					field:  fmt.Sprintf("Summary[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetReport() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VulnerabilityComparisonReportValidationError{
						field:  fmt.Sprintf("Report[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VulnerabilityComparisonReportValidationError{
						field:  fmt.Sprintf("Report[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VulnerabilityComparisonReportValidationError{
					field:  fmt.Sprintf("Report[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VulnerabilityComparisonReportMultiError(errors)
	}

	return nil
}

// VulnerabilityComparisonReportMultiError is an error wrapping multiple
// validation errors returned by VulnerabilityComparisonReport.ValidateAll()
// if the designated constraints aren't met.
type VulnerabilityComparisonReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilityComparisonReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilityComparisonReportMultiError) AllErrors() []error { return m }

// VulnerabilityComparisonReportValidationError is the validation error
// returned by VulnerabilityComparisonReport.Validate if the designated
// constraints aren't met.
type VulnerabilityComparisonReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilityComparisonReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilityComparisonReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilityComparisonReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilityComparisonReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilityComparisonReportValidationError) ErrorName() string {
	return "VulnerabilityComparisonReportValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilityComparisonReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilityComparisonReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilityComparisonReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilityComparisonReportValidationError{}

// Validate checks the field values on VulnerabilityDiscovery with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilityDiscovery) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilityDiscovery with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VulnerabilityDiscoveryMultiError, or nil if none found.
func (m *VulnerabilityDiscovery) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilityDiscovery) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Component

	// no validation rules for Fixed

	// no validation rules for Common

	// no validation rules for New

	if len(errors) > 0 {
		return VulnerabilityDiscoveryMultiError(errors)
	}

	return nil
}

// VulnerabilityDiscoveryMultiError is an error wrapping multiple validation
// errors returned by VulnerabilityDiscovery.ValidateAll() if the designated
// constraints aren't met.
type VulnerabilityDiscoveryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilityDiscoveryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilityDiscoveryMultiError) AllErrors() []error { return m }

// VulnerabilityDiscoveryValidationError is the validation error returned by
// VulnerabilityDiscovery.Validate if the designated constraints aren't met.
type VulnerabilityDiscoveryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilityDiscoveryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilityDiscoveryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilityDiscoveryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilityDiscoveryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilityDiscoveryValidationError) ErrorName() string {
	return "VulnerabilityDiscoveryValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilityDiscoveryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilityDiscovery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilityDiscoveryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilityDiscoveryValidationError{}

// Validate checks the field values on VulnerabilityComparisonSummary with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilityComparisonSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilityComparisonSummary with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// VulnerabilityComparisonSummaryMultiError, or nil if none found.
func (m *VulnerabilityComparisonSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilityComparisonSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ComponentName

	// no validation rules for CurrReleaseId

	// no validation rules for NewReleaseId

	// no validation rules for CurrComponentSHA256

	// no validation rules for NewComponentSHA256

	if all {
		switch v := interface{}(m.GetCurrScanTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "CurrScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "CurrScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrScanTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityComparisonSummaryValidationError{
				field:  "CurrScanTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNewScanTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "NewScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "NewScanTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewScanTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityComparisonSummaryValidationError{
				field:  "NewScanTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ScanTool

	if all {
		switch v := interface{}(m.GetFixed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "Fixed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "Fixed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFixed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityComparisonSummaryValidationError{
				field:  "Fixed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommon()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "Common",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommon()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityComparisonSummaryValidationError{
				field:  "Common",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNew()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "New",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VulnerabilityComparisonSummaryValidationError{
					field:  "New",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNew()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VulnerabilityComparisonSummaryValidationError{
				field:  "New",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VulnerabilityComparisonSummaryMultiError(errors)
	}

	return nil
}

// VulnerabilityComparisonSummaryMultiError is an error wrapping multiple
// validation errors returned by VulnerabilityComparisonSummary.ValidateAll()
// if the designated constraints aren't met.
type VulnerabilityComparisonSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilityComparisonSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilityComparisonSummaryMultiError) AllErrors() []error { return m }

// VulnerabilityComparisonSummaryValidationError is the validation error
// returned by VulnerabilityComparisonSummary.Validate if the designated
// constraints aren't met.
type VulnerabilityComparisonSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilityComparisonSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilityComparisonSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilityComparisonSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilityComparisonSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilityComparisonSummaryValidationError) ErrorName() string {
	return "VulnerabilityComparisonSummaryValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilityComparisonSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilityComparisonSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilityComparisonSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilityComparisonSummaryValidationError{}

// Validate checks the field values on VulnerabilitiesWrapper with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VulnerabilitiesWrapper) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VulnerabilitiesWrapper with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VulnerabilitiesWrapperMultiError, or nil if none found.
func (m *VulnerabilitiesWrapper) ValidateAll() error {
	return m.validate(true)
}

func (m *VulnerabilitiesWrapper) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVulns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VulnerabilitiesWrapperValidationError{
						field:  fmt.Sprintf("Vulns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VulnerabilitiesWrapperValidationError{
						field:  fmt.Sprintf("Vulns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VulnerabilitiesWrapperValidationError{
					field:  fmt.Sprintf("Vulns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VulnerabilitiesWrapperMultiError(errors)
	}

	return nil
}

// VulnerabilitiesWrapperMultiError is an error wrapping multiple validation
// errors returned by VulnerabilitiesWrapper.ValidateAll() if the designated
// constraints aren't met.
type VulnerabilitiesWrapperMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VulnerabilitiesWrapperMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VulnerabilitiesWrapperMultiError) AllErrors() []error { return m }

// VulnerabilitiesWrapperValidationError is the validation error returned by
// VulnerabilitiesWrapper.Validate if the designated constraints aren't met.
type VulnerabilitiesWrapperValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VulnerabilitiesWrapperValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VulnerabilitiesWrapperValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VulnerabilitiesWrapperValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VulnerabilitiesWrapperValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VulnerabilitiesWrapperValidationError) ErrorName() string {
	return "VulnerabilitiesWrapperValidationError"
}

// Error satisfies the builtin error interface
func (e VulnerabilitiesWrapperValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVulnerabilitiesWrapper.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VulnerabilitiesWrapperValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VulnerabilitiesWrapperValidationError{}
