// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: iks.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ClusterRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterRequestMultiError,
// or nil if none found.
func (m *ClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for K8Sversionname

	// no validation rules for Runtimename

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CloudAccountId

	// no validation rules for InstanceType

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Network != nil {

		if all {
			switch v := interface{}(m.GetNetwork()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterRequestValidationError{
						field:  "Network",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterRequestValidationError{
						field:  "Network",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetwork()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterRequestValidationError{
					field:  "Network",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Clustertype != nil {
		// no validation rules for Clustertype
	}

	if len(errors) > 0 {
		return ClusterRequestMultiError(errors)
	}

	return nil
}

// ClusterRequestMultiError is an error wrapping multiple validation errors
// returned by ClusterRequest.ValidateAll() if the designated constraints
// aren't met.
type ClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterRequestMultiError) AllErrors() []error { return m }

// ClusterRequestValidationError is the validation error returned by
// ClusterRequest.Validate if the designated constraints aren't met.
type ClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterRequestValidationError) ErrorName() string { return "ClusterRequestValidationError" }

// Error satisfies the builtin error interface
func (e ClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterRequestValidationError{}

// Validate checks the field values on ClusterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterResponseMultiError, or nil if none found.
func (m *ClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseValidationError{
					field:  fmt.Sprintf("Clusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClusterResponseMultiError(errors)
	}

	return nil
}

// ClusterResponseMultiError is an error wrapping multiple validation errors
// returned by ClusterResponse.ValidateAll() if the designated constraints
// aren't met.
type ClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterResponseMultiError) AllErrors() []error { return m }

// ClusterResponseValidationError is the validation error returned by
// ClusterResponse.Validate if the designated constraints aren't met.
type ClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterResponseValidationError) ErrorName() string { return "ClusterResponseValidationError" }

// Error satisfies the builtin error interface
func (e ClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterResponseValidationError{}

// Validate checks the field values on ClusterCreateResponseForm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterCreateResponseForm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterCreateResponseForm with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterCreateResponseFormMultiError, or nil if none found.
func (m *ClusterCreateResponseForm) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterCreateResponseForm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uuid

	// no validation rules for Name

	// no validation rules for Clusterstate

	// no validation rules for K8Sversionname

	if len(errors) > 0 {
		return ClusterCreateResponseFormMultiError(errors)
	}

	return nil
}

// ClusterCreateResponseFormMultiError is an error wrapping multiple validation
// errors returned by ClusterCreateResponseForm.ValidateAll() if the
// designated constraints aren't met.
type ClusterCreateResponseFormMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterCreateResponseFormMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterCreateResponseFormMultiError) AllErrors() []error { return m }

// ClusterCreateResponseFormValidationError is the validation error returned by
// ClusterCreateResponseForm.Validate if the designated constraints aren't met.
type ClusterCreateResponseFormValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterCreateResponseFormValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterCreateResponseFormValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterCreateResponseFormValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterCreateResponseFormValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterCreateResponseFormValidationError) ErrorName() string {
	return "ClusterCreateResponseFormValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterCreateResponseFormValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterCreateResponseForm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterCreateResponseFormValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterCreateResponseFormValidationError{}

// Validate checks the field values on ClusterResponseForm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterResponseForm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterResponseForm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterResponseFormMultiError, or nil if none found.
func (m *ClusterResponseForm) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterResponseForm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Uuid

	// no validation rules for Clusterstate

	if all {
		switch v := interface{}(m.GetClusterstatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterResponseFormValidationError{
					field:  "Clusterstatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterResponseFormValidationError{
					field:  "Clusterstatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterstatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterResponseFormValidationError{
				field:  "Clusterstatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Createddate

	// no validation rules for K8Sversion

	// no validation rules for Upgradeavailable

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVips() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Vips[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Vips[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  fmt.Sprintf("Vips[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetProvisioningLog() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("ProvisioningLog[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("ProvisioningLog[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  fmt.Sprintf("ProvisioningLog[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetNodegroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  fmt.Sprintf("Nodegroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Storageenabled

	for idx, item := range m.GetStorages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Storages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  fmt.Sprintf("Storages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  fmt.Sprintf("Storages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Clustertype

	if m.Network != nil {

		if all {
			switch v := interface{}(m.GetNetwork()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  "Network",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterResponseFormValidationError{
						field:  "Network",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetwork()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterResponseFormValidationError{
					field:  "Network",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClusterResponseFormMultiError(errors)
	}

	return nil
}

// ClusterResponseFormMultiError is an error wrapping multiple validation
// errors returned by ClusterResponseForm.ValidateAll() if the designated
// constraints aren't met.
type ClusterResponseFormMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterResponseFormMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterResponseFormMultiError) AllErrors() []error { return m }

// ClusterResponseFormValidationError is the validation error returned by
// ClusterResponseForm.Validate if the designated constraints aren't met.
type ClusterResponseFormValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterResponseFormValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterResponseFormValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterResponseFormValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterResponseFormValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterResponseFormValidationError) ErrorName() string {
	return "ClusterResponseFormValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterResponseFormValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterResponseForm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterResponseFormValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterResponseFormValidationError{}

// Validate checks the field values on ClusterStorageStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterStorageStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterStorageStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterStorageStatusMultiError, or nil if none found.
func (m *ClusterStorageStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterStorageStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Storageprovider

	// no validation rules for Size

	// no validation rules for State

	// no validation rules for Reason

	// no validation rules for Message

	if len(errors) > 0 {
		return ClusterStorageStatusMultiError(errors)
	}

	return nil
}

// ClusterStorageStatusMultiError is an error wrapping multiple validation
// errors returned by ClusterStorageStatus.ValidateAll() if the designated
// constraints aren't met.
type ClusterStorageStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterStorageStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterStorageStatusMultiError) AllErrors() []error { return m }

// ClusterStorageStatusValidationError is the validation error returned by
// ClusterStorageStatus.Validate if the designated constraints aren't met.
type ClusterStorageStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterStorageStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterStorageStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterStorageStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterStorageStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterStorageStatusValidationError) ErrorName() string {
	return "ClusterStorageStatusValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterStorageStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterStorageStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterStorageStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterStorageStatusValidationError{}

// Validate checks the field values on CreateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateNodeGroupRequestMultiError, or nil if none found.
func (m *CreateNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Name

	// no validation rules for Instancetypeid

	for idx, item := range m.GetVnets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Vnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Vnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeGroupRequestValidationError{
					field:  fmt.Sprintf("Vnets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Count

	for idx, item := range m.GetSshkeyname() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Sshkeyname[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Sshkeyname[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeGroupRequestValidationError{
					field:  fmt.Sprintf("Sshkeyname[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeGroupRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeGroupRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CloudAccountId

	// no validation rules for InstanceType

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Upgradestrategy != nil {

		if all {
			switch v := interface{}(m.GetUpgradestrategy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateNodeGroupRequestValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpgradestrategy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateNodeGroupRequestValidationError{
					field:  "Upgradestrategy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Userdataurl != nil {
		// no validation rules for Userdataurl
	}

	if m.Nodegrouptype != nil {
		// no validation rules for Nodegrouptype
	}

	if len(errors) > 0 {
		return CreateNodeGroupRequestMultiError(errors)
	}

	return nil
}

// CreateNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by CreateNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateNodeGroupRequestMultiError) AllErrors() []error { return m }

// CreateNodeGroupRequestValidationError is the validation error returned by
// CreateNodeGroupRequest.Validate if the designated constraints aren't met.
type CreateNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateNodeGroupRequestValidationError) ErrorName() string {
	return "CreateNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateNodeGroupRequestValidationError{}

// Validate checks the field values on Vnet with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Vnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Vnet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VnetMultiError, or nil if none found.
func (m *Vnet) ValidateAll() error {
	return m.validate(true)
}

func (m *Vnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Availabilityzonename

	// no validation rules for Networkinterfacevnetname

	if len(errors) > 0 {
		return VnetMultiError(errors)
	}

	return nil
}

// VnetMultiError is an error wrapping multiple validation errors returned by
// Vnet.ValidateAll() if the designated constraints aren't met.
type VnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VnetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VnetMultiError) AllErrors() []error { return m }

// VnetValidationError is the validation error returned by Vnet.Validate if the
// designated constraints aren't met.
type VnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VnetValidationError) ErrorName() string { return "VnetValidationError" }

// Error satisfies the builtin error interface
func (e VnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VnetValidationError{}

// Validate checks the field values on SshKey with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SshKey) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SshKey with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SshKeyMultiError, or nil if none found.
func (m *SshKey) ValidateAll() error {
	return m.validate(true)
}

func (m *SshKey) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSshkey()) > 63 {
		err := SshKeyValidationError{
			field:  "Sshkey",
			reason: "value length must be at most 63 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SshKey_Sshkey_Pattern.MatchString(m.GetSshkey()) {
		err := SshKeyValidationError{
			field:  "Sshkey",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SshKeyMultiError(errors)
	}

	return nil
}

// SshKeyMultiError is an error wrapping multiple validation errors returned by
// SshKey.ValidateAll() if the designated constraints aren't met.
type SshKeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SshKeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SshKeyMultiError) AllErrors() []error { return m }

// SshKeyValidationError is the validation error returned by SshKey.Validate if
// the designated constraints aren't met.
type SshKeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SshKeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SshKeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SshKeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SshKeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SshKeyValidationError) ErrorName() string { return "SshKeyValidationError" }

// Error satisfies the builtin error interface
func (e SshKeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSshKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SshKeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SshKeyValidationError{}

var _SshKey_Sshkey_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

// Validate checks the field values on NodeGroupResponseForm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeGroupResponseForm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupResponseForm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeGroupResponseFormMultiError, or nil if none found.
func (m *NodeGroupResponseForm) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupResponseForm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nodegroupuuid

	// no validation rules for Clusteruuid

	// no validation rules for Name

	// no validation rules for Instancetypeid

	// no validation rules for Nodegroupstate

	// no validation rules for Createddate

	if all {
		switch v := interface{}(m.GetNodegroupstatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeGroupResponseFormValidationError{
					field:  "Nodegroupstatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeGroupResponseFormValidationError{
					field:  "Nodegroupstatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodegroupstatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeGroupResponseFormValidationError{
				field:  "Nodegroupstatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	for idx, item := range m.GetVnets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Vnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Vnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseFormValidationError{
					field:  fmt.Sprintf("Vnets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSshkeyname() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Sshkeyname[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Sshkeyname[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseFormValidationError{
					field:  fmt.Sprintf("Sshkeyname[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Networkinterfacename

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseFormValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseFormValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Imiid

	// no validation rules for Upgradeavailable

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseFormValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Clustertype

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Upgradestrategy != nil {

		if all {
			switch v := interface{}(m.GetUpgradestrategy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseFormValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpgradestrategy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseFormValidationError{
					field:  "Upgradestrategy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Userdataurl != nil {
		// no validation rules for Userdataurl
	}

	if m.Nodegrouptype != nil {
		// no validation rules for Nodegrouptype
	}

	if len(errors) > 0 {
		return NodeGroupResponseFormMultiError(errors)
	}

	return nil
}

// NodeGroupResponseFormMultiError is an error wrapping multiple validation
// errors returned by NodeGroupResponseForm.ValidateAll() if the designated
// constraints aren't met.
type NodeGroupResponseFormMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupResponseFormMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupResponseFormMultiError) AllErrors() []error { return m }

// NodeGroupResponseFormValidationError is the validation error returned by
// NodeGroupResponseForm.Validate if the designated constraints aren't met.
type NodeGroupResponseFormValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupResponseFormValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupResponseFormValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupResponseFormValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupResponseFormValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupResponseFormValidationError) ErrorName() string {
	return "NodeGroupResponseFormValidationError"
}

// Error satisfies the builtin error interface
func (e NodeGroupResponseFormValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupResponseForm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupResponseFormValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupResponseFormValidationError{}

// Validate checks the field values on NodeGroupResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NodeGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeGroupResponseMultiError, or nil if none found.
func (m *NodeGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodegroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeGroupResponseValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeGroupResponseValidationError{
						field:  fmt.Sprintf("Nodegroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeGroupResponseValidationError{
					field:  fmt.Sprintf("Nodegroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeGroupResponseMultiError(errors)
	}

	return nil
}

// NodeGroupResponseMultiError is an error wrapping multiple validation errors
// returned by NodeGroupResponse.ValidateAll() if the designated constraints
// aren't met.
type NodeGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupResponseMultiError) AllErrors() []error { return m }

// NodeGroupResponseValidationError is the validation error returned by
// NodeGroupResponse.Validate if the designated constraints aren't met.
type NodeGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupResponseValidationError) ErrorName() string {
	return "NodeGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NodeGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupResponseValidationError{}

// Validate checks the field values on UpdateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNodeGroupRequestMultiError, or nil if none found.
func (m *UpdateNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeGroupRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeGroupRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeGroupRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CloudAccountId

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Count != nil {
		// no validation rules for Count
	}

	if m.Upgradestrategy != nil {

		if all {
			switch v := interface{}(m.GetUpgradestrategy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateNodeGroupRequestValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateNodeGroupRequestValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpgradestrategy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateNodeGroupRequestValidationError{
					field:  "Upgradestrategy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Nodegrouptype != nil {
		// no validation rules for Nodegrouptype
	}

	if len(errors) > 0 {
		return UpdateNodeGroupRequestMultiError(errors)
	}

	return nil
}

// UpdateNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNodeGroupRequestMultiError) AllErrors() []error { return m }

// UpdateNodeGroupRequestValidationError is the validation error returned by
// UpdateNodeGroupRequest.Validate if the designated constraints aren't met.
type UpdateNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNodeGroupRequestValidationError) ErrorName() string {
	return "UpdateNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNodeGroupRequestValidationError{}

// Validate checks the field values on DeleteNodeGroupInstanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNodeGroupInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNodeGroupInstanceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNodeGroupInstanceRequestMultiError, or nil if none found.
func (m *DeleteNodeGroupInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNodeGroupInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	// no validation rules for InstanceName

	// no validation rules for CloudAccountId

	if m.Downsize != nil {
		// no validation rules for Downsize
	}

	if len(errors) > 0 {
		return DeleteNodeGroupInstanceRequestMultiError(errors)
	}

	return nil
}

// DeleteNodeGroupInstanceRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteNodeGroupInstanceRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteNodeGroupInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNodeGroupInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNodeGroupInstanceRequestMultiError) AllErrors() []error { return m }

// DeleteNodeGroupInstanceRequestValidationError is the validation error
// returned by DeleteNodeGroupInstanceRequest.Validate if the designated
// constraints aren't met.
type DeleteNodeGroupInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNodeGroupInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNodeGroupInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNodeGroupInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNodeGroupInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNodeGroupInstanceRequestValidationError) ErrorName() string {
	return "DeleteNodeGroupInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNodeGroupInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNodeGroupInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNodeGroupInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNodeGroupInstanceRequestValidationError{}

// Validate checks the field values on NodeGroupid with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroupid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupid with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupidMultiError, or
// nil if none found.
func (m *NodeGroupid) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	// no validation rules for CloudAccountId

	if m.Nodegrouptype != nil {
		// no validation rules for Nodegrouptype
	}

	if len(errors) > 0 {
		return NodeGroupidMultiError(errors)
	}

	return nil
}

// NodeGroupidMultiError is an error wrapping multiple validation errors
// returned by NodeGroupid.ValidateAll() if the designated constraints aren't met.
type NodeGroupidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupidMultiError) AllErrors() []error { return m }

// NodeGroupidValidationError is the validation error returned by
// NodeGroupid.Validate if the designated constraints aren't met.
type NodeGroupidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupidValidationError) ErrorName() string { return "NodeGroupidValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupidValidationError{}

// Validate checks the field values on ProvisioningLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProvisioningLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProvisioningLog with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProvisioningLogMultiError, or nil if none found.
func (m *ProvisioningLog) ValidateAll() error {
	return m.validate(true)
}

func (m *ProvisioningLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Logentry

	// no validation rules for Loglevel

	// no validation rules for Logobject

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return ProvisioningLogMultiError(errors)
	}

	return nil
}

// ProvisioningLogMultiError is an error wrapping multiple validation errors
// returned by ProvisioningLog.ValidateAll() if the designated constraints
// aren't met.
type ProvisioningLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvisioningLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvisioningLogMultiError) AllErrors() []error { return m }

// ProvisioningLogValidationError is the validation error returned by
// ProvisioningLog.Validate if the designated constraints aren't met.
type ProvisioningLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvisioningLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvisioningLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvisioningLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvisioningLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvisioningLogValidationError) ErrorName() string { return "ProvisioningLogValidationError" }

// Error satisfies the builtin error interface
func (e ProvisioningLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvisioningLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvisioningLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvisioningLogValidationError{}

// Validate checks the field values on KeyValuePair with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyValuePair) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyValuePair with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyValuePairMultiError, or
// nil if none found.
func (m *KeyValuePair) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyValuePair) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return KeyValuePairMultiError(errors)
	}

	return nil
}

// KeyValuePairMultiError is an error wrapping multiple validation errors
// returned by KeyValuePair.ValidateAll() if the designated constraints aren't met.
type KeyValuePairMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyValuePairMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyValuePairMultiError) AllErrors() []error { return m }

// KeyValuePairValidationError is the validation error returned by
// KeyValuePair.Validate if the designated constraints aren't met.
type KeyValuePairValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValuePairValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValuePairValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValuePairValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValuePairValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValuePairValidationError) ErrorName() string { return "KeyValuePairValidationError" }

// Error satisfies the builtin error interface
func (e KeyValuePairValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyValuePair.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValuePairValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValuePairValidationError{}

// Validate checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Annotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnnotationsMultiError, or
// nil if none found.
func (m *Annotations) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return AnnotationsMultiError(errors)
	}

	return nil
}

// AnnotationsMultiError is an error wrapping multiple validation errors
// returned by Annotations.ValidateAll() if the designated constraints aren't met.
type AnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationsMultiError) AllErrors() []error { return m }

// AnnotationsValidationError is the validation error returned by
// Annotations.Validate if the designated constraints aren't met.
type AnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationsValidationError) ErrorName() string { return "AnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e AnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationsValidationError{}

// Validate checks the field values on ClusterID with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterID with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterIDMultiError, or nil
// if none found.
func (m *ClusterID) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for CloudAccountId

	if m.Clustertype != nil {
		// no validation rules for Clustertype
	}

	if len(errors) > 0 {
		return ClusterIDMultiError(errors)
	}

	return nil
}

// ClusterIDMultiError is an error wrapping multiple validation errors returned
// by ClusterID.ValidateAll() if the designated constraints aren't met.
type ClusterIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterIDMultiError) AllErrors() []error { return m }

// ClusterIDValidationError is the validation error returned by
// ClusterID.Validate if the designated constraints aren't met.
type ClusterIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterIDValidationError) ErrorName() string { return "ClusterIDValidationError" }

// Error satisfies the builtin error interface
func (e ClusterIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterIDValidationError{}

// Validate checks the field values on GetNodeGroupsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeGroupsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeGroupsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeGroupsRequestMultiError, or nil if none found.
func (m *GetNodeGroupsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeGroupsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for CloudAccountId

	if m.Nodes != nil {
		// no validation rules for Nodes
	}

	if len(errors) > 0 {
		return GetNodeGroupsRequestMultiError(errors)
	}

	return nil
}

// GetNodeGroupsRequestMultiError is an error wrapping multiple validation
// errors returned by GetNodeGroupsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNodeGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeGroupsRequestMultiError) AllErrors() []error { return m }

// GetNodeGroupsRequestValidationError is the validation error returned by
// GetNodeGroupsRequest.Validate if the designated constraints aren't met.
type GetNodeGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeGroupsRequestValidationError) ErrorName() string {
	return "GetNodeGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeGroupsRequestValidationError{}

// Validate checks the field values on NodeGroupID with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeGroupID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeGroupID with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeGroupIDMultiError, or
// nil if none found.
func (m *NodeGroupID) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeGroupID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nodegroupuuid

	if len(errors) > 0 {
		return NodeGroupIDMultiError(errors)
	}

	return nil
}

// NodeGroupIDMultiError is an error wrapping multiple validation errors
// returned by NodeGroupID.ValidateAll() if the designated constraints aren't met.
type NodeGroupIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeGroupIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeGroupIDMultiError) AllErrors() []error { return m }

// NodeGroupIDValidationError is the validation error returned by
// NodeGroupID.Validate if the designated constraints aren't met.
type NodeGroupIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeGroupIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeGroupIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeGroupIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeGroupIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeGroupIDValidationError) ErrorName() string { return "NodeGroupIDValidationError" }

// Error satisfies the builtin error interface
func (e NodeGroupIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeGroupID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeGroupIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeGroupIDValidationError{}

// Validate checks the field values on UpgradeClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpgradeClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeClusterRequestMultiError, or nil if none found.
func (m *UpgradeClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for CloudAccountId

	if m.K8Sversionname != nil {
		// no validation rules for K8Sversionname
	}

	if len(errors) > 0 {
		return UpgradeClusterRequestMultiError(errors)
	}

	return nil
}

// UpgradeClusterRequestMultiError is an error wrapping multiple validation
// errors returned by UpgradeClusterRequest.ValidateAll() if the designated
// constraints aren't met.
type UpgradeClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeClusterRequestMultiError) AllErrors() []error { return m }

// UpgradeClusterRequestValidationError is the validation error returned by
// UpgradeClusterRequest.Validate if the designated constraints aren't met.
type UpgradeClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeClusterRequestValidationError) ErrorName() string {
	return "UpgradeClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpgradeClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeClusterRequestValidationError{}

// Validate checks the field values on ClusterStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterStatusMultiError, or
// nil if none found.
func (m *ClusterStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Clusteruuid

	// no validation rules for State

	// no validation rules for Lastupdate

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Errorcode

	if len(errors) > 0 {
		return ClusterStatusMultiError(errors)
	}

	return nil
}

// ClusterStatusMultiError is an error wrapping multiple validation errors
// returned by ClusterStatus.ValidateAll() if the designated constraints
// aren't met.
type ClusterStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterStatusMultiError) AllErrors() []error { return m }

// ClusterStatusValidationError is the validation error returned by
// ClusterStatus.Validate if the designated constraints aren't met.
type ClusterStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterStatusValidationError) ErrorName() string { return "ClusterStatusValidationError" }

// Error satisfies the builtin error interface
func (e ClusterStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterStatusValidationError{}

// Validate checks the field values on Nodegroupstatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Nodegroupstatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Nodegroupstatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodegroupstatusMultiError, or nil if none found.
func (m *Nodegroupstatus) ValidateAll() error {
	return m.validate(true)
}

func (m *Nodegroupstatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	// no validation rules for Count

	// no validation rules for State

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Errorcode

	for idx, item := range m.GetNodestatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupstatusValidationError{
						field:  fmt.Sprintf("Nodestatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupstatusValidationError{
						field:  fmt.Sprintf("Nodestatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupstatusValidationError{
					field:  fmt.Sprintf("Nodestatus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Nodegroupsummary != nil {

		if all {
			switch v := interface{}(m.GetNodegroupsummary()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupstatusValidationError{
						field:  "Nodegroupsummary",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupstatusValidationError{
						field:  "Nodegroupsummary",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNodegroupsummary()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupstatusValidationError{
					field:  "Nodegroupsummary",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodegroupstatusMultiError(errors)
	}

	return nil
}

// NodegroupstatusMultiError is an error wrapping multiple validation errors
// returned by Nodegroupstatus.ValidateAll() if the designated constraints
// aren't met.
type NodegroupstatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodegroupstatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodegroupstatusMultiError) AllErrors() []error { return m }

// NodegroupstatusValidationError is the validation error returned by
// Nodegroupstatus.Validate if the designated constraints aren't met.
type NodegroupstatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodegroupstatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodegroupstatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodegroupstatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodegroupstatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodegroupstatusValidationError) ErrorName() string { return "NodegroupstatusValidationError" }

// Error satisfies the builtin error interface
func (e NodegroupstatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodegroupstatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodegroupstatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodegroupstatusValidationError{}

// Validate checks the field values on NodegroupSummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NodegroupSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodegroupSummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodegroupSummaryMultiError, or nil if none found.
func (m *NodegroupSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *NodegroupSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Activenodes

	// no validation rules for Provisioningnodes

	// no validation rules for Errornodes

	// no validation rules for Deletingnodes

	if len(errors) > 0 {
		return NodegroupSummaryMultiError(errors)
	}

	return nil
}

// NodegroupSummaryMultiError is an error wrapping multiple validation errors
// returned by NodegroupSummary.ValidateAll() if the designated constraints
// aren't met.
type NodegroupSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodegroupSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodegroupSummaryMultiError) AllErrors() []error { return m }

// NodegroupSummaryValidationError is the validation error returned by
// NodegroupSummary.Validate if the designated constraints aren't met.
type NodegroupSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodegroupSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodegroupSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodegroupSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodegroupSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodegroupSummaryValidationError) ErrorName() string { return "NodegroupSummaryValidationError" }

// Error satisfies the builtin error interface
func (e NodegroupSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodegroupSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodegroupSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodegroupSummaryValidationError{}

// Validate checks the field values on NodeStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeStatusMultiError, or
// nil if none found.
func (m *NodeStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Ipaddress

	// no validation rules for Dnsname

	// no validation rules for Imi

	// no validation rules for State

	// no validation rules for Createddate

	// no validation rules for Instanceimi

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Errorcode

	// no validation rules for Unschedulable

	if all {
		switch v := interface{}(m.GetWekaStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeStatusValidationError{
					field:  "WekaStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeStatusValidationError{
					field:  "WekaStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWekaStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeStatusValidationError{
				field:  "WekaStorage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeStatusMultiError(errors)
	}

	return nil
}

// NodeStatusMultiError is an error wrapping multiple validation errors
// returned by NodeStatus.ValidateAll() if the designated constraints aren't met.
type NodeStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeStatusMultiError) AllErrors() []error { return m }

// NodeStatusValidationError is the validation error returned by
// NodeStatus.Validate if the designated constraints aren't met.
type NodeStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeStatusValidationError) ErrorName() string { return "NodeStatusValidationError" }

// Error satisfies the builtin error interface
func (e NodeStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeStatusValidationError{}

// Validate checks the field values on ClusterInstance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClusterInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterInstanceMultiError, or nil if none found.
func (m *ClusterInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInstanceos()) < 1 {
		err := ClusterInstanceValidationError{
			field:  "Instanceos",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstancetype()) < 1 {
		err := ClusterInstanceValidationError{
			field:  "Instancetype",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ClusterInstanceMultiError(errors)
	}

	return nil
}

// ClusterInstanceMultiError is an error wrapping multiple validation errors
// returned by ClusterInstance.ValidateAll() if the designated constraints
// aren't met.
type ClusterInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterInstanceMultiError) AllErrors() []error { return m }

// ClusterInstanceValidationError is the validation error returned by
// ClusterInstance.Validate if the designated constraints aren't met.
type ClusterInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterInstanceValidationError) ErrorName() string { return "ClusterInstanceValidationError" }

// Error satisfies the builtin error interface
func (e ClusterInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterInstanceValidationError{}

// Validate checks the field values on Taint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Taint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Taint with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaintMultiError, or nil if none found.
func (m *Taint) ValidateAll() error {
	return m.validate(true)
}

func (m *Taint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Operator

	if len(m.GetValue()) > 253 {
		err := TaintValidationError{
			field:  "Value",
			reason: "value length must be at most 253 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Taint_Value_Pattern.MatchString(m.GetValue()) {
		err := TaintValidationError{
			field:  "Value",
			reason: "value does not match regex pattern \"^([a-zA-Z])[a-zA-Z0-9-_]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Effect

	if len(errors) > 0 {
		return TaintMultiError(errors)
	}

	return nil
}

// TaintMultiError is an error wrapping multiple validation errors returned by
// Taint.ValidateAll() if the designated constraints aren't met.
type TaintMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaintMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaintMultiError) AllErrors() []error { return m }

// TaintValidationError is the validation error returned by Taint.Validate if
// the designated constraints aren't met.
type TaintValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaintValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaintValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaintValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaintValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaintValidationError) ErrorName() string { return "TaintValidationError" }

// Error satisfies the builtin error interface
func (e TaintValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaintValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaintValidationError{}

var _Taint_Value_Pattern = regexp.MustCompile("^([a-zA-Z])[a-zA-Z0-9-_]*$")

// Validate checks the field values on UpgradeStrategy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpgradeStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpgradeStrategy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpgradeStrategyMultiError, or nil if none found.
func (m *UpgradeStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *UpgradeStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Drainnodes

	// no validation rules for Maxunavailablepercentage

	if len(errors) > 0 {
		return UpgradeStrategyMultiError(errors)
	}

	return nil
}

// UpgradeStrategyMultiError is an error wrapping multiple validation errors
// returned by UpgradeStrategy.ValidateAll() if the designated constraints
// aren't met.
type UpgradeStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpgradeStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpgradeStrategyMultiError) AllErrors() []error { return m }

// UpgradeStrategyValidationError is the validation error returned by
// UpgradeStrategy.Validate if the designated constraints aren't met.
type UpgradeStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpgradeStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpgradeStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpgradeStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpgradeStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpgradeStrategyValidationError) ErrorName() string { return "UpgradeStrategyValidationError" }

// Error satisfies the builtin error interface
func (e UpgradeStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpgradeStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpgradeStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpgradeStrategyValidationError{}

// Validate checks the field values on Network with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Network) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Network with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NetworkMultiError, or nil if none found.
func (m *Network) ValidateAll() error {
	return m.validate(true)
}

func (m *Network) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enableloadbalancer

	// no validation rules for Region

	if m.Servicecidr != nil {
		// no validation rules for Servicecidr
	}

	if m.Clustercidr != nil {
		// no validation rules for Clustercidr
	}

	if m.Clusterdns != nil {
		// no validation rules for Clusterdns
	}

	if len(errors) > 0 {
		return NetworkMultiError(errors)
	}

	return nil
}

// NetworkMultiError is an error wrapping multiple validation errors returned
// by Network.ValidateAll() if the designated constraints aren't met.
type NetworkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkMultiError) AllErrors() []error { return m }

// NetworkValidationError is the validation error returned by Network.Validate
// if the designated constraints aren't met.
type NetworkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkValidationError) ErrorName() string { return "NetworkValidationError" }

// Error satisfies the builtin error interface
func (e NetworkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetwork.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkValidationError{}

// Validate checks the field values on EncryptionConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EncryptionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EncryptionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EncryptionConfigMultiError, or nil if none found.
func (m *EncryptionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EncryptionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Source

	// no validation rules for Encrytionalgorithm

	// no validation rules for Externalkms

	if len(errors) > 0 {
		return EncryptionConfigMultiError(errors)
	}

	return nil
}

// EncryptionConfigMultiError is an error wrapping multiple validation errors
// returned by EncryptionConfig.ValidateAll() if the designated constraints
// aren't met.
type EncryptionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EncryptionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EncryptionConfigMultiError) AllErrors() []error { return m }

// EncryptionConfigValidationError is the validation error returned by
// EncryptionConfig.Validate if the designated constraints aren't met.
type EncryptionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EncryptionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EncryptionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EncryptionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EncryptionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EncryptionConfigValidationError) ErrorName() string { return "EncryptionConfigValidationError" }

// Error satisfies the builtin error interface
func (e EncryptionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEncryptionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EncryptionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EncryptionConfigValidationError{}

// Validate checks the field values on AdvancedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AdvancedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdvancedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdvancedConfigMultiError,
// or nil if none found.
func (m *AdvancedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AdvancedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetKubeapiserverArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("KubeapiserverArgs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("KubeapiserverArgs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdvancedConfigValidationError{
					field:  fmt.Sprintf("KubeapiserverArgs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKubeproxyargs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubeproxyargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubeproxyargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdvancedConfigValidationError{
					field:  fmt.Sprintf("Kubeproxyargs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKubecontrollerargs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubecontrollerargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubecontrollerargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdvancedConfigValidationError{
					field:  fmt.Sprintf("Kubecontrollerargs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKubeschedularargs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubeschedularargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubeschedularargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdvancedConfigValidationError{
					field:  fmt.Sprintf("Kubeschedularargs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKubeletargs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubeletargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdvancedConfigValidationError{
						field:  fmt.Sprintf("Kubeletargs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdvancedConfigValidationError{
					field:  fmt.Sprintf("Kubeletargs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AdvancedConfigMultiError(errors)
	}

	return nil
}

// AdvancedConfigMultiError is an error wrapping multiple validation errors
// returned by AdvancedConfig.ValidateAll() if the designated constraints
// aren't met.
type AdvancedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdvancedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdvancedConfigMultiError) AllErrors() []error { return m }

// AdvancedConfigValidationError is the validation error returned by
// AdvancedConfig.Validate if the designated constraints aren't met.
type AdvancedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdvancedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdvancedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdvancedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdvancedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdvancedConfigValidationError) ErrorName() string { return "AdvancedConfigValidationError" }

// Error satisfies the builtin error interface
func (e AdvancedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdvancedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdvancedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdvancedConfigValidationError{}

// Validate checks the field values on Member with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Member) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Member with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MemberMultiError, or nil if none found.
func (m *Member) ValidateAll() error {
	return m.validate(true)
}

func (m *Member) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kubeconfig

	// no validation rules for Cloudaccount

	if len(errors) > 0 {
		return MemberMultiError(errors)
	}

	return nil
}

// MemberMultiError is an error wrapping multiple validation errors returned by
// Member.ValidateAll() if the designated constraints aren't met.
type MemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemberMultiError) AllErrors() []error { return m }

// MemberValidationError is the validation error returned by Member.Validate if
// the designated constraints aren't met.
type MemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemberValidationError) ErrorName() string { return "MemberValidationError" }

// Error satisfies the builtin error interface
func (e MemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemberValidationError{}

// Validate checks the field values on GetNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNodeGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNodeGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNodeGroupRequestMultiError, or nil if none found.
func (m *GetNodeGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNodeGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Nodegroupuuid

	// no validation rules for CloudAccountId

	if m.Nodes != nil {
		// no validation rules for Nodes
	}

	if len(errors) > 0 {
		return GetNodeGroupRequestMultiError(errors)
	}

	return nil
}

// GetNodeGroupRequestMultiError is an error wrapping multiple validation
// errors returned by GetNodeGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type GetNodeGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNodeGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNodeGroupRequestMultiError) AllErrors() []error { return m }

// GetNodeGroupRequestValidationError is the validation error returned by
// GetNodeGroupRequest.Validate if the designated constraints aren't met.
type GetNodeGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNodeGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNodeGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNodeGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNodeGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNodeGroupRequestValidationError) ErrorName() string {
	return "GetNodeGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNodeGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNodeGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNodeGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNodeGroupRequestValidationError{}

// Validate checks the field values on UpdateClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterRequestMultiError, or nil if none found.
func (m *UpdateClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Clusteruuid

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateClusterRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateClusterRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateClusterRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateClusterRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateClusterRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateClusterRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return UpdateClusterRequestMultiError(errors)
	}

	return nil
}

// UpdateClusterRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateClusterRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterRequestMultiError) AllErrors() []error { return m }

// UpdateClusterRequestValidationError is the validation error returned by
// UpdateClusterRequest.Validate if the designated constraints aren't met.
type UpdateClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterRequestValidationError) ErrorName() string {
	return "UpdateClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterRequestValidationError{}

// Validate checks the field values on ClustersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClustersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClustersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClustersResponseMultiError, or nil if none found.
func (m *ClustersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClustersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClustersResponseValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClustersResponseValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClustersResponseValidationError{
					field:  fmt.Sprintf("Clusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetResourcelimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClustersResponseValidationError{
					field:  "Resourcelimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClustersResponseValidationError{
					field:  "Resourcelimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourcelimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClustersResponseValidationError{
				field:  "Resourcelimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClustersResponseMultiError(errors)
	}

	return nil
}

// ClustersResponseMultiError is an error wrapping multiple validation errors
// returned by ClustersResponse.ValidateAll() if the designated constraints
// aren't met.
type ClustersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClustersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClustersResponseMultiError) AllErrors() []error { return m }

// ClustersResponseValidationError is the validation error returned by
// ClustersResponse.Validate if the designated constraints aren't met.
type ClustersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClustersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClustersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClustersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClustersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClustersResponseValidationError) ErrorName() string { return "ClustersResponseValidationError" }

// Error satisfies the builtin error interface
func (e ClustersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClustersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClustersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClustersResponseValidationError{}

// Validate checks the field values on ResourceLimits with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceLimits) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceLimits with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceLimitsMultiError,
// or nil if none found.
func (m *ResourceLimits) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceLimits) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Maxclusterpercloudaccount

	// no validation rules for Maxnodegroupspercluster

	// no validation rules for Maxvipspercluster

	// no validation rules for Maxnodespernodegroup

	// no validation rules for Maxclustervm

	if len(errors) > 0 {
		return ResourceLimitsMultiError(errors)
	}

	return nil
}

// ResourceLimitsMultiError is an error wrapping multiple validation errors
// returned by ResourceLimits.ValidateAll() if the designated constraints
// aren't met.
type ResourceLimitsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceLimitsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceLimitsMultiError) AllErrors() []error { return m }

// ResourceLimitsValidationError is the validation error returned by
// ResourceLimits.Validate if the designated constraints aren't met.
type ResourceLimitsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceLimitsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceLimitsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceLimitsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceLimitsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceLimitsValidationError) ErrorName() string { return "ResourceLimitsValidationError" }

// Error satisfies the builtin error interface
func (e ResourceLimitsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceLimits.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceLimitsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceLimitsValidationError{}

// Validate checks the field values on GetPublicK8SversionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPublicK8SversionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicK8SversionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPublicK8SversionResponseMultiError, or nil if none found.
func (m *GetPublicK8SversionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicK8SversionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for K8Sversionname

	if len(errors) > 0 {
		return GetPublicK8SversionResponseMultiError(errors)
	}

	return nil
}

// GetPublicK8SversionResponseMultiError is an error wrapping multiple
// validation errors returned by GetPublicK8SversionResponse.ValidateAll() if
// the designated constraints aren't met.
type GetPublicK8SversionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicK8SversionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicK8SversionResponseMultiError) AllErrors() []error { return m }

// GetPublicK8SversionResponseValidationError is the validation error returned
// by GetPublicK8SversionResponse.Validate if the designated constraints
// aren't met.
type GetPublicK8SversionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicK8SversionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicK8SversionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicK8SversionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicK8SversionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicK8SversionResponseValidationError) ErrorName() string {
	return "GetPublicK8SversionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicK8SversionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicK8SversionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicK8SversionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicK8SversionResponseValidationError{}

// Validate checks the field values on GetPublicAllK8SversionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPublicAllK8SversionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicAllK8SversionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetPublicAllK8SversionResponseMultiError, or nil if none found.
func (m *GetPublicAllK8SversionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicAllK8SversionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetK8Sversions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPublicAllK8SversionResponseValidationError{
						field:  fmt.Sprintf("K8Sversions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPublicAllK8SversionResponseValidationError{
						field:  fmt.Sprintf("K8Sversions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPublicAllK8SversionResponseValidationError{
					field:  fmt.Sprintf("K8Sversions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPublicAllK8SversionResponseMultiError(errors)
	}

	return nil
}

// GetPublicAllK8SversionResponseMultiError is an error wrapping multiple
// validation errors returned by GetPublicAllK8SversionResponse.ValidateAll()
// if the designated constraints aren't met.
type GetPublicAllK8SversionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicAllK8SversionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicAllK8SversionResponseMultiError) AllErrors() []error { return m }

// GetPublicAllK8SversionResponseValidationError is the validation error
// returned by GetPublicAllK8SversionResponse.Validate if the designated
// constraints aren't met.
type GetPublicAllK8SversionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicAllK8SversionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicAllK8SversionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicAllK8SversionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicAllK8SversionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicAllK8SversionResponseValidationError) ErrorName() string {
	return "GetPublicAllK8SversionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicAllK8SversionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicAllK8SversionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicAllK8SversionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicAllK8SversionResponseValidationError{}

// Validate checks the field values on GetPublicRuntimeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPublicRuntimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicRuntimeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPublicRuntimeResponseMultiError, or nil if none found.
func (m *GetPublicRuntimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicRuntimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Runtimename

	if len(errors) > 0 {
		return GetPublicRuntimeResponseMultiError(errors)
	}

	return nil
}

// GetPublicRuntimeResponseMultiError is an error wrapping multiple validation
// errors returned by GetPublicRuntimeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetPublicRuntimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicRuntimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicRuntimeResponseMultiError) AllErrors() []error { return m }

// GetPublicRuntimeResponseValidationError is the validation error returned by
// GetPublicRuntimeResponse.Validate if the designated constraints aren't met.
type GetPublicRuntimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicRuntimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicRuntimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicRuntimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicRuntimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicRuntimeResponseValidationError) ErrorName() string {
	return "GetPublicRuntimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicRuntimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicRuntimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicRuntimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicRuntimeResponseValidationError{}

// Validate checks the field values on GetPublicAllRuntimeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPublicAllRuntimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicAllRuntimeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPublicAllRuntimeResponseMultiError, or nil if none found.
func (m *GetPublicAllRuntimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicAllRuntimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRuntimes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPublicAllRuntimeResponseValidationError{
						field:  fmt.Sprintf("Runtimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPublicAllRuntimeResponseValidationError{
						field:  fmt.Sprintf("Runtimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPublicAllRuntimeResponseValidationError{
					field:  fmt.Sprintf("Runtimes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPublicAllRuntimeResponseMultiError(errors)
	}

	return nil
}

// GetPublicAllRuntimeResponseMultiError is an error wrapping multiple
// validation errors returned by GetPublicAllRuntimeResponse.ValidateAll() if
// the designated constraints aren't met.
type GetPublicAllRuntimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicAllRuntimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicAllRuntimeResponseMultiError) AllErrors() []error { return m }

// GetPublicAllRuntimeResponseValidationError is the validation error returned
// by GetPublicAllRuntimeResponse.Validate if the designated constraints
// aren't met.
type GetPublicAllRuntimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicAllRuntimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicAllRuntimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicAllRuntimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicAllRuntimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicAllRuntimeResponseValidationError) ErrorName() string {
	return "GetPublicAllRuntimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicAllRuntimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicAllRuntimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicAllRuntimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicAllRuntimeResponseValidationError{}

// Validate checks the field values on GetPublicInstancetypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPublicInstancetypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicInstancetypeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetPublicInstancetypeResponseMultiError, or nil if none found.
func (m *GetPublicInstancetypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicInstancetypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Instancetypename

	// no validation rules for Memory

	// no validation rules for Cpu

	// no validation rules for Storage

	// no validation rules for Displayname

	// no validation rules for Description

	// no validation rules for Instancecategory

	if len(errors) > 0 {
		return GetPublicInstancetypeResponseMultiError(errors)
	}

	return nil
}

// GetPublicInstancetypeResponseMultiError is an error wrapping multiple
// validation errors returned by GetPublicInstancetypeResponse.ValidateAll()
// if the designated constraints aren't met.
type GetPublicInstancetypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicInstancetypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicInstancetypeResponseMultiError) AllErrors() []error { return m }

// GetPublicInstancetypeResponseValidationError is the validation error
// returned by GetPublicInstancetypeResponse.Validate if the designated
// constraints aren't met.
type GetPublicInstancetypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicInstancetypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicInstancetypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicInstancetypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicInstancetypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicInstancetypeResponseValidationError) ErrorName() string {
	return "GetPublicInstancetypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicInstancetypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicInstancetypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicInstancetypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicInstancetypeResponseValidationError{}

// Validate checks the field values on GetPublicAllInstancetypeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetPublicAllInstancetypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicAllInstancetypeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetPublicAllInstancetypeResponseMultiError, or nil if none found.
func (m *GetPublicAllInstancetypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicAllInstancetypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstancetypes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPublicAllInstancetypeResponseValidationError{
						field:  fmt.Sprintf("Instancetypes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPublicAllInstancetypeResponseValidationError{
						field:  fmt.Sprintf("Instancetypes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPublicAllInstancetypeResponseValidationError{
					field:  fmt.Sprintf("Instancetypes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPublicAllInstancetypeResponseMultiError(errors)
	}

	return nil
}

// GetPublicAllInstancetypeResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetPublicAllInstancetypeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetPublicAllInstancetypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicAllInstancetypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicAllInstancetypeResponseMultiError) AllErrors() []error { return m }

// GetPublicAllInstancetypeResponseValidationError is the validation error
// returned by GetPublicAllInstancetypeResponse.Validate if the designated
// constraints aren't met.
type GetPublicAllInstancetypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicAllInstancetypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicAllInstancetypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicAllInstancetypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicAllInstancetypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicAllInstancetypeResponseValidationError) ErrorName() string {
	return "GetPublicAllInstancetypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicAllInstancetypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicAllInstancetypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicAllInstancetypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicAllInstancetypeResponseValidationError{}

// Validate checks the field values on GetKubeconfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetKubeconfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKubeconfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetKubeconfigRequestMultiError, or nil if none found.
func (m *GetKubeconfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKubeconfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for CloudAccountId

	if m.Readonly != nil {
		// no validation rules for Readonly
	}

	if len(errors) > 0 {
		return GetKubeconfigRequestMultiError(errors)
	}

	return nil
}

// GetKubeconfigRequestMultiError is an error wrapping multiple validation
// errors returned by GetKubeconfigRequest.ValidateAll() if the designated
// constraints aren't met.
type GetKubeconfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKubeconfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKubeconfigRequestMultiError) AllErrors() []error { return m }

// GetKubeconfigRequestValidationError is the validation error returned by
// GetKubeconfigRequest.Validate if the designated constraints aren't met.
type GetKubeconfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKubeconfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKubeconfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKubeconfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKubeconfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKubeconfigRequestValidationError) ErrorName() string {
	return "GetKubeconfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetKubeconfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKubeconfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKubeconfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKubeconfigRequestValidationError{}

// Validate checks the field values on GetKubeconfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetKubeconfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKubeconfigResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetKubeconfigResponseMultiError, or nil if none found.
func (m *GetKubeconfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKubeconfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusterid

	// no validation rules for Kubeconfig

	if len(errors) > 0 {
		return GetKubeconfigResponseMultiError(errors)
	}

	return nil
}

// GetKubeconfigResponseMultiError is an error wrapping multiple validation
// errors returned by GetKubeconfigResponse.ValidateAll() if the designated
// constraints aren't met.
type GetKubeconfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKubeconfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKubeconfigResponseMultiError) AllErrors() []error { return m }

// GetKubeconfigResponseValidationError is the validation error returned by
// GetKubeconfigResponse.Validate if the designated constraints aren't met.
type GetKubeconfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKubeconfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKubeconfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKubeconfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKubeconfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKubeconfigResponseValidationError) ErrorName() string {
	return "GetKubeconfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetKubeconfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKubeconfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKubeconfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKubeconfigResponseValidationError{}

// Validate checks the field values on IksCloudAccountId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IksCloudAccountId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IksCloudAccountId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IksCloudAccountIdMultiError, or nil if none found.
func (m *IksCloudAccountId) ValidateAll() error {
	return m.validate(true)
}

func (m *IksCloudAccountId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return IksCloudAccountIdMultiError(errors)
	}

	return nil
}

// IksCloudAccountIdMultiError is an error wrapping multiple validation errors
// returned by IksCloudAccountId.ValidateAll() if the designated constraints
// aren't met.
type IksCloudAccountIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IksCloudAccountIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IksCloudAccountIdMultiError) AllErrors() []error { return m }

// IksCloudAccountIdValidationError is the validation error returned by
// IksCloudAccountId.Validate if the designated constraints aren't met.
type IksCloudAccountIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IksCloudAccountIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IksCloudAccountIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IksCloudAccountIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IksCloudAccountIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IksCloudAccountIdValidationError) ErrorName() string {
	return "IksCloudAccountIdValidationError"
}

// Error satisfies the builtin error interface
func (e IksCloudAccountIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIksCloudAccountId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IksCloudAccountIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IksCloudAccountIdValidationError{}

// Validate checks the field values on VipCreateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VipCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VipCreateRequestMultiError, or nil if none found.
func (m *VipCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VipCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Port

	// no validation rules for Viptype

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return VipCreateRequestMultiError(errors)
	}

	return nil
}

// VipCreateRequestMultiError is an error wrapping multiple validation errors
// returned by VipCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type VipCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipCreateRequestMultiError) AllErrors() []error { return m }

// VipCreateRequestValidationError is the validation error returned by
// VipCreateRequest.Validate if the designated constraints aren't met.
type VipCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipCreateRequestValidationError) ErrorName() string { return "VipCreateRequestValidationError" }

// Error satisfies the builtin error interface
func (e VipCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipCreateRequestValidationError{}

// Validate checks the field values on VipResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VipResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VipResponseMultiError, or
// nil if none found.
func (m *VipResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VipResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Vipid

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Vipstate

	// no validation rules for Port

	// no validation rules for Poolport

	// no validation rules for Viptype

	if len(errors) > 0 {
		return VipResponseMultiError(errors)
	}

	return nil
}

// VipResponseMultiError is an error wrapping multiple validation errors
// returned by VipResponse.ValidateAll() if the designated constraints aren't met.
type VipResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipResponseMultiError) AllErrors() []error { return m }

// VipResponseValidationError is the validation error returned by
// VipResponse.Validate if the designated constraints aren't met.
type VipResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipResponseValidationError) ErrorName() string { return "VipResponseValidationError" }

// Error satisfies the builtin error interface
func (e VipResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipResponseValidationError{}

// Validate checks the field values on VipStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VipStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VipStatusMultiError, or nil
// if none found.
func (m *VipStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *VipStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Vipstate

	// no validation rules for Message

	// no validation rules for Poolid

	// no validation rules for Vipid

	// no validation rules for Errorcode

	if len(errors) > 0 {
		return VipStatusMultiError(errors)
	}

	return nil
}

// VipStatusMultiError is an error wrapping multiple validation errors returned
// by VipStatus.ValidateAll() if the designated constraints aren't met.
type VipStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipStatusMultiError) AllErrors() []error { return m }

// VipStatusValidationError is the validation error returned by
// VipStatus.Validate if the designated constraints aren't met.
type VipStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipStatusValidationError) ErrorName() string { return "VipStatusValidationError" }

// Error satisfies the builtin error interface
func (e VipStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipStatusValidationError{}

// Validate checks the field values on GetVipResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetVipResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVipResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetVipResponseMultiError,
// or nil if none found.
func (m *GetVipResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVipResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Vipid

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Vipstate

	// no validation rules for Port

	// no validation rules for Poolport

	// no validation rules for Viptype

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetVipResponseValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetVipResponseValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetVipResponseValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetVipstatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetVipResponseValidationError{
					field:  "Vipstatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetVipResponseValidationError{
					field:  "Vipstatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVipstatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetVipResponseValidationError{
				field:  "Vipstatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Createddate

	if m.VipIp != nil {
		// no validation rules for VipIp
	}

	if len(errors) > 0 {
		return GetVipResponseMultiError(errors)
	}

	return nil
}

// GetVipResponseMultiError is an error wrapping multiple validation errors
// returned by GetVipResponse.ValidateAll() if the designated constraints
// aren't met.
type GetVipResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVipResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVipResponseMultiError) AllErrors() []error { return m }

// GetVipResponseValidationError is the validation error returned by
// GetVipResponse.Validate if the designated constraints aren't met.
type GetVipResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVipResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVipResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVipResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVipResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVipResponseValidationError) ErrorName() string { return "GetVipResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetVipResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVipResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVipResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVipResponseValidationError{}

// Validate checks the field values on Members with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Members) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Members with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MembersMultiError, or nil if none found.
func (m *Members) ValidateAll() error {
	return m.validate(true)
}

func (m *Members) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MembersMultiError(errors)
	}

	return nil
}

// MembersMultiError is an error wrapping multiple validation errors returned
// by Members.ValidateAll() if the designated constraints aren't met.
type MembersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MembersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MembersMultiError) AllErrors() []error { return m }

// MembersValidationError is the validation error returned by Members.Validate
// if the designated constraints aren't met.
type MembersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MembersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MembersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MembersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MembersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MembersValidationError) ErrorName() string { return "MembersValidationError" }

// Error satisfies the builtin error interface
func (e MembersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMembers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MembersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MembersValidationError{}

// Validate checks the field values on GetVipsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetVipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetVipsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetVipsResponseMultiError, or nil if none found.
func (m *GetVipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetVipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetVipsResponseValidationError{
						field:  fmt.Sprintf("Response[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetVipsResponseValidationError{
						field:  fmt.Sprintf("Response[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetVipsResponseValidationError{
					field:  fmt.Sprintf("Response[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetVipsResponseMultiError(errors)
	}

	return nil
}

// GetVipsResponseMultiError is an error wrapping multiple validation errors
// returned by GetVipsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetVipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetVipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetVipsResponseMultiError) AllErrors() []error { return m }

// GetVipsResponseValidationError is the validation error returned by
// GetVipsResponse.Validate if the designated constraints aren't met.
type GetVipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetVipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetVipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetVipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetVipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetVipsResponseValidationError) ErrorName() string { return "GetVipsResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetVipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetVipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetVipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetVipsResponseValidationError{}

// Validate checks the field values on VipId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VipId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VipId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VipIdMultiError, or nil if none found.
func (m *VipId) ValidateAll() error {
	return m.validate(true)
}

func (m *VipId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Clusteruuid

	// no validation rules for Vipid

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return VipIdMultiError(errors)
	}

	return nil
}

// VipIdMultiError is an error wrapping multiple validation errors returned by
// VipId.ValidateAll() if the designated constraints aren't met.
type VipIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VipIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VipIdMultiError) AllErrors() []error { return m }

// VipIdValidationError is the validation error returned by VipId.Validate if
// the designated constraints aren't met.
type VipIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VipIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VipIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VipIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VipIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VipIdValidationError) ErrorName() string { return "VipIdValidationError" }

// Error satisfies the builtin error interface
func (e VipIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVipId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VipIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VipIdValidationError{}

// Validate checks the field values on ClusterStorageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterStorageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterStorageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterStorageRequestMultiError, or nil if none found.
func (m *ClusterStorageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterStorageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Clusteruuid

	// no validation rules for Enablestorage

	// no validation rules for Storagesize

	if len(errors) > 0 {
		return ClusterStorageRequestMultiError(errors)
	}

	return nil
}

// ClusterStorageRequestMultiError is an error wrapping multiple validation
// errors returned by ClusterStorageRequest.ValidateAll() if the designated
// constraints aren't met.
type ClusterStorageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterStorageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterStorageRequestMultiError) AllErrors() []error { return m }

// ClusterStorageRequestValidationError is the validation error returned by
// ClusterStorageRequest.Validate if the designated constraints aren't met.
type ClusterStorageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterStorageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterStorageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterStorageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterStorageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterStorageRequestValidationError) ErrorName() string {
	return "ClusterStorageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterStorageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterStorageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterStorageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterStorageRequestValidationError{}

// Validate checks the field values on ClusterStorageUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClusterStorageUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterStorageUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterStorageUpdateRequestMultiError, or nil if none found.
func (m *ClusterStorageUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterStorageUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Clusteruuid

	// no validation rules for Storagesize

	if len(errors) > 0 {
		return ClusterStorageUpdateRequestMultiError(errors)
	}

	return nil
}

// ClusterStorageUpdateRequestMultiError is an error wrapping multiple
// validation errors returned by ClusterStorageUpdateRequest.ValidateAll() if
// the designated constraints aren't met.
type ClusterStorageUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterStorageUpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterStorageUpdateRequestMultiError) AllErrors() []error { return m }

// ClusterStorageUpdateRequestValidationError is the validation error returned
// by ClusterStorageUpdateRequest.Validate if the designated constraints
// aren't met.
type ClusterStorageUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterStorageUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterStorageUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterStorageUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterStorageUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterStorageUpdateRequestValidationError) ErrorName() string {
	return "ClusterStorageUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClusterStorageUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterStorageUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterStorageUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterStorageUpdateRequestValidationError{}

// Validate checks the field values on WekaStorageStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WekaStorageStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WekaStorageStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WekaStorageStatusMultiError, or nil if none found.
func (m *WekaStorageStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *WekaStorageStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	// no validation rules for Status

	// no validation rules for CustomStatus

	// no validation rules for Message

	if len(errors) > 0 {
		return WekaStorageStatusMultiError(errors)
	}

	return nil
}

// WekaStorageStatusMultiError is an error wrapping multiple validation errors
// returned by WekaStorageStatus.ValidateAll() if the designated constraints
// aren't met.
type WekaStorageStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WekaStorageStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WekaStorageStatusMultiError) AllErrors() []error { return m }

// WekaStorageStatusValidationError is the validation error returned by
// WekaStorageStatus.Validate if the designated constraints aren't met.
type WekaStorageStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WekaStorageStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WekaStorageStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WekaStorageStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WekaStorageStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WekaStorageStatusValidationError) ErrorName() string {
	return "WekaStorageStatusValidationError"
}

// Error satisfies the builtin error interface
func (e WekaStorageStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWekaStorageStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WekaStorageStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WekaStorageStatusValidationError{}

// Validate checks the field values on FirewallRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FirewallRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirewallRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FirewallRuleResponseMultiError, or nil if none found.
func (m *FirewallRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FirewallRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	// no validation rules for Destinationip

	// no validation rules for Port

	// no validation rules for Vipid

	// no validation rules for Vipname

	// no validation rules for Viptype

	// no validation rules for Internalport

	if len(errors) > 0 {
		return FirewallRuleResponseMultiError(errors)
	}

	return nil
}

// FirewallRuleResponseMultiError is an error wrapping multiple validation
// errors returned by FirewallRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type FirewallRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirewallRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirewallRuleResponseMultiError) AllErrors() []error { return m }

// FirewallRuleResponseValidationError is the validation error returned by
// FirewallRuleResponse.Validate if the designated constraints aren't met.
type FirewallRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirewallRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirewallRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirewallRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirewallRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirewallRuleResponseValidationError) ErrorName() string {
	return "FirewallRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FirewallRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirewallRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirewallRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirewallRuleResponseValidationError{}

// Validate checks the field values on GetFirewallRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFirewallRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFirewallRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFirewallRuleRequestMultiError, or nil if none found.
func (m *GetFirewallRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFirewallRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Clusteruuid

	if len(errors) > 0 {
		return GetFirewallRuleRequestMultiError(errors)
	}

	return nil
}

// GetFirewallRuleRequestMultiError is an error wrapping multiple validation
// errors returned by GetFirewallRuleRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFirewallRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFirewallRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFirewallRuleRequestMultiError) AllErrors() []error { return m }

// GetFirewallRuleRequestValidationError is the validation error returned by
// GetFirewallRuleRequest.Validate if the designated constraints aren't met.
type GetFirewallRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFirewallRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFirewallRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFirewallRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFirewallRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFirewallRuleRequestValidationError) ErrorName() string {
	return "GetFirewallRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFirewallRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFirewallRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFirewallRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFirewallRuleRequestValidationError{}

// Validate checks the field values on GetFirewallRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFirewallRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFirewallRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFirewallRuleResponseMultiError, or nil if none found.
func (m *GetFirewallRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFirewallRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGetfirewallresponse() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFirewallRuleResponseValidationError{
						field:  fmt.Sprintf("Getfirewallresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFirewallRuleResponseValidationError{
						field:  fmt.Sprintf("Getfirewallresponse[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFirewallRuleResponseValidationError{
					field:  fmt.Sprintf("Getfirewallresponse[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetFirewallRuleResponseMultiError(errors)
	}

	return nil
}

// GetFirewallRuleResponseMultiError is an error wrapping multiple validation
// errors returned by GetFirewallRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFirewallRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFirewallRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFirewallRuleResponseMultiError) AllErrors() []error { return m }

// GetFirewallRuleResponseValidationError is the validation error returned by
// GetFirewallRuleResponse.Validate if the designated constraints aren't met.
type GetFirewallRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFirewallRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFirewallRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFirewallRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFirewallRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFirewallRuleResponseValidationError) ErrorName() string {
	return "GetFirewallRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFirewallRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFirewallRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFirewallRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFirewallRuleResponseValidationError{}

// Validate checks the field values on UpdateFirewallRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateFirewallRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFirewallRuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateFirewallRuleRequestMultiError, or nil if none found.
func (m *UpdateFirewallRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFirewallRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Clusteruuid

	// no validation rules for Internalip

	// no validation rules for Port

	if len(errors) > 0 {
		return UpdateFirewallRuleRequestMultiError(errors)
	}

	return nil
}

// UpdateFirewallRuleRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateFirewallRuleRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateFirewallRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFirewallRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFirewallRuleRequestMultiError) AllErrors() []error { return m }

// UpdateFirewallRuleRequestValidationError is the validation error returned by
// UpdateFirewallRuleRequest.Validate if the designated constraints aren't met.
type UpdateFirewallRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFirewallRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFirewallRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFirewallRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFirewallRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFirewallRuleRequestValidationError) ErrorName() string {
	return "UpdateFirewallRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFirewallRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFirewallRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFirewallRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFirewallRuleRequestValidationError{}

// Validate checks the field values on DeleteFirewallRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFirewallRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFirewallRuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFirewallRuleRequestMultiError, or nil if none found.
func (m *DeleteFirewallRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFirewallRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Clusteruuid

	// no validation rules for Vipid

	if len(errors) > 0 {
		return DeleteFirewallRuleRequestMultiError(errors)
	}

	return nil
}

// DeleteFirewallRuleRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteFirewallRuleRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteFirewallRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFirewallRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFirewallRuleRequestMultiError) AllErrors() []error { return m }

// DeleteFirewallRuleRequestValidationError is the validation error returned by
// DeleteFirewallRuleRequest.Validate if the designated constraints aren't met.
type DeleteFirewallRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFirewallRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFirewallRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFirewallRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFirewallRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFirewallRuleRequestValidationError) ErrorName() string {
	return "DeleteFirewallRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFirewallRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFirewallRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFirewallRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFirewallRuleRequestValidationError{}

// Validate checks the field values on SuperComputeClusterCreateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SuperComputeClusterCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuperComputeClusterCreateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SuperComputeClusterCreateRequestMultiError, or nil if none found.
func (m *SuperComputeClusterCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SuperComputeClusterCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if all {
		switch v := interface{}(m.GetClusterspec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuperComputeClusterCreateRequestValidationError{
					field:  "Clusterspec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuperComputeClusterCreateRequestValidationError{
					field:  "Clusterspec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterspec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuperComputeClusterCreateRequestValidationError{
				field:  "Clusterspec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNodegroupspec() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SuperComputeClusterCreateRequestValidationError{
						field:  fmt.Sprintf("Nodegroupspec[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SuperComputeClusterCreateRequestValidationError{
						field:  fmt.Sprintf("Nodegroupspec[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SuperComputeClusterCreateRequestValidationError{
					field:  fmt.Sprintf("Nodegroupspec[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStoragespec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SuperComputeClusterCreateRequestValidationError{
					field:  "Storagespec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SuperComputeClusterCreateRequestValidationError{
					field:  "Storagespec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStoragespec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SuperComputeClusterCreateRequestValidationError{
				field:  "Storagespec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Clustertype

	// no validation rules for InstanceType

	if len(errors) > 0 {
		return SuperComputeClusterCreateRequestMultiError(errors)
	}

	return nil
}

// SuperComputeClusterCreateRequestMultiError is an error wrapping multiple
// validation errors returned by
// SuperComputeClusterCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type SuperComputeClusterCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuperComputeClusterCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuperComputeClusterCreateRequestMultiError) AllErrors() []error { return m }

// SuperComputeClusterCreateRequestValidationError is the validation error
// returned by SuperComputeClusterCreateRequest.Validate if the designated
// constraints aren't met.
type SuperComputeClusterCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuperComputeClusterCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuperComputeClusterCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuperComputeClusterCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuperComputeClusterCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuperComputeClusterCreateRequestValidationError) ErrorName() string {
	return "SuperComputeClusterCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SuperComputeClusterCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuperComputeClusterCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuperComputeClusterCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuperComputeClusterCreateRequestValidationError{}

// Validate checks the field values on StorageSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageSpecMultiError, or
// nil if none found.
func (m *StorageSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Storagesize

	// no validation rules for Enablestorage

	if len(errors) > 0 {
		return StorageSpecMultiError(errors)
	}

	return nil
}

// StorageSpecMultiError is an error wrapping multiple validation errors
// returned by StorageSpec.ValidateAll() if the designated constraints aren't met.
type StorageSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageSpecMultiError) AllErrors() []error { return m }

// StorageSpecValidationError is the validation error returned by
// StorageSpec.Validate if the designated constraints aren't met.
type StorageSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageSpecValidationError) ErrorName() string { return "StorageSpecValidationError" }

// Error satisfies the builtin error interface
func (e StorageSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageSpecValidationError{}

// Validate checks the field values on ClusterSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterSpecMultiError, or
// nil if none found.
func (m *ClusterSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 63 {
		err := ClusterSpecValidationError{
			field:  "Name",
			reason: "value length must be at most 63 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ClusterSpec_Name_Pattern.MatchString(m.GetName()) {
		err := ClusterSpecValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for K8Sversionname

	// no validation rules for Runtimename

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterSpecValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterSpecValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterSpecValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterSpecValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterSpecValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterSpecValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {

		if len(m.GetDescription()) > 253 {
			err := ClusterSpecValidationError{
				field:  "Description",
				reason: "value length must be at most 253 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ClusterSpec_Description_Pattern.MatchString(m.GetDescription()) {
			err := ClusterSpecValidationError{
				field:  "Description",
				reason: "value does not match regex pattern \"^[a-zA-Z0-9-_ ]*$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Network != nil {

		if all {
			switch v := interface{}(m.GetNetwork()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClusterSpecValidationError{
						field:  "Network",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClusterSpecValidationError{
						field:  "Network",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNetwork()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClusterSpecValidationError{
					field:  "Network",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClusterSpecMultiError(errors)
	}

	return nil
}

// ClusterSpecMultiError is an error wrapping multiple validation errors
// returned by ClusterSpec.ValidateAll() if the designated constraints aren't met.
type ClusterSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterSpecMultiError) AllErrors() []error { return m }

// ClusterSpecValidationError is the validation error returned by
// ClusterSpec.Validate if the designated constraints aren't met.
type ClusterSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterSpecValidationError) ErrorName() string { return "ClusterSpecValidationError" }

// Error satisfies the builtin error interface
func (e ClusterSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterSpecValidationError{}

var _ClusterSpec_Name_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ClusterSpec_Description_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_ ]*$")

// Validate checks the field values on NodegroupSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodegroupSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodegroupSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodegroupSpecMultiError, or
// nil if none found.
func (m *NodegroupSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *NodegroupSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 63 {
		err := NodegroupSpecValidationError{
			field:  "Name",
			reason: "value length must be at most 63 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NodegroupSpec_Name_Pattern.MatchString(m.GetName()) {
		err := NodegroupSpecValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstancetypeid()) < 1 {
		err := NodegroupSpecValidationError{
			field:  "Instancetypeid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetVnets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Vnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Vnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupSpecValidationError{
					field:  fmt.Sprintf("Vnets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if val := m.GetCount(); val < 0 || val > 10 {
		err := NodegroupSpecValidationError{
			field:  "Count",
			reason: "value must be inside range [0, 10]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSshkeyname() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Sshkeyname[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Sshkeyname[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupSpecValidationError{
					field:  fmt.Sprintf("Sshkeyname[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupSpecValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupSpecValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Nodegrouptype

	if m.Description != nil {

		if len(m.GetDescription()) > 253 {
			err := NodegroupSpecValidationError{
				field:  "Description",
				reason: "value length must be at most 253 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_NodegroupSpec_Description_Pattern.MatchString(m.GetDescription()) {
			err := NodegroupSpecValidationError{
				field:  "Description",
				reason: "value does not match regex pattern \"^[a-zA-Z0-9-_ ]*$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Upgradestrategy != nil {

		if all {
			switch v := interface{}(m.GetUpgradestrategy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodegroupSpecValidationError{
						field:  "Upgradestrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpgradestrategy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodegroupSpecValidationError{
					field:  "Upgradestrategy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Userdataurl != nil {

		if m.GetUserdataurl() != "" {

			if uri, err := url.Parse(m.GetUserdataurl()); err != nil {
				err = NodegroupSpecValidationError{
					field:  "Userdataurl",
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := NodegroupSpecValidationError{
					field:  "Userdataurl",
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return NodegroupSpecMultiError(errors)
	}

	return nil
}

// NodegroupSpecMultiError is an error wrapping multiple validation errors
// returned by NodegroupSpec.ValidateAll() if the designated constraints
// aren't met.
type NodegroupSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodegroupSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodegroupSpecMultiError) AllErrors() []error { return m }

// NodegroupSpecValidationError is the validation error returned by
// NodegroupSpec.Validate if the designated constraints aren't met.
type NodegroupSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodegroupSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodegroupSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodegroupSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodegroupSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodegroupSpecValidationError) ErrorName() string { return "NodegroupSpecValidationError" }

// Error satisfies the builtin error interface
func (e NodegroupSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodegroupSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodegroupSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodegroupSpecValidationError{}

var _NodegroupSpec_Name_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _NodegroupSpec_Description_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_ ]*$")
