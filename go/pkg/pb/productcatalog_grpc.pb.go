// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: productcatalog.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ProductVendorServiceClient is the client API for ProductVendorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductVendorServiceClient interface {
	Read(ctx context.Context, in *VendorFilter, opts ...grpc.CallOption) (*VendorResponse, error)
}

type productVendorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductVendorServiceClient(cc grpc.ClientConnInterface) ProductVendorServiceClient {
	return &productVendorServiceClient{cc}
}

func (c *productVendorServiceClient) Read(ctx context.Context, in *VendorFilter, opts ...grpc.CallOption) (*VendorResponse, error) {
	out := new(VendorResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductVendorService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductVendorServiceServer is the server API for ProductVendorService service.
// All implementations must embed UnimplementedProductVendorServiceServer
// for forward compatibility
type ProductVendorServiceServer interface {
	Read(context.Context, *VendorFilter) (*VendorResponse, error)
	mustEmbedUnimplementedProductVendorServiceServer()
}

// UnimplementedProductVendorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProductVendorServiceServer struct {
}

func (UnimplementedProductVendorServiceServer) Read(context.Context, *VendorFilter) (*VendorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedProductVendorServiceServer) mustEmbedUnimplementedProductVendorServiceServer() {}

// UnsafeProductVendorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductVendorServiceServer will
// result in compilation errors.
type UnsafeProductVendorServiceServer interface {
	mustEmbedUnimplementedProductVendorServiceServer()
}

func RegisterProductVendorServiceServer(s grpc.ServiceRegistrar, srv ProductVendorServiceServer) {
	s.RegisterService(&ProductVendorService_ServiceDesc, srv)
}

func _ProductVendorService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VendorFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductVendorServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductVendorService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductVendorServiceServer).Read(ctx, req.(*VendorFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductVendorService_ServiceDesc is the grpc.ServiceDesc for ProductVendorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductVendorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductVendorService",
	HandlerType: (*ProductVendorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _ProductVendorService_Read_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// ProductCatalogServiceClient is the client API for ProductCatalogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductCatalogServiceClient interface {
	// admin read call
	AdminRead(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductResponse, error)
	// user read call
	UserRead(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error)
	// external user read call
	UserReadExternal(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error)
	SetStatus(ctx context.Context, in *SetProductStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type productCatalogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductCatalogServiceClient(cc grpc.ClientConnInterface) ProductCatalogServiceClient {
	return &productCatalogServiceClient{cc}
}

func (c *productCatalogServiceClient) AdminRead(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductResponse, error) {
	out := new(ProductResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogService/AdminRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) UserRead(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error) {
	out := new(ProductResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogService/UserRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) UserReadExternal(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error) {
	out := new(ProductResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogService/UserReadExternal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) SetStatus(ctx context.Context, in *SetProductStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogService/SetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductCatalogServiceServer is the server API for ProductCatalogService service.
// All implementations must embed UnimplementedProductCatalogServiceServer
// for forward compatibility
type ProductCatalogServiceServer interface {
	// admin read call
	AdminRead(context.Context, *ProductFilter) (*ProductResponse, error)
	// user read call
	UserRead(context.Context, *ProductUserFilter) (*ProductResponse, error)
	// external user read call
	UserReadExternal(context.Context, *ProductUserFilter) (*ProductResponse, error)
	SetStatus(context.Context, *SetProductStatusRequest) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedProductCatalogServiceServer()
}

// UnimplementedProductCatalogServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProductCatalogServiceServer struct {
}

func (UnimplementedProductCatalogServiceServer) AdminRead(context.Context, *ProductFilter) (*ProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminRead not implemented")
}
func (UnimplementedProductCatalogServiceServer) UserRead(context.Context, *ProductUserFilter) (*ProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRead not implemented")
}
func (UnimplementedProductCatalogServiceServer) UserReadExternal(context.Context, *ProductUserFilter) (*ProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserReadExternal not implemented")
}
func (UnimplementedProductCatalogServiceServer) SetStatus(context.Context, *SetProductStatusRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStatus not implemented")
}
func (UnimplementedProductCatalogServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedProductCatalogServiceServer) mustEmbedUnimplementedProductCatalogServiceServer() {}

// UnsafeProductCatalogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductCatalogServiceServer will
// result in compilation errors.
type UnsafeProductCatalogServiceServer interface {
	mustEmbedUnimplementedProductCatalogServiceServer()
}

func RegisterProductCatalogServiceServer(s grpc.ServiceRegistrar, srv ProductCatalogServiceServer) {
	s.RegisterService(&ProductCatalogService_ServiceDesc, srv)
}

func _ProductCatalogService_AdminRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).AdminRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogService/AdminRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).AdminRead(ctx, req.(*ProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_UserRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).UserRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogService/UserRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).UserRead(ctx, req.(*ProductUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_UserReadExternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).UserReadExternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogService/UserReadExternal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).UserReadExternal(ctx, req.(*ProductUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_SetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProductStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).SetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogService/SetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).SetStatus(ctx, req.(*SetProductStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductCatalogService_ServiceDesc is the grpc.ServiceDesc for ProductCatalogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductCatalogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductCatalogService",
	HandlerType: (*ProductCatalogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AdminRead",
			Handler:    _ProductCatalogService_AdminRead_Handler,
		},
		{
			MethodName: "UserRead",
			Handler:    _ProductCatalogService_UserRead_Handler,
		},
		{
			MethodName: "UserReadExternal",
			Handler:    _ProductCatalogService_UserReadExternal_Handler,
		},
		{
			MethodName: "SetStatus",
			Handler:    _ProductCatalogService_SetStatus_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _ProductCatalogService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// ProductAccessServiceClient is the client API for ProductAccessService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductAccessServiceClient interface {
	ReadAccess(ctx context.Context, in *GetAccessRequest, opts ...grpc.CallOption) (*GetAccessResponse, error)
	AddAccess(ctx context.Context, in *ProductAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveAccess(ctx context.Context, in *DeleteAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CheckProductAccess(ctx context.Context, in *ProductAccessCheckRequest, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
}

type productAccessServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductAccessServiceClient(cc grpc.ClientConnInterface) ProductAccessServiceClient {
	return &productAccessServiceClient{cc}
}

func (c *productAccessServiceClient) ReadAccess(ctx context.Context, in *GetAccessRequest, opts ...grpc.CallOption) (*GetAccessResponse, error) {
	out := new(GetAccessResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductAccessService/ReadAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productAccessServiceClient) AddAccess(ctx context.Context, in *ProductAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductAccessService/AddAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productAccessServiceClient) RemoveAccess(ctx context.Context, in *DeleteAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductAccessService/RemoveAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productAccessServiceClient) CheckProductAccess(ctx context.Context, in *ProductAccessCheckRequest, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/proto.ProductAccessService/CheckProductAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductAccessServiceServer is the server API for ProductAccessService service.
// All implementations must embed UnimplementedProductAccessServiceServer
// for forward compatibility
type ProductAccessServiceServer interface {
	ReadAccess(context.Context, *GetAccessRequest) (*GetAccessResponse, error)
	AddAccess(context.Context, *ProductAccessRequest) (*emptypb.Empty, error)
	RemoveAccess(context.Context, *DeleteAccessRequest) (*emptypb.Empty, error)
	CheckProductAccess(context.Context, *ProductAccessCheckRequest) (*wrapperspb.BoolValue, error)
	mustEmbedUnimplementedProductAccessServiceServer()
}

// UnimplementedProductAccessServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProductAccessServiceServer struct {
}

func (UnimplementedProductAccessServiceServer) ReadAccess(context.Context, *GetAccessRequest) (*GetAccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAccess not implemented")
}
func (UnimplementedProductAccessServiceServer) AddAccess(context.Context, *ProductAccessRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAccess not implemented")
}
func (UnimplementedProductAccessServiceServer) RemoveAccess(context.Context, *DeleteAccessRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAccess not implemented")
}
func (UnimplementedProductAccessServiceServer) CheckProductAccess(context.Context, *ProductAccessCheckRequest) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckProductAccess not implemented")
}
func (UnimplementedProductAccessServiceServer) mustEmbedUnimplementedProductAccessServiceServer() {}

// UnsafeProductAccessServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductAccessServiceServer will
// result in compilation errors.
type UnsafeProductAccessServiceServer interface {
	mustEmbedUnimplementedProductAccessServiceServer()
}

func RegisterProductAccessServiceServer(s grpc.ServiceRegistrar, srv ProductAccessServiceServer) {
	s.RegisterService(&ProductAccessService_ServiceDesc, srv)
}

func _ProductAccessService_ReadAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductAccessServiceServer).ReadAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductAccessService/ReadAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductAccessServiceServer).ReadAccess(ctx, req.(*GetAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductAccessService_AddAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductAccessServiceServer).AddAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductAccessService/AddAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductAccessServiceServer).AddAccess(ctx, req.(*ProductAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductAccessService_RemoveAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductAccessServiceServer).RemoveAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductAccessService/RemoveAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductAccessServiceServer).RemoveAccess(ctx, req.(*DeleteAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductAccessService_CheckProductAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductAccessCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductAccessServiceServer).CheckProductAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductAccessService/CheckProductAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductAccessServiceServer).CheckProductAccess(ctx, req.(*ProductAccessCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductAccessService_ServiceDesc is the grpc.ServiceDesc for ProductAccessService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductAccessService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductAccessService",
	HandlerType: (*ProductAccessServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadAccess",
			Handler:    _ProductAccessService_ReadAccess_Handler,
		},
		{
			MethodName: "AddAccess",
			Handler:    _ProductAccessService_AddAccess_Handler,
		},
		{
			MethodName: "RemoveAccess",
			Handler:    _ProductAccessService_RemoveAccess_Handler,
		},
		{
			MethodName: "CheckProductAccess",
			Handler:    _ProductAccessService_CheckProductAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// RegionServiceClient is the client API for RegionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionServiceClient interface {
	Add(ctx context.Context, in *AddRegionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AdminRead(ctx context.Context, in *RegionFilter, opts ...grpc.CallOption) (*RegionResponse, error)
	UserRead(ctx context.Context, in *RegionUserFilter, opts ...grpc.CallOption) (*RegionUserResponse, error)
	Update(ctx context.Context, in *UpdateRegionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Delete(ctx context.Context, in *DeleteRegionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type regionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionServiceClient(cc grpc.ClientConnInterface) RegionServiceClient {
	return &regionServiceClient{cc}
}

func (c *regionServiceClient) Add(ctx context.Context, in *AddRegionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.RegionService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionServiceClient) AdminRead(ctx context.Context, in *RegionFilter, opts ...grpc.CallOption) (*RegionResponse, error) {
	out := new(RegionResponse)
	err := c.cc.Invoke(ctx, "/proto.RegionService/AdminRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionServiceClient) UserRead(ctx context.Context, in *RegionUserFilter, opts ...grpc.CallOption) (*RegionUserResponse, error) {
	out := new(RegionUserResponse)
	err := c.cc.Invoke(ctx, "/proto.RegionService/UserRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionServiceClient) Update(ctx context.Context, in *UpdateRegionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.RegionService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionServiceClient) Delete(ctx context.Context, in *DeleteRegionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.RegionService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionServiceServer is the server API for RegionService service.
// All implementations must embed UnimplementedRegionServiceServer
// for forward compatibility
type RegionServiceServer interface {
	Add(context.Context, *AddRegionRequest) (*emptypb.Empty, error)
	AdminRead(context.Context, *RegionFilter) (*RegionResponse, error)
	UserRead(context.Context, *RegionUserFilter) (*RegionUserResponse, error)
	Update(context.Context, *UpdateRegionRequest) (*emptypb.Empty, error)
	Delete(context.Context, *DeleteRegionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRegionServiceServer()
}

// UnimplementedRegionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRegionServiceServer struct {
}

func (UnimplementedRegionServiceServer) Add(context.Context, *AddRegionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedRegionServiceServer) AdminRead(context.Context, *RegionFilter) (*RegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminRead not implemented")
}
func (UnimplementedRegionServiceServer) UserRead(context.Context, *RegionUserFilter) (*RegionUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRead not implemented")
}
func (UnimplementedRegionServiceServer) Update(context.Context, *UpdateRegionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedRegionServiceServer) Delete(context.Context, *DeleteRegionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionServiceServer) mustEmbedUnimplementedRegionServiceServer() {}

// UnsafeRegionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionServiceServer will
// result in compilation errors.
type UnsafeRegionServiceServer interface {
	mustEmbedUnimplementedRegionServiceServer()
}

func RegisterRegionServiceServer(s grpc.ServiceRegistrar, srv RegionServiceServer) {
	s.RegisterService(&RegionService_ServiceDesc, srv)
}

func _RegionService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionServiceServer).Add(ctx, req.(*AddRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionService_AdminRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionServiceServer).AdminRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionService/AdminRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionServiceServer).AdminRead(ctx, req.(*RegionFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionService_UserRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionServiceServer).UserRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionService/UserRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionServiceServer).UserRead(ctx, req.(*RegionUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionServiceServer).Update(ctx, req.(*UpdateRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionServiceServer).Delete(ctx, req.(*DeleteRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionService_ServiceDesc is the grpc.ServiceDesc for RegionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.RegionService",
	HandlerType: (*RegionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _RegionService_Add_Handler,
		},
		{
			MethodName: "AdminRead",
			Handler:    _RegionService_AdminRead_Handler,
		},
		{
			MethodName: "UserRead",
			Handler:    _RegionService_UserRead_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegionService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// RegionAccessServiceClient is the client API for RegionAccessService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionAccessServiceClient interface {
	ReadAccess(ctx context.Context, in *GetRegionAccessRequest, opts ...grpc.CallOption) (*GetRegionAccessResponse, error)
	AddAccess(ctx context.Context, in *RegionAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveAccess(ctx context.Context, in *DeleteRegionAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CheckRegionAccess(ctx context.Context, in *RegionAccessCheckRequest, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
}

type regionAccessServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionAccessServiceClient(cc grpc.ClientConnInterface) RegionAccessServiceClient {
	return &regionAccessServiceClient{cc}
}

func (c *regionAccessServiceClient) ReadAccess(ctx context.Context, in *GetRegionAccessRequest, opts ...grpc.CallOption) (*GetRegionAccessResponse, error) {
	out := new(GetRegionAccessResponse)
	err := c.cc.Invoke(ctx, "/proto.RegionAccessService/ReadAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAccessServiceClient) AddAccess(ctx context.Context, in *RegionAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.RegionAccessService/AddAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAccessServiceClient) RemoveAccess(ctx context.Context, in *DeleteRegionAccessRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.RegionAccessService/RemoveAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAccessServiceClient) CheckRegionAccess(ctx context.Context, in *RegionAccessCheckRequest, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/proto.RegionAccessService/CheckRegionAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionAccessServiceServer is the server API for RegionAccessService service.
// All implementations must embed UnimplementedRegionAccessServiceServer
// for forward compatibility
type RegionAccessServiceServer interface {
	ReadAccess(context.Context, *GetRegionAccessRequest) (*GetRegionAccessResponse, error)
	AddAccess(context.Context, *RegionAccessRequest) (*emptypb.Empty, error)
	RemoveAccess(context.Context, *DeleteRegionAccessRequest) (*emptypb.Empty, error)
	CheckRegionAccess(context.Context, *RegionAccessCheckRequest) (*wrapperspb.BoolValue, error)
	mustEmbedUnimplementedRegionAccessServiceServer()
}

// UnimplementedRegionAccessServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRegionAccessServiceServer struct {
}

func (UnimplementedRegionAccessServiceServer) ReadAccess(context.Context, *GetRegionAccessRequest) (*GetRegionAccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAccess not implemented")
}
func (UnimplementedRegionAccessServiceServer) AddAccess(context.Context, *RegionAccessRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAccess not implemented")
}
func (UnimplementedRegionAccessServiceServer) RemoveAccess(context.Context, *DeleteRegionAccessRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAccess not implemented")
}
func (UnimplementedRegionAccessServiceServer) CheckRegionAccess(context.Context, *RegionAccessCheckRequest) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckRegionAccess not implemented")
}
func (UnimplementedRegionAccessServiceServer) mustEmbedUnimplementedRegionAccessServiceServer() {}

// UnsafeRegionAccessServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionAccessServiceServer will
// result in compilation errors.
type UnsafeRegionAccessServiceServer interface {
	mustEmbedUnimplementedRegionAccessServiceServer()
}

func RegisterRegionAccessServiceServer(s grpc.ServiceRegistrar, srv RegionAccessServiceServer) {
	s.RegisterService(&RegionAccessService_ServiceDesc, srv)
}

func _RegionAccessService_ReadAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAccessServiceServer).ReadAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionAccessService/ReadAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAccessServiceServer).ReadAccess(ctx, req.(*GetRegionAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAccessService_AddAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAccessServiceServer).AddAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionAccessService/AddAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAccessServiceServer).AddAccess(ctx, req.(*RegionAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAccessService_RemoveAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAccessServiceServer).RemoveAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionAccessService/RemoveAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAccessServiceServer).RemoveAccess(ctx, req.(*DeleteRegionAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAccessService_CheckRegionAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegionAccessCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAccessServiceServer).CheckRegionAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.RegionAccessService/CheckRegionAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAccessServiceServer).CheckRegionAccess(ctx, req.(*RegionAccessCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionAccessService_ServiceDesc is the grpc.ServiceDesc for RegionAccessService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionAccessService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.RegionAccessService",
	HandlerType: (*RegionAccessServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadAccess",
			Handler:    _RegionAccessService_ReadAccess_Handler,
		},
		{
			MethodName: "AddAccess",
			Handler:    _RegionAccessService_AddAccess_Handler,
		},
		{
			MethodName: "RemoveAccess",
			Handler:    _RegionAccessService_RemoveAccess_Handler,
		},
		{
			MethodName: "CheckRegionAccess",
			Handler:    _RegionAccessService_CheckRegionAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// ProductSyncServiceClient is the client API for ProductSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductSyncServiceClient interface {
	SearchStream(ctx context.Context, in *DefaultProductSearchRequest, opts ...grpc.CallOption) (ProductSyncService_SearchStreamClient, error)
	Put(ctx context.Context, in *DefaultProduct, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Delete(ctx context.Context, in *DefaultProductDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *DefaultProductGetRequest, opts ...grpc.CallOption) (*DefaultProduct, error)
}

type productSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductSyncServiceClient(cc grpc.ClientConnInterface) ProductSyncServiceClient {
	return &productSyncServiceClient{cc}
}

func (c *productSyncServiceClient) SearchStream(ctx context.Context, in *DefaultProductSearchRequest, opts ...grpc.CallOption) (ProductSyncService_SearchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ProductSyncService_ServiceDesc.Streams[0], "/proto.ProductSyncService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &productSyncServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ProductSyncService_SearchStreamClient interface {
	Recv() (*DefaultProduct, error)
	grpc.ClientStream
}

type productSyncServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *productSyncServiceSearchStreamClient) Recv() (*DefaultProduct, error) {
	m := new(DefaultProduct)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *productSyncServiceClient) Put(ctx context.Context, in *DefaultProduct, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductSyncService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSyncServiceClient) Delete(ctx context.Context, in *DefaultProductDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductSyncService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSyncServiceClient) Get(ctx context.Context, in *DefaultProductGetRequest, opts ...grpc.CallOption) (*DefaultProduct, error) {
	out := new(DefaultProduct)
	err := c.cc.Invoke(ctx, "/proto.ProductSyncService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductSyncServiceServer is the server API for ProductSyncService service.
// All implementations must embed UnimplementedProductSyncServiceServer
// for forward compatibility
type ProductSyncServiceServer interface {
	SearchStream(*DefaultProductSearchRequest, ProductSyncService_SearchStreamServer) error
	Put(context.Context, *DefaultProduct) (*emptypb.Empty, error)
	Delete(context.Context, *DefaultProductDeleteRequest) (*emptypb.Empty, error)
	Get(context.Context, *DefaultProductGetRequest) (*DefaultProduct, error)
	mustEmbedUnimplementedProductSyncServiceServer()
}

// UnimplementedProductSyncServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProductSyncServiceServer struct {
}

func (UnimplementedProductSyncServiceServer) SearchStream(*DefaultProductSearchRequest, ProductSyncService_SearchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedProductSyncServiceServer) Put(context.Context, *DefaultProduct) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedProductSyncServiceServer) Delete(context.Context, *DefaultProductDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedProductSyncServiceServer) Get(context.Context, *DefaultProductGetRequest) (*DefaultProduct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedProductSyncServiceServer) mustEmbedUnimplementedProductSyncServiceServer() {}

// UnsafeProductSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductSyncServiceServer will
// result in compilation errors.
type UnsafeProductSyncServiceServer interface {
	mustEmbedUnimplementedProductSyncServiceServer()
}

func RegisterProductSyncServiceServer(s grpc.ServiceRegistrar, srv ProductSyncServiceServer) {
	s.RegisterService(&ProductSyncService_ServiceDesc, srv)
}

func _ProductSyncService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DefaultProductSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProductSyncServiceServer).SearchStream(m, &productSyncServiceSearchStreamServer{stream})
}

type ProductSyncService_SearchStreamServer interface {
	Send(*DefaultProduct) error
	grpc.ServerStream
}

type productSyncServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *productSyncServiceSearchStreamServer) Send(m *DefaultProduct) error {
	return x.ServerStream.SendMsg(m)
}

func _ProductSyncService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultProduct)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSyncServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductSyncService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSyncServiceServer).Put(ctx, req.(*DefaultProduct))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSyncService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultProductDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSyncServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductSyncService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSyncServiceServer).Delete(ctx, req.(*DefaultProductDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSyncService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultProductGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSyncServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductSyncService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSyncServiceServer).Get(ctx, req.(*DefaultProductGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductSyncService_ServiceDesc is the grpc.ServiceDesc for ProductSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductSyncService",
	HandlerType: (*ProductSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _ProductSyncService_Put_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ProductSyncService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ProductSyncService_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _ProductSyncService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "productcatalog.proto",
}

// VendorSyncServiceClient is the client API for VendorSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VendorSyncServiceClient interface {
	SearchStream(ctx context.Context, in *DefaultVendorSearchRequest, opts ...grpc.CallOption) (VendorSyncService_SearchStreamClient, error)
	Put(ctx context.Context, in *DefaultVendor, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Delete(ctx context.Context, in *DefaultVendortDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *DefaultVendorGetRequest, opts ...grpc.CallOption) (*DefaultVendor, error)
}

type vendorSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVendorSyncServiceClient(cc grpc.ClientConnInterface) VendorSyncServiceClient {
	return &vendorSyncServiceClient{cc}
}

func (c *vendorSyncServiceClient) SearchStream(ctx context.Context, in *DefaultVendorSearchRequest, opts ...grpc.CallOption) (VendorSyncService_SearchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &VendorSyncService_ServiceDesc.Streams[0], "/proto.VendorSyncService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vendorSyncServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VendorSyncService_SearchStreamClient interface {
	Recv() (*DefaultVendor, error)
	grpc.ClientStream
}

type vendorSyncServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *vendorSyncServiceSearchStreamClient) Recv() (*DefaultVendor, error) {
	m := new(DefaultVendor)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vendorSyncServiceClient) Put(ctx context.Context, in *DefaultVendor, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VendorSyncService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vendorSyncServiceClient) Delete(ctx context.Context, in *DefaultVendortDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VendorSyncService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vendorSyncServiceClient) Get(ctx context.Context, in *DefaultVendorGetRequest, opts ...grpc.CallOption) (*DefaultVendor, error) {
	out := new(DefaultVendor)
	err := c.cc.Invoke(ctx, "/proto.VendorSyncService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VendorSyncServiceServer is the server API for VendorSyncService service.
// All implementations must embed UnimplementedVendorSyncServiceServer
// for forward compatibility
type VendorSyncServiceServer interface {
	SearchStream(*DefaultVendorSearchRequest, VendorSyncService_SearchStreamServer) error
	Put(context.Context, *DefaultVendor) (*emptypb.Empty, error)
	Delete(context.Context, *DefaultVendortDeleteRequest) (*emptypb.Empty, error)
	Get(context.Context, *DefaultVendorGetRequest) (*DefaultVendor, error)
	mustEmbedUnimplementedVendorSyncServiceServer()
}

// UnimplementedVendorSyncServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVendorSyncServiceServer struct {
}

func (UnimplementedVendorSyncServiceServer) SearchStream(*DefaultVendorSearchRequest, VendorSyncService_SearchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedVendorSyncServiceServer) Put(context.Context, *DefaultVendor) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedVendorSyncServiceServer) Delete(context.Context, *DefaultVendortDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedVendorSyncServiceServer) Get(context.Context, *DefaultVendorGetRequest) (*DefaultVendor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedVendorSyncServiceServer) mustEmbedUnimplementedVendorSyncServiceServer() {}

// UnsafeVendorSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VendorSyncServiceServer will
// result in compilation errors.
type UnsafeVendorSyncServiceServer interface {
	mustEmbedUnimplementedVendorSyncServiceServer()
}

func RegisterVendorSyncServiceServer(s grpc.ServiceRegistrar, srv VendorSyncServiceServer) {
	s.RegisterService(&VendorSyncService_ServiceDesc, srv)
}

func _VendorSyncService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DefaultVendorSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VendorSyncServiceServer).SearchStream(m, &vendorSyncServiceSearchStreamServer{stream})
}

type VendorSyncService_SearchStreamServer interface {
	Send(*DefaultVendor) error
	grpc.ServerStream
}

type vendorSyncServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *vendorSyncServiceSearchStreamServer) Send(m *DefaultVendor) error {
	return x.ServerStream.SendMsg(m)
}

func _VendorSyncService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultVendor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorSyncServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorSyncService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorSyncServiceServer).Put(ctx, req.(*DefaultVendor))
	}
	return interceptor(ctx, in, info, handler)
}

func _VendorSyncService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultVendortDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorSyncServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorSyncService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorSyncServiceServer).Delete(ctx, req.(*DefaultVendortDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VendorSyncService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefaultVendorGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorSyncServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorSyncService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorSyncServiceServer).Get(ctx, req.(*DefaultVendorGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VendorSyncService_ServiceDesc is the grpc.ServiceDesc for VendorSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VendorSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.VendorSyncService",
	HandlerType: (*VendorSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _VendorSyncService_Put_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VendorSyncService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _VendorSyncService_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _VendorSyncService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "productcatalog.proto",
}

// FamilyServiceClient is the client API for FamilyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FamilyServiceClient interface {
	Read(ctx context.Context, in *FamilyRequest, opts ...grpc.CallOption) (*FamilyResponse, error)
	// only used by admin
	Add(ctx context.Context, in *FamilyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *FamilyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetById(ctx context.Context, in *FamilyFilter, opts ...grpc.CallOption) (*FamilyResponse, error)
}

type familyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFamilyServiceClient(cc grpc.ClientConnInterface) FamilyServiceClient {
	return &familyServiceClient{cc}
}

func (c *familyServiceClient) Read(ctx context.Context, in *FamilyRequest, opts ...grpc.CallOption) (*FamilyResponse, error) {
	out := new(FamilyResponse)
	err := c.cc.Invoke(ctx, "/proto.FamilyService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) Add(ctx context.Context, in *FamilyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.FamilyService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) Update(ctx context.Context, in *FamilyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.FamilyService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) GetById(ctx context.Context, in *FamilyFilter, opts ...grpc.CallOption) (*FamilyResponse, error) {
	out := new(FamilyResponse)
	err := c.cc.Invoke(ctx, "/proto.FamilyService/GetById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FamilyServiceServer is the server API for FamilyService service.
// All implementations must embed UnimplementedFamilyServiceServer
// for forward compatibility
type FamilyServiceServer interface {
	Read(context.Context, *FamilyRequest) (*FamilyResponse, error)
	// only used by admin
	Add(context.Context, *FamilyRequest) (*emptypb.Empty, error)
	Update(context.Context, *FamilyRequest) (*emptypb.Empty, error)
	GetById(context.Context, *FamilyFilter) (*FamilyResponse, error)
	mustEmbedUnimplementedFamilyServiceServer()
}

// UnimplementedFamilyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFamilyServiceServer struct {
}

func (UnimplementedFamilyServiceServer) Read(context.Context, *FamilyRequest) (*FamilyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedFamilyServiceServer) Add(context.Context, *FamilyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedFamilyServiceServer) Update(context.Context, *FamilyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedFamilyServiceServer) GetById(context.Context, *FamilyFilter) (*FamilyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedFamilyServiceServer) mustEmbedUnimplementedFamilyServiceServer() {}

// UnsafeFamilyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FamilyServiceServer will
// result in compilation errors.
type UnsafeFamilyServiceServer interface {
	mustEmbedUnimplementedFamilyServiceServer()
}

func RegisterFamilyServiceServer(s grpc.ServiceRegistrar, srv FamilyServiceServer) {
	s.RegisterService(&FamilyService_ServiceDesc, srv)
}

func _FamilyService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FamilyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.FamilyService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).Read(ctx, req.(*FamilyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FamilyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.FamilyService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).Add(ctx, req.(*FamilyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FamilyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.FamilyService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).Update(ctx, req.(*FamilyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FamilyFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.FamilyService/GetById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).GetById(ctx, req.(*FamilyFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// FamilyService_ServiceDesc is the grpc.ServiceDesc for FamilyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FamilyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.FamilyService",
	HandlerType: (*FamilyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _FamilyService_Read_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _FamilyService_Add_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _FamilyService_Update_Handler,
		},
		{
			MethodName: "GetById",
			Handler:    _FamilyService_GetById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// VendorServiceClient is the client API for VendorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VendorServiceClient interface {
	// to be used by billing
	Read(ctx context.Context, in *VendorFilter, opts ...grpc.CallOption) (*VendorResponse, error)
	Add(ctx context.Context, in *VendorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Update(ctx context.Context, in *VendorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetById(ctx context.Context, in *VendorId, opts ...grpc.CallOption) (*VendorResponse, error)
}

type vendorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVendorServiceClient(cc grpc.ClientConnInterface) VendorServiceClient {
	return &vendorServiceClient{cc}
}

func (c *vendorServiceClient) Read(ctx context.Context, in *VendorFilter, opts ...grpc.CallOption) (*VendorResponse, error) {
	out := new(VendorResponse)
	err := c.cc.Invoke(ctx, "/proto.VendorService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vendorServiceClient) Add(ctx context.Context, in *VendorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VendorService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vendorServiceClient) Update(ctx context.Context, in *VendorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VendorService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vendorServiceClient) GetById(ctx context.Context, in *VendorId, opts ...grpc.CallOption) (*VendorResponse, error) {
	out := new(VendorResponse)
	err := c.cc.Invoke(ctx, "/proto.VendorService/GetById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VendorServiceServer is the server API for VendorService service.
// All implementations must embed UnimplementedVendorServiceServer
// for forward compatibility
type VendorServiceServer interface {
	// to be used by billing
	Read(context.Context, *VendorFilter) (*VendorResponse, error)
	Add(context.Context, *VendorRequest) (*emptypb.Empty, error)
	Update(context.Context, *VendorRequest) (*emptypb.Empty, error)
	GetById(context.Context, *VendorId) (*VendorResponse, error)
	mustEmbedUnimplementedVendorServiceServer()
}

// UnimplementedVendorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVendorServiceServer struct {
}

func (UnimplementedVendorServiceServer) Read(context.Context, *VendorFilter) (*VendorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedVendorServiceServer) Add(context.Context, *VendorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedVendorServiceServer) Update(context.Context, *VendorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedVendorServiceServer) GetById(context.Context, *VendorId) (*VendorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetById not implemented")
}
func (UnimplementedVendorServiceServer) mustEmbedUnimplementedVendorServiceServer() {}

// UnsafeVendorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VendorServiceServer will
// result in compilation errors.
type UnsafeVendorServiceServer interface {
	mustEmbedUnimplementedVendorServiceServer()
}

func RegisterVendorServiceServer(s grpc.ServiceRegistrar, srv VendorServiceServer) {
	s.RegisterService(&VendorService_ServiceDesc, srv)
}

func _VendorService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VendorFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorServiceServer).Read(ctx, req.(*VendorFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _VendorService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VendorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorServiceServer).Add(ctx, req.(*VendorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VendorService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VendorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorServiceServer).Update(ctx, req.(*VendorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VendorService_GetById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VendorId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VendorServiceServer).GetById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VendorService/GetById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VendorServiceServer).GetById(ctx, req.(*VendorId))
	}
	return interceptor(ctx, in, info, handler)
}

// VendorService_ServiceDesc is the grpc.ServiceDesc for VendorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VendorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.VendorService",
	HandlerType: (*VendorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _VendorService_Read_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _VendorService_Add_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _VendorService_Update_Handler,
		},
		{
			MethodName: "GetById",
			Handler:    _VendorService_GetById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// ProductCatalogServiceV2Client is the client API for ProductCatalogServiceV2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductCatalogServiceV2Client interface {
	// to be used by billing
	AdminRead(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductResponse, error)
	UserRead(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error)
	// external user read call
	UserReadExternal(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error)
	SetStatus(ctx context.Context, in *SetProductStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type productCatalogServiceV2Client struct {
	cc grpc.ClientConnInterface
}

func NewProductCatalogServiceV2Client(cc grpc.ClientConnInterface) ProductCatalogServiceV2Client {
	return &productCatalogServiceV2Client{cc}
}

func (c *productCatalogServiceV2Client) AdminRead(ctx context.Context, in *ProductFilter, opts ...grpc.CallOption) (*ProductResponse, error) {
	out := new(ProductResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogServiceV2/AdminRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceV2Client) UserRead(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error) {
	out := new(ProductResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogServiceV2/UserRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceV2Client) UserReadExternal(ctx context.Context, in *ProductUserFilter, opts ...grpc.CallOption) (*ProductResponse, error) {
	out := new(ProductResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogServiceV2/UserReadExternal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceV2Client) SetStatus(ctx context.Context, in *SetProductStatusRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogServiceV2/SetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCatalogServiceV2Client) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductCatalogServiceV2/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductCatalogServiceV2Server is the server API for ProductCatalogServiceV2 service.
// All implementations must embed UnimplementedProductCatalogServiceV2Server
// for forward compatibility
type ProductCatalogServiceV2Server interface {
	// to be used by billing
	AdminRead(context.Context, *ProductFilter) (*ProductResponse, error)
	UserRead(context.Context, *ProductUserFilter) (*ProductResponse, error)
	// external user read call
	UserReadExternal(context.Context, *ProductUserFilter) (*ProductResponse, error)
	SetStatus(context.Context, *SetProductStatusRequest) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedProductCatalogServiceV2Server()
}

// UnimplementedProductCatalogServiceV2Server must be embedded to have forward compatible implementations.
type UnimplementedProductCatalogServiceV2Server struct {
}

func (UnimplementedProductCatalogServiceV2Server) AdminRead(context.Context, *ProductFilter) (*ProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminRead not implemented")
}
func (UnimplementedProductCatalogServiceV2Server) UserRead(context.Context, *ProductUserFilter) (*ProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRead not implemented")
}
func (UnimplementedProductCatalogServiceV2Server) UserReadExternal(context.Context, *ProductUserFilter) (*ProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserReadExternal not implemented")
}
func (UnimplementedProductCatalogServiceV2Server) SetStatus(context.Context, *SetProductStatusRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStatus not implemented")
}
func (UnimplementedProductCatalogServiceV2Server) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedProductCatalogServiceV2Server) mustEmbedUnimplementedProductCatalogServiceV2Server() {
}

// UnsafeProductCatalogServiceV2Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductCatalogServiceV2Server will
// result in compilation errors.
type UnsafeProductCatalogServiceV2Server interface {
	mustEmbedUnimplementedProductCatalogServiceV2Server()
}

func RegisterProductCatalogServiceV2Server(s grpc.ServiceRegistrar, srv ProductCatalogServiceV2Server) {
	s.RegisterService(&ProductCatalogServiceV2_ServiceDesc, srv)
}

func _ProductCatalogServiceV2_AdminRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceV2Server).AdminRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogServiceV2/AdminRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceV2Server).AdminRead(ctx, req.(*ProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogServiceV2_UserRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceV2Server).UserRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogServiceV2/UserRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceV2Server).UserRead(ctx, req.(*ProductUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogServiceV2_UserReadExternal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductUserFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceV2Server).UserReadExternal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogServiceV2/UserReadExternal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceV2Server).UserReadExternal(ctx, req.(*ProductUserFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogServiceV2_SetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProductStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceV2Server).SetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogServiceV2/SetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceV2Server).SetStatus(ctx, req.(*SetProductStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCatalogServiceV2_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCatalogServiceV2Server).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductCatalogServiceV2/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCatalogServiceV2Server).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductCatalogServiceV2_ServiceDesc is the grpc.ServiceDesc for ProductCatalogServiceV2 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductCatalogServiceV2_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductCatalogServiceV2",
	HandlerType: (*ProductCatalogServiceV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AdminRead",
			Handler:    _ProductCatalogServiceV2_AdminRead_Handler,
		},
		{
			MethodName: "UserRead",
			Handler:    _ProductCatalogServiceV2_UserRead_Handler,
		},
		{
			MethodName: "UserReadExternal",
			Handler:    _ProductCatalogServiceV2_UserReadExternal_Handler,
		},
		{
			MethodName: "SetStatus",
			Handler:    _ProductCatalogServiceV2_SetStatus_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _ProductCatalogServiceV2_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// AccessServiceClient is the client API for AccessService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccessServiceClient interface {
	ReadAccess(ctx context.Context, in *GetAccessRequest, opts ...grpc.CallOption) (*GetAccessResponseV2, error)
	AddAccess(ctx context.Context, in *ProductAccessRequestV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveAccess(ctx context.Context, in *DeleteAccessRequestV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type accessServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccessServiceClient(cc grpc.ClientConnInterface) AccessServiceClient {
	return &accessServiceClient{cc}
}

func (c *accessServiceClient) ReadAccess(ctx context.Context, in *GetAccessRequest, opts ...grpc.CallOption) (*GetAccessResponseV2, error) {
	out := new(GetAccessResponseV2)
	err := c.cc.Invoke(ctx, "/proto.AccessService/ReadAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessServiceClient) AddAccess(ctx context.Context, in *ProductAccessRequestV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AccessService/AddAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessServiceClient) RemoveAccess(ctx context.Context, in *DeleteAccessRequestV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AccessService/RemoveAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessServiceServer is the server API for AccessService service.
// All implementations must embed UnimplementedAccessServiceServer
// for forward compatibility
type AccessServiceServer interface {
	ReadAccess(context.Context, *GetAccessRequest) (*GetAccessResponseV2, error)
	AddAccess(context.Context, *ProductAccessRequestV2) (*emptypb.Empty, error)
	RemoveAccess(context.Context, *DeleteAccessRequestV2) (*emptypb.Empty, error)
	mustEmbedUnimplementedAccessServiceServer()
}

// UnimplementedAccessServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAccessServiceServer struct {
}

func (UnimplementedAccessServiceServer) ReadAccess(context.Context, *GetAccessRequest) (*GetAccessResponseV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadAccess not implemented")
}
func (UnimplementedAccessServiceServer) AddAccess(context.Context, *ProductAccessRequestV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAccess not implemented")
}
func (UnimplementedAccessServiceServer) RemoveAccess(context.Context, *DeleteAccessRequestV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAccess not implemented")
}
func (UnimplementedAccessServiceServer) mustEmbedUnimplementedAccessServiceServer() {}

// UnsafeAccessServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccessServiceServer will
// result in compilation errors.
type UnsafeAccessServiceServer interface {
	mustEmbedUnimplementedAccessServiceServer()
}

func RegisterAccessServiceServer(s grpc.ServiceRegistrar, srv AccessServiceServer) {
	s.RegisterService(&AccessService_ServiceDesc, srv)
}

func _AccessService_ReadAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).ReadAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AccessService/ReadAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).ReadAccess(ctx, req.(*GetAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessService_AddAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductAccessRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).AddAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AccessService/AddAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).AddAccess(ctx, req.(*ProductAccessRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessService_RemoveAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccessRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).RemoveAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AccessService/RemoveAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).RemoveAccess(ctx, req.(*DeleteAccessRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

// AccessService_ServiceDesc is the grpc.ServiceDesc for AccessService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccessService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AccessService",
	HandlerType: (*AccessServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadAccess",
			Handler:    _AccessService_ReadAccess_Handler,
		},
		{
			MethodName: "AddAccess",
			Handler:    _AccessService_AddAccess_Handler,
		},
		{
			MethodName: "RemoveAccess",
			Handler:    _AccessService_RemoveAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// ProductChangeRequestServiceClient is the client API for ProductChangeRequestService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductChangeRequestServiceClient interface {
	AddProductDataInChangeRequest(ctx context.Context, in *ProposedData, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateProductDataInChangeRequest(ctx context.Context, in *ProposedData, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReviewProductChangeRequest(ctx context.Context, in *ReviewProductChangeRequestFilter, opts ...grpc.CallOption) (*emptypb.Empty, error)
	EnableProductInChangeRequest(ctx context.Context, in *EnableProductFilter, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReadProductChangeRequest(ctx context.Context, in *ProductChangeRequestFilter, opts ...grpc.CallOption) (*ProductChangeRequestResponseList, error)
}

type productChangeRequestServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductChangeRequestServiceClient(cc grpc.ClientConnInterface) ProductChangeRequestServiceClient {
	return &productChangeRequestServiceClient{cc}
}

func (c *productChangeRequestServiceClient) AddProductDataInChangeRequest(ctx context.Context, in *ProposedData, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductChangeRequestService/AddProductDataInChangeRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productChangeRequestServiceClient) UpdateProductDataInChangeRequest(ctx context.Context, in *ProposedData, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductChangeRequestService/UpdateProductDataInChangeRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productChangeRequestServiceClient) ReviewProductChangeRequest(ctx context.Context, in *ReviewProductChangeRequestFilter, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductChangeRequestService/ReviewProductChangeRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productChangeRequestServiceClient) EnableProductInChangeRequest(ctx context.Context, in *EnableProductFilter, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductChangeRequestService/EnableProductInChangeRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productChangeRequestServiceClient) ReadProductChangeRequest(ctx context.Context, in *ProductChangeRequestFilter, opts ...grpc.CallOption) (*ProductChangeRequestResponseList, error) {
	out := new(ProductChangeRequestResponseList)
	err := c.cc.Invoke(ctx, "/proto.ProductChangeRequestService/ReadProductChangeRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductChangeRequestServiceServer is the server API for ProductChangeRequestService service.
// All implementations must embed UnimplementedProductChangeRequestServiceServer
// for forward compatibility
type ProductChangeRequestServiceServer interface {
	AddProductDataInChangeRequest(context.Context, *ProposedData) (*emptypb.Empty, error)
	UpdateProductDataInChangeRequest(context.Context, *ProposedData) (*emptypb.Empty, error)
	ReviewProductChangeRequest(context.Context, *ReviewProductChangeRequestFilter) (*emptypb.Empty, error)
	EnableProductInChangeRequest(context.Context, *EnableProductFilter) (*emptypb.Empty, error)
	ReadProductChangeRequest(context.Context, *ProductChangeRequestFilter) (*ProductChangeRequestResponseList, error)
	mustEmbedUnimplementedProductChangeRequestServiceServer()
}

// UnimplementedProductChangeRequestServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProductChangeRequestServiceServer struct {
}

func (UnimplementedProductChangeRequestServiceServer) AddProductDataInChangeRequest(context.Context, *ProposedData) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProductDataInChangeRequest not implemented")
}
func (UnimplementedProductChangeRequestServiceServer) UpdateProductDataInChangeRequest(context.Context, *ProposedData) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductDataInChangeRequest not implemented")
}
func (UnimplementedProductChangeRequestServiceServer) ReviewProductChangeRequest(context.Context, *ReviewProductChangeRequestFilter) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReviewProductChangeRequest not implemented")
}
func (UnimplementedProductChangeRequestServiceServer) EnableProductInChangeRequest(context.Context, *EnableProductFilter) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableProductInChangeRequest not implemented")
}
func (UnimplementedProductChangeRequestServiceServer) ReadProductChangeRequest(context.Context, *ProductChangeRequestFilter) (*ProductChangeRequestResponseList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadProductChangeRequest not implemented")
}
func (UnimplementedProductChangeRequestServiceServer) mustEmbedUnimplementedProductChangeRequestServiceServer() {
}

// UnsafeProductChangeRequestServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductChangeRequestServiceServer will
// result in compilation errors.
type UnsafeProductChangeRequestServiceServer interface {
	mustEmbedUnimplementedProductChangeRequestServiceServer()
}

func RegisterProductChangeRequestServiceServer(s grpc.ServiceRegistrar, srv ProductChangeRequestServiceServer) {
	s.RegisterService(&ProductChangeRequestService_ServiceDesc, srv)
}

func _ProductChangeRequestService_AddProductDataInChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposedData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductChangeRequestServiceServer).AddProductDataInChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductChangeRequestService/AddProductDataInChangeRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductChangeRequestServiceServer).AddProductDataInChangeRequest(ctx, req.(*ProposedData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductChangeRequestService_UpdateProductDataInChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposedData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductChangeRequestServiceServer).UpdateProductDataInChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductChangeRequestService/UpdateProductDataInChangeRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductChangeRequestServiceServer).UpdateProductDataInChangeRequest(ctx, req.(*ProposedData))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductChangeRequestService_ReviewProductChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewProductChangeRequestFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductChangeRequestServiceServer).ReviewProductChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductChangeRequestService/ReviewProductChangeRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductChangeRequestServiceServer).ReviewProductChangeRequest(ctx, req.(*ReviewProductChangeRequestFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductChangeRequestService_EnableProductInChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableProductFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductChangeRequestServiceServer).EnableProductInChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductChangeRequestService/EnableProductInChangeRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductChangeRequestServiceServer).EnableProductInChangeRequest(ctx, req.(*EnableProductFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductChangeRequestService_ReadProductChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductChangeRequestFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductChangeRequestServiceServer).ReadProductChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductChangeRequestService/ReadProductChangeRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductChangeRequestServiceServer).ReadProductChangeRequest(ctx, req.(*ProductChangeRequestFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductChangeRequestService_ServiceDesc is the grpc.ServiceDesc for ProductChangeRequestService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductChangeRequestService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductChangeRequestService",
	HandlerType: (*ProductChangeRequestServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddProductDataInChangeRequest",
			Handler:    _ProductChangeRequestService_AddProductDataInChangeRequest_Handler,
		},
		{
			MethodName: "UpdateProductDataInChangeRequest",
			Handler:    _ProductChangeRequestService_UpdateProductDataInChangeRequest_Handler,
		},
		{
			MethodName: "ReviewProductChangeRequest",
			Handler:    _ProductChangeRequestService_ReviewProductChangeRequest_Handler,
		},
		{
			MethodName: "EnableProductInChangeRequest",
			Handler:    _ProductChangeRequestService_EnableProductInChangeRequest_Handler,
		},
		{
			MethodName: "ReadProductChangeRequest",
			Handler:    _ProductChangeRequestService_ReadProductChangeRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}

// ProductInterestServiceClient is the client API for ProductInterestService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductInterestServiceClient interface {
	Read(ctx context.Context, in *ProductInterestFilter, opts ...grpc.CallOption) (*ProductInterestResponse, error)
	// only used by admin
	Add(ctx context.Context, in *ProductInterestRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type productInterestServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductInterestServiceClient(cc grpc.ClientConnInterface) ProductInterestServiceClient {
	return &productInterestServiceClient{cc}
}

func (c *productInterestServiceClient) Read(ctx context.Context, in *ProductInterestFilter, opts ...grpc.CallOption) (*ProductInterestResponse, error) {
	out := new(ProductInterestResponse)
	err := c.cc.Invoke(ctx, "/proto.ProductInterestService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productInterestServiceClient) Add(ctx context.Context, in *ProductInterestRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.ProductInterestService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductInterestServiceServer is the server API for ProductInterestService service.
// All implementations must embed UnimplementedProductInterestServiceServer
// for forward compatibility
type ProductInterestServiceServer interface {
	Read(context.Context, *ProductInterestFilter) (*ProductInterestResponse, error)
	// only used by admin
	Add(context.Context, *ProductInterestRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedProductInterestServiceServer()
}

// UnimplementedProductInterestServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProductInterestServiceServer struct {
}

func (UnimplementedProductInterestServiceServer) Read(context.Context, *ProductInterestFilter) (*ProductInterestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedProductInterestServiceServer) Add(context.Context, *ProductInterestRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedProductInterestServiceServer) mustEmbedUnimplementedProductInterestServiceServer() {
}

// UnsafeProductInterestServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductInterestServiceServer will
// result in compilation errors.
type UnsafeProductInterestServiceServer interface {
	mustEmbedUnimplementedProductInterestServiceServer()
}

func RegisterProductInterestServiceServer(s grpc.ServiceRegistrar, srv ProductInterestServiceServer) {
	s.RegisterService(&ProductInterestService_ServiceDesc, srv)
}

func _ProductInterestService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductInterestFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductInterestServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductInterestService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductInterestServiceServer).Read(ctx, req.(*ProductInterestFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductInterestService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductInterestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductInterestServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProductInterestService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductInterestServiceServer).Add(ctx, req.(*ProductInterestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductInterestService_ServiceDesc is the grpc.ServiceDesc for ProductInterestService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductInterestService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProductInterestService",
	HandlerType: (*ProductInterestServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _ProductInterestService_Read_Handler,
		},
		{
			MethodName: "Add",
			Handler:    _ProductInterestService_Add_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "productcatalog.proto",
}
