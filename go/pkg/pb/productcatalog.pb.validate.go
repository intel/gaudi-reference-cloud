// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: productcatalog.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _productcatalog_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on VendorFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorFilterMultiError, or
// nil if none found.
func (m *VendorFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if len(errors) > 0 {
		return VendorFilterMultiError(errors)
	}

	return nil
}

// VendorFilterMultiError is an error wrapping multiple validation errors
// returned by VendorFilter.ValidateAll() if the designated constraints aren't met.
type VendorFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorFilterMultiError) AllErrors() []error { return m }

// VendorFilterValidationError is the validation error returned by
// VendorFilter.Validate if the designated constraints aren't met.
type VendorFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorFilterValidationError) ErrorName() string { return "VendorFilterValidationError" }

// Error satisfies the builtin error interface
func (e VendorFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorFilterValidationError{}

// Validate checks the field values on Vendor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Vendor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Vendor with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VendorMultiError, or nil if none found.
func (m *Vendor) ValidateAll() error {
	return m.validate(true)
}

func (m *Vendor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	for idx, item := range m.GetFamilies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VendorValidationError{
						field:  fmt.Sprintf("Families[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VendorValidationError{
						field:  fmt.Sprintf("Families[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VendorValidationError{
					field:  fmt.Sprintf("Families[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VendorMultiError(errors)
	}

	return nil
}

// VendorMultiError is an error wrapping multiple validation errors returned by
// Vendor.ValidateAll() if the designated constraints aren't met.
type VendorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorMultiError) AllErrors() []error { return m }

// VendorValidationError is the validation error returned by Vendor.Validate if
// the designated constraints aren't met.
type VendorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorValidationError) ErrorName() string { return "VendorValidationError" }

// Error satisfies the builtin error interface
func (e VendorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorValidationError{}

// Validate checks the field values on ProductFamily with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductFamily) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductFamily with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductFamilyMultiError, or
// nil if none found.
func (m *ProductFamily) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductFamily) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductFamilyValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductFamilyValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductFamilyValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if len(errors) > 0 {
		return ProductFamilyMultiError(errors)
	}

	return nil
}

// ProductFamilyMultiError is an error wrapping multiple validation errors
// returned by ProductFamily.ValidateAll() if the designated constraints
// aren't met.
type ProductFamilyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductFamilyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductFamilyMultiError) AllErrors() []error { return m }

// ProductFamilyValidationError is the validation error returned by
// ProductFamily.Validate if the designated constraints aren't met.
type ProductFamilyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductFamilyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductFamilyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductFamilyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductFamilyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductFamilyValidationError) ErrorName() string { return "ProductFamilyValidationError" }

// Error satisfies the builtin error interface
func (e ProductFamilyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductFamily.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductFamilyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductFamilyValidationError{}

// Validate checks the field values on ProductUserFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProductUserFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductUserFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductUserFilterMultiError, or nil if none found.
func (m *ProductUserFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductUserFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	if all {
		switch v := interface{}(m.GetProductFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductUserFilterValidationError{
					field:  "ProductFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductUserFilterValidationError{
					field:  "ProductFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductUserFilterValidationError{
				field:  "ProductFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductUserFilterMultiError(errors)
	}

	return nil
}

// ProductUserFilterMultiError is an error wrapping multiple validation errors
// returned by ProductUserFilter.ValidateAll() if the designated constraints
// aren't met.
type ProductUserFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductUserFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductUserFilterMultiError) AllErrors() []error { return m }

// ProductUserFilterValidationError is the validation error returned by
// ProductUserFilter.Validate if the designated constraints aren't met.
type ProductUserFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductUserFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductUserFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductUserFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductUserFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductUserFilterValidationError) ErrorName() string {
	return "ProductUserFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ProductUserFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductUserFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductUserFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductUserFilterValidationError{}

// Validate checks the field values on ProductFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductFilterMultiError, or
// nil if none found.
func (m *ProductFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Metadata

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.VendorId != nil {
		// no validation rules for VendorId
	}

	if m.FamilyId != nil {
		// no validation rules for FamilyId
	}

	if m.Eccn != nil {
		// no validation rules for Eccn
	}

	if m.Pcq != nil {
		// no validation rules for Pcq
	}

	if m.MatchExpr != nil {
		// no validation rules for MatchExpr
	}

	if m.AccountType != nil {
		// no validation rules for AccountType
	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if len(errors) > 0 {
		return ProductFilterMultiError(errors)
	}

	return nil
}

// ProductFilterMultiError is an error wrapping multiple validation errors
// returned by ProductFilter.ValidateAll() if the designated constraints
// aren't met.
type ProductFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductFilterMultiError) AllErrors() []error { return m }

// ProductFilterValidationError is the validation error returned by
// ProductFilter.Validate if the designated constraints aren't met.
type ProductFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductFilterValidationError) ErrorName() string { return "ProductFilterValidationError" }

// Error satisfies the builtin error interface
func (e ProductFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductFilterValidationError{}

// Validate checks the field values on Product with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Product) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Product with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProductMultiError, or nil if none found.
func (m *Product) ValidateAll() error {
	return m.validate(true)
}

func (m *Product) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VendorId

	// no validation rules for FamilyId

	// no validation rules for Description

	// no validation rules for Metadata

	// no validation rules for Eccn

	// no validation rules for Pcq

	// no validation rules for MatchExpr

	for idx, item := range m.GetRates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Rates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductValidationError{
						field:  fmt.Sprintf("Rates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductValidationError{
					field:  fmt.Sprintf("Rates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	// no validation rules for Access

	if len(errors) > 0 {
		return ProductMultiError(errors)
	}

	return nil
}

// ProductMultiError is an error wrapping multiple validation errors returned
// by Product.ValidateAll() if the designated constraints aren't met.
type ProductMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductMultiError) AllErrors() []error { return m }

// ProductValidationError is the validation error returned by Product.Validate
// if the designated constraints aren't met.
type ProductValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductValidationError) ErrorName() string { return "ProductValidationError" }

// Error satisfies the builtin error interface
func (e ProductValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProduct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductValidationError{}

// Validate checks the field values on Rate with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RateMultiError, or nil if none found.
func (m *Rate) ValidateAll() error {
	return m.validate(true)
}

func (m *Rate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountType

	// no validation rules for Unit

	// no validation rules for Rate

	// no validation rules for UsageExpr

	if len(errors) > 0 {
		return RateMultiError(errors)
	}

	return nil
}

// RateMultiError is an error wrapping multiple validation errors returned by
// Rate.ValidateAll() if the designated constraints aren't met.
type RateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateMultiError) AllErrors() []error { return m }

// RateValidationError is the validation error returned by Rate.Validate if the
// designated constraints aren't met.
type RateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateValidationError) ErrorName() string { return "RateValidationError" }

// Error satisfies the builtin error interface
func (e RateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateValidationError{}

// Validate checks the field values on ProductResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProductResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductResponseMultiError, or nil if none found.
func (m *ProductResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProducts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductResponseValidationError{
						field:  fmt.Sprintf("Products[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductResponseValidationError{
					field:  fmt.Sprintf("Products[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductResponseMultiError(errors)
	}

	return nil
}

// ProductResponseMultiError is an error wrapping multiple validation errors
// returned by ProductResponse.ValidateAll() if the designated constraints
// aren't met.
type ProductResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductResponseMultiError) AllErrors() []error { return m }

// ProductResponseValidationError is the validation error returned by
// ProductResponse.Validate if the designated constraints aren't met.
type ProductResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductResponseValidationError) ErrorName() string { return "ProductResponseValidationError" }

// Error satisfies the builtin error interface
func (e ProductResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductResponseValidationError{}

// Validate checks the field values on VendorResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorResponseMultiError,
// or nil if none found.
func (m *VendorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVendors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VendorResponseValidationError{
						field:  fmt.Sprintf("Vendors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VendorResponseValidationError{
						field:  fmt.Sprintf("Vendors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VendorResponseValidationError{
					field:  fmt.Sprintf("Vendors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VendorResponseMultiError(errors)
	}

	return nil
}

// VendorResponseMultiError is an error wrapping multiple validation errors
// returned by VendorResponse.ValidateAll() if the designated constraints
// aren't met.
type VendorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorResponseMultiError) AllErrors() []error { return m }

// VendorResponseValidationError is the validation error returned by
// VendorResponse.Validate if the designated constraints aren't met.
type VendorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorResponseValidationError) ErrorName() string { return "VendorResponseValidationError" }

// Error satisfies the builtin error interface
func (e VendorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorResponseValidationError{}

// Validate checks the field values on SetProductStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetProductStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetProductStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetProductStatusMultiError, or nil if none found.
func (m *SetProductStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *SetProductStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VendorId

	// no validation rules for FamilyId

	// no validation rules for ProductId

	// no validation rules for Status

	// no validation rules for Error

	if len(errors) > 0 {
		return SetProductStatusMultiError(errors)
	}

	return nil
}

// SetProductStatusMultiError is an error wrapping multiple validation errors
// returned by SetProductStatus.ValidateAll() if the designated constraints
// aren't met.
type SetProductStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetProductStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetProductStatusMultiError) AllErrors() []error { return m }

// SetProductStatusValidationError is the validation error returned by
// SetProductStatus.Validate if the designated constraints aren't met.
type SetProductStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetProductStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetProductStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetProductStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetProductStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetProductStatusValidationError) ErrorName() string { return "SetProductStatusValidationError" }

// Error satisfies the builtin error interface
func (e SetProductStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetProductStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetProductStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetProductStatusValidationError{}

// Validate checks the field values on SetProductStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetProductStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetProductStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetProductStatusRequestMultiError, or nil if none found.
func (m *SetProductStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetProductStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetProductStatusRequestValidationError{
						field:  fmt.Sprintf("Status[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetProductStatusRequestValidationError{
						field:  fmt.Sprintf("Status[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetProductStatusRequestValidationError{
					field:  fmt.Sprintf("Status[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetProductStatusRequestMultiError(errors)
	}

	return nil
}

// SetProductStatusRequestMultiError is an error wrapping multiple validation
// errors returned by SetProductStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type SetProductStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetProductStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetProductStatusRequestMultiError) AllErrors() []error { return m }

// SetProductStatusRequestValidationError is the validation error returned by
// SetProductStatusRequest.Validate if the designated constraints aren't met.
type SetProductStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetProductStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetProductStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetProductStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetProductStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetProductStatusRequestValidationError) ErrorName() string {
	return "SetProductStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetProductStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetProductStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetProductStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetProductStatusRequestValidationError{}

// Validate checks the field values on GetAccessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessRequestMultiError, or nil if none found.
func (m *GetAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.CloudaccountId != nil {
		// no validation rules for CloudaccountId
	}

	if len(errors) > 0 {
		return GetAccessRequestMultiError(errors)
	}

	return nil
}

// GetAccessRequestMultiError is an error wrapping multiple validation errors
// returned by GetAccessRequest.ValidateAll() if the designated constraints
// aren't met.
type GetAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessRequestMultiError) AllErrors() []error { return m }

// GetAccessRequestValidationError is the validation error returned by
// GetAccessRequest.Validate if the designated constraints aren't met.
type GetAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessRequestValidationError) ErrorName() string { return "GetAccessRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessRequestValidationError{}

// Validate checks the field values on GetAccessResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessResponseMultiError, or nil if none found.
func (m *GetAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAcl() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAccessResponseValidationError{
						field:  fmt.Sprintf("Acl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAccessResponseValidationError{
						field:  fmt.Sprintf("Acl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAccessResponseValidationError{
					field:  fmt.Sprintf("Acl[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAccessResponseMultiError(errors)
	}

	return nil
}

// GetAccessResponseMultiError is an error wrapping multiple validation errors
// returned by GetAccessResponse.ValidateAll() if the designated constraints
// aren't met.
type GetAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessResponseMultiError) AllErrors() []error { return m }

// GetAccessResponseValidationError is the validation error returned by
// GetAccessResponse.Validate if the designated constraints aren't met.
type GetAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessResponseValidationError) ErrorName() string {
	return "GetAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessResponseValidationError{}

// Validate checks the field values on ProductAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductAccessRequestMultiError, or nil if none found.
func (m *ProductAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for VendorId

	// no validation rules for FamilyId

	// no validation rules for ProductId

	// no validation rules for AdminName

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductAccessRequestValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductAccessRequestValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductAccessRequestValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductAccessRequestMultiError(errors)
	}

	return nil
}

// ProductAccessRequestMultiError is an error wrapping multiple validation
// errors returned by ProductAccessRequest.ValidateAll() if the designated
// constraints aren't met.
type ProductAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductAccessRequestMultiError) AllErrors() []error { return m }

// ProductAccessRequestValidationError is the validation error returned by
// ProductAccessRequest.Validate if the designated constraints aren't met.
type ProductAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductAccessRequestValidationError) ErrorName() string {
	return "ProductAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProductAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductAccessRequestValidationError{}

// Validate checks the field values on ProductAccessCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductAccessCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductAccessCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductAccessCheckRequestMultiError, or nil if none found.
func (m *ProductAccessCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductAccessCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for ProductId

	if len(errors) > 0 {
		return ProductAccessCheckRequestMultiError(errors)
	}

	return nil
}

// ProductAccessCheckRequestMultiError is an error wrapping multiple validation
// errors returned by ProductAccessCheckRequest.ValidateAll() if the
// designated constraints aren't met.
type ProductAccessCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductAccessCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductAccessCheckRequestMultiError) AllErrors() []error { return m }

// ProductAccessCheckRequestValidationError is the validation error returned by
// ProductAccessCheckRequest.Validate if the designated constraints aren't met.
type ProductAccessCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductAccessCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductAccessCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductAccessCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductAccessCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductAccessCheckRequestValidationError) ErrorName() string {
	return "ProductAccessCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProductAccessCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductAccessCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductAccessCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductAccessCheckRequestValidationError{}

// Validate checks the field values on DeleteAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAccessRequestMultiError, or nil if none found.
func (m *DeleteAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for VendorId

	// no validation rules for ProductId

	if len(errors) > 0 {
		return DeleteAccessRequestMultiError(errors)
	}

	return nil
}

// DeleteAccessRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteAccessRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAccessRequestMultiError) AllErrors() []error { return m }

// DeleteAccessRequestValidationError is the validation error returned by
// DeleteAccessRequest.Validate if the designated constraints aren't met.
type DeleteAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAccessRequestValidationError) ErrorName() string {
	return "DeleteAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAccessRequestValidationError{}

// Validate checks the field values on ProductAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductAccessResponseMultiError, or nil if none found.
func (m *ProductAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for VendorId

	// no validation rules for FamilyId

	// no validation rules for ProductId

	// no validation rules for AdminName

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductAccessResponseValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductAccessResponseValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductAccessResponseValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductAccessResponseMultiError(errors)
	}

	return nil
}

// ProductAccessResponseMultiError is an error wrapping multiple validation
// errors returned by ProductAccessResponse.ValidateAll() if the designated
// constraints aren't met.
type ProductAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductAccessResponseMultiError) AllErrors() []error { return m }

// ProductAccessResponseValidationError is the validation error returned by
// ProductAccessResponse.Validate if the designated constraints aren't met.
type ProductAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductAccessResponseValidationError) ErrorName() string {
	return "ProductAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProductAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductAccessResponseValidationError{}

// Validate checks the field values on AddRegionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddRegionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddRegionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddRegionRequestMultiError, or nil if none found.
func (m *AddRegionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddRegionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := AddRegionRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFriendlyName()); l < 1 || l > 255 {
		err := AddRegionRequestValidationError{
			field:  "FriendlyName",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _AddRegionRequest_Type_InLookup[m.GetType()]; !ok {
		err := AddRegionRequestValidationError{
			field:  "Type",
			reason: "value must be in list [open controlled]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSubnet()); l < 1 || l > 255 {
		err := AddRegionRequestValidationError{
			field:  "Subnet",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAvailabilityZone()); l < 1 || l > 255 {
		err := AddRegionRequestValidationError{
			field:  "AvailabilityZone",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPrefix() < 0 {
		err := AddRegionRequestValidationError{
			field:  "Prefix",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsDefault

	if !_AddRegionRequest_ApiDns_Pattern.MatchString(m.GetApiDns()) {
		err := AddRegionRequestValidationError{
			field:  "ApiDns",
			reason: "value does not match regex pattern \"^(https?:\\\\/\\\\/)([a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,}(:\\\\d+)?(\\\\/[a-zA-Z0-9-._~%!$&'()*+,;=:@/]+)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Vnet

	if len(errors) > 0 {
		return AddRegionRequestMultiError(errors)
	}

	return nil
}

// AddRegionRequestMultiError is an error wrapping multiple validation errors
// returned by AddRegionRequest.ValidateAll() if the designated constraints
// aren't met.
type AddRegionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddRegionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddRegionRequestMultiError) AllErrors() []error { return m }

// AddRegionRequestValidationError is the validation error returned by
// AddRegionRequest.Validate if the designated constraints aren't met.
type AddRegionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddRegionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddRegionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddRegionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddRegionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddRegionRequestValidationError) ErrorName() string { return "AddRegionRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddRegionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddRegionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddRegionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddRegionRequestValidationError{}

var _AddRegionRequest_Type_InLookup = map[string]struct{}{
	"open":       {},
	"controlled": {},
}

var _AddRegionRequest_ApiDns_Pattern = regexp.MustCompile("^(https?:\\/\\/)([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}(:\\d+)?(\\/[a-zA-Z0-9-._~%!$&'()*+,;=:@/]+)+$")

// Validate checks the field values on RegionUserFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegionUserFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionUserFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegionUserFilterMultiError, or nil if none found.
func (m *RegionUserFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionUserFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	if all {
		switch v := interface{}(m.GetRegionFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegionUserFilterValidationError{
					field:  "RegionFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegionUserFilterValidationError{
					field:  "RegionFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegionFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegionUserFilterValidationError{
				field:  "RegionFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegionUserFilterMultiError(errors)
	}

	return nil
}

// RegionUserFilterMultiError is an error wrapping multiple validation errors
// returned by RegionUserFilter.ValidateAll() if the designated constraints
// aren't met.
type RegionUserFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionUserFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionUserFilterMultiError) AllErrors() []error { return m }

// RegionUserFilterValidationError is the validation error returned by
// RegionUserFilter.Validate if the designated constraints aren't met.
type RegionUserFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionUserFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionUserFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionUserFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionUserFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionUserFilterValidationError) ErrorName() string { return "RegionUserFilterValidationError" }

// Error satisfies the builtin error interface
func (e RegionUserFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionUserFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionUserFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionUserFilterValidationError{}

// Validate checks the field values on RegionFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionFilterMultiError, or
// nil if none found.
func (m *RegionFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.FriendlyName != nil {
		// no validation rules for FriendlyName
	}

	if m.Type != nil {

		if utf8.RuneCountInString(m.GetType()) < 1 {
			err := RegionFilterValidationError{
				field:  "Type",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_RegionFilter_Type_Pattern.MatchString(m.GetType()) {
			err := RegionFilterValidationError{
				field:  "Type",
				reason: "value does not match regex pattern \"^(open|controlled)$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Subnet != nil {
		// no validation rules for Subnet
	}

	if m.AvailabilityZone != nil {
		// no validation rules for AvailabilityZone
	}

	if m.Prefix != nil {
		// no validation rules for Prefix
	}

	if m.IsDefault != nil {
		// no validation rules for IsDefault
	}

	if m.ApiDns != nil {
		// no validation rules for ApiDns
	}

	if m.Vnet != nil {
		// no validation rules for Vnet
	}

	if m.AdminName != nil {
		// no validation rules for AdminName
	}

	if len(errors) > 0 {
		return RegionFilterMultiError(errors)
	}

	return nil
}

// RegionFilterMultiError is an error wrapping multiple validation errors
// returned by RegionFilter.ValidateAll() if the designated constraints aren't met.
type RegionFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionFilterMultiError) AllErrors() []error { return m }

// RegionFilterValidationError is the validation error returned by
// RegionFilter.Validate if the designated constraints aren't met.
type RegionFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionFilterValidationError) ErrorName() string { return "RegionFilterValidationError" }

// Error satisfies the builtin error interface
func (e RegionFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionFilterValidationError{}

var _RegionFilter_Type_Pattern = regexp.MustCompile("^(open|controlled)$")

// Validate checks the field values on Region with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Region) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Region with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RegionMultiError, or nil if none found.
func (m *Region) ValidateAll() error {
	return m.validate(true)
}

func (m *Region) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for FriendlyName

	// no validation rules for Type

	// no validation rules for Subnet

	// no validation rules for AvailabilityZone

	// no validation rules for Prefix

	// no validation rules for IsDefault

	// no validation rules for ApiDns

	// no validation rules for Vnet

	// no validation rules for AdminName

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegionMultiError(errors)
	}

	return nil
}

// RegionMultiError is an error wrapping multiple validation errors returned by
// Region.ValidateAll() if the designated constraints aren't met.
type RegionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionMultiError) AllErrors() []error { return m }

// RegionValidationError is the validation error returned by Region.Validate if
// the designated constraints aren't met.
type RegionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionValidationError) ErrorName() string { return "RegionValidationError" }

// Error satisfies the builtin error interface
func (e RegionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionValidationError{}

// Validate checks the field values on RegionUser with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionUser with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionUserMultiError, or
// nil if none found.
func (m *RegionUser) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for FriendlyName

	// no validation rules for Type

	// no validation rules for Subnet

	// no validation rules for AvailabilityZone

	// no validation rules for Prefix

	// no validation rules for IsDefault

	// no validation rules for ApiDns

	// no validation rules for Vnet

	if len(errors) > 0 {
		return RegionUserMultiError(errors)
	}

	return nil
}

// RegionUserMultiError is an error wrapping multiple validation errors
// returned by RegionUser.ValidateAll() if the designated constraints aren't met.
type RegionUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionUserMultiError) AllErrors() []error { return m }

// RegionUserValidationError is the validation error returned by
// RegionUser.Validate if the designated constraints aren't met.
type RegionUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionUserValidationError) ErrorName() string { return "RegionUserValidationError" }

// Error satisfies the builtin error interface
func (e RegionUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionUserValidationError{}

// Validate checks the field values on RegionResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegionResponseMultiError,
// or nil if none found.
func (m *RegionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRegions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegionResponseValidationError{
						field:  fmt.Sprintf("Regions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegionResponseValidationError{
						field:  fmt.Sprintf("Regions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegionResponseValidationError{
					field:  fmt.Sprintf("Regions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegionResponseMultiError(errors)
	}

	return nil
}

// RegionResponseMultiError is an error wrapping multiple validation errors
// returned by RegionResponse.ValidateAll() if the designated constraints
// aren't met.
type RegionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionResponseMultiError) AllErrors() []error { return m }

// RegionResponseValidationError is the validation error returned by
// RegionResponse.Validate if the designated constraints aren't met.
type RegionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionResponseValidationError) ErrorName() string { return "RegionResponseValidationError" }

// Error satisfies the builtin error interface
func (e RegionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionResponseValidationError{}

// Validate checks the field values on RegionUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegionUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegionUserResponseMultiError, or nil if none found.
func (m *RegionUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRegions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegionUserResponseValidationError{
						field:  fmt.Sprintf("Regions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegionUserResponseValidationError{
						field:  fmt.Sprintf("Regions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegionUserResponseValidationError{
					field:  fmt.Sprintf("Regions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegionUserResponseMultiError(errors)
	}

	return nil
}

// RegionUserResponseMultiError is an error wrapping multiple validation errors
// returned by RegionUserResponse.ValidateAll() if the designated constraints
// aren't met.
type RegionUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionUserResponseMultiError) AllErrors() []error { return m }

// RegionUserResponseValidationError is the validation error returned by
// RegionUserResponse.Validate if the designated constraints aren't met.
type RegionUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionUserResponseValidationError) ErrorName() string {
	return "RegionUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegionUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionUserResponseValidationError{}

// Validate checks the field values on UpdateRegionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateRegionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRegionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateRegionRequestMultiError, or nil if none found.
func (m *UpdateRegionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRegionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
		err := UpdateRegionRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.FriendlyName != nil {

		if l := utf8.RuneCountInString(m.GetFriendlyName()); l < 1 || l > 255 {
			err := UpdateRegionRequestValidationError{
				field:  "FriendlyName",
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Type != nil {

		if _, ok := _UpdateRegionRequest_Type_InLookup[m.GetType()]; !ok {
			err := UpdateRegionRequestValidationError{
				field:  "Type",
				reason: "value must be in list [open controlled]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Subnet != nil {

		if l := utf8.RuneCountInString(m.GetSubnet()); l < 1 || l > 255 {
			err := UpdateRegionRequestValidationError{
				field:  "Subnet",
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.AvailabilityZone != nil {

		if l := utf8.RuneCountInString(m.GetAvailabilityZone()); l < 1 || l > 255 {
			err := UpdateRegionRequestValidationError{
				field:  "AvailabilityZone",
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Prefix != nil {

		if m.GetPrefix() < 0 {
			err := UpdateRegionRequestValidationError{
				field:  "Prefix",
				reason: "value must be greater than or equal to 0",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.IsDefault != nil {
		// no validation rules for IsDefault
	}

	if m.ApiDns != nil {

		if !_UpdateRegionRequest_ApiDns_Pattern.MatchString(m.GetApiDns()) {
			err := UpdateRegionRequestValidationError{
				field:  "ApiDns",
				reason: "value does not match regex pattern \"^(https?:\\\\/\\\\/)([a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,}(:\\\\d+)?(\\\\/[a-zA-Z0-9-._~%!$&'()*+,;=:@/]+)+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Vnet != nil {
		// no validation rules for Vnet
	}

	if len(errors) > 0 {
		return UpdateRegionRequestMultiError(errors)
	}

	return nil
}

// UpdateRegionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateRegionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateRegionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRegionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRegionRequestMultiError) AllErrors() []error { return m }

// UpdateRegionRequestValidationError is the validation error returned by
// UpdateRegionRequest.Validate if the designated constraints aren't met.
type UpdateRegionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRegionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRegionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRegionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRegionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRegionRequestValidationError) ErrorName() string {
	return "UpdateRegionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRegionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRegionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRegionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRegionRequestValidationError{}

var _UpdateRegionRequest_Type_InLookup = map[string]struct{}{
	"open":       {},
	"controlled": {},
}

var _UpdateRegionRequest_ApiDns_Pattern = regexp.MustCompile("^(https?:\\/\\/)([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}(:\\d+)?(\\/[a-zA-Z0-9-._~%!$&'()*+,;=:@/]+)+$")

// Validate checks the field values on DeleteRegionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRegionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRegionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRegionRequestMultiError, or nil if none found.
func (m *DeleteRegionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRegionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DeleteRegionRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteRegionRequest_Name_Pattern.MatchString(m.GetName()) {
		err := DeleteRegionRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9]+([-.][a-z0-9]+)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRegionRequestMultiError(errors)
	}

	return nil
}

// DeleteRegionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteRegionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteRegionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRegionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRegionRequestMultiError) AllErrors() []error { return m }

// DeleteRegionRequestValidationError is the validation error returned by
// DeleteRegionRequest.Validate if the designated constraints aren't met.
type DeleteRegionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRegionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRegionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRegionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRegionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRegionRequestValidationError) ErrorName() string {
	return "DeleteRegionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRegionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRegionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRegionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRegionRequestValidationError{}

var _DeleteRegionRequest_Name_Pattern = regexp.MustCompile("^[a-z0-9]+([-.][a-z0-9]+)*$")

// Validate checks the field values on GetRegionAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRegionAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRegionAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRegionAccessRequestMultiError, or nil if none found.
func (m *GetRegionAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRegionAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.CloudaccountId != nil {
		// no validation rules for CloudaccountId
	}

	if m.RegionAccessType != nil {
		// no validation rules for RegionAccessType
	}

	if len(errors) > 0 {
		return GetRegionAccessRequestMultiError(errors)
	}

	return nil
}

// GetRegionAccessRequestMultiError is an error wrapping multiple validation
// errors returned by GetRegionAccessRequest.ValidateAll() if the designated
// constraints aren't met.
type GetRegionAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRegionAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRegionAccessRequestMultiError) AllErrors() []error { return m }

// GetRegionAccessRequestValidationError is the validation error returned by
// GetRegionAccessRequest.Validate if the designated constraints aren't met.
type GetRegionAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRegionAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRegionAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRegionAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRegionAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRegionAccessRequestValidationError) ErrorName() string {
	return "GetRegionAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRegionAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRegionAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRegionAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRegionAccessRequestValidationError{}

// Validate checks the field values on GetRegionAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRegionAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRegionAccessResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRegionAccessResponseMultiError, or nil if none found.
func (m *GetRegionAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRegionAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAcl() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetRegionAccessResponseValidationError{
						field:  fmt.Sprintf("Acl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetRegionAccessResponseValidationError{
						field:  fmt.Sprintf("Acl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetRegionAccessResponseValidationError{
					field:  fmt.Sprintf("Acl[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetRegionAccessResponseMultiError(errors)
	}

	return nil
}

// GetRegionAccessResponseMultiError is an error wrapping multiple validation
// errors returned by GetRegionAccessResponse.ValidateAll() if the designated
// constraints aren't met.
type GetRegionAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRegionAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRegionAccessResponseMultiError) AllErrors() []error { return m }

// GetRegionAccessResponseValidationError is the validation error returned by
// GetRegionAccessResponse.Validate if the designated constraints aren't met.
type GetRegionAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRegionAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRegionAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRegionAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRegionAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRegionAccessResponseValidationError) ErrorName() string {
	return "GetRegionAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRegionAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRegionAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRegionAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRegionAccessResponseValidationError{}

// Validate checks the field values on RegionAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegionAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegionAccessRequestMultiError, or nil if none found.
func (m *RegionAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for RegionName

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegionAccessRequestValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegionAccessRequestValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegionAccessRequestValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegionAccessRequestMultiError(errors)
	}

	return nil
}

// RegionAccessRequestMultiError is an error wrapping multiple validation
// errors returned by RegionAccessRequest.ValidateAll() if the designated
// constraints aren't met.
type RegionAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionAccessRequestMultiError) AllErrors() []error { return m }

// RegionAccessRequestValidationError is the validation error returned by
// RegionAccessRequest.Validate if the designated constraints aren't met.
type RegionAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionAccessRequestValidationError) ErrorName() string {
	return "RegionAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegionAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionAccessRequestValidationError{}

// Validate checks the field values on RegionAccessCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegionAccessCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionAccessCheckRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegionAccessCheckRequestMultiError, or nil if none found.
func (m *RegionAccessCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionAccessCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for RegionName

	if len(errors) > 0 {
		return RegionAccessCheckRequestMultiError(errors)
	}

	return nil
}

// RegionAccessCheckRequestMultiError is an error wrapping multiple validation
// errors returned by RegionAccessCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type RegionAccessCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionAccessCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionAccessCheckRequestMultiError) AllErrors() []error { return m }

// RegionAccessCheckRequestValidationError is the validation error returned by
// RegionAccessCheckRequest.Validate if the designated constraints aren't met.
type RegionAccessCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionAccessCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionAccessCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionAccessCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionAccessCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionAccessCheckRequestValidationError) ErrorName() string {
	return "RegionAccessCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegionAccessCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionAccessCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionAccessCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionAccessCheckRequestValidationError{}

// Validate checks the field values on DeleteRegionAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRegionAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRegionAccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRegionAccessRequestMultiError, or nil if none found.
func (m *DeleteRegionAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRegionAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for RegionName

	if len(errors) > 0 {
		return DeleteRegionAccessRequestMultiError(errors)
	}

	return nil
}

// DeleteRegionAccessRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteRegionAccessRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteRegionAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRegionAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRegionAccessRequestMultiError) AllErrors() []error { return m }

// DeleteRegionAccessRequestValidationError is the validation error returned by
// DeleteRegionAccessRequest.Validate if the designated constraints aren't met.
type DeleteRegionAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRegionAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRegionAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRegionAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRegionAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRegionAccessRequestValidationError) ErrorName() string {
	return "DeleteRegionAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRegionAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRegionAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRegionAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRegionAccessRequestValidationError{}

// Validate checks the field values on RegionAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegionAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegionAccessResponseMultiError, or nil if none found.
func (m *RegionAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for RegionName

	// no validation rules for AdminName

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegionAccessResponseValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegionAccessResponseValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegionAccessResponseValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegionAccessResponseMultiError(errors)
	}

	return nil
}

// RegionAccessResponseMultiError is an error wrapping multiple validation
// errors returned by RegionAccessResponse.ValidateAll() if the designated
// constraints aren't met.
type RegionAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionAccessResponseMultiError) AllErrors() []error { return m }

// RegionAccessResponseValidationError is the validation error returned by
// RegionAccessResponse.Validate if the designated constraints aren't met.
type RegionAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionAccessResponseValidationError) ErrorName() string {
	return "RegionAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegionAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionAccessResponseValidationError{}

// Validate checks the field values on DefaultRegionSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DefaultRegionSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultRegionSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultRegionSpecMultiError, or nil if none found.
func (m *DefaultRegionSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultRegionSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for FriendlyName

	// no validation rules for Type

	// no validation rules for Subnet

	// no validation rules for AvailabilityZone

	// no validation rules for Prefix

	// no validation rules for IsDefault

	// no validation rules for ApiDns

	// no validation rules for Environment

	if len(errors) > 0 {
		return DefaultRegionSpecMultiError(errors)
	}

	return nil
}

// DefaultRegionSpecMultiError is an error wrapping multiple validation errors
// returned by DefaultRegionSpec.ValidateAll() if the designated constraints
// aren't met.
type DefaultRegionSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultRegionSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultRegionSpecMultiError) AllErrors() []error { return m }

// DefaultRegionSpecValidationError is the validation error returned by
// DefaultRegionSpec.Validate if the designated constraints aren't met.
type DefaultRegionSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultRegionSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultRegionSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultRegionSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultRegionSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultRegionSpecValidationError) ErrorName() string {
	return "DefaultRegionSpecValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultRegionSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultRegionSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultRegionSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultRegionSpecValidationError{}

// Validate checks the field values on DefaultProduct with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DefaultProduct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultProduct with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefaultProductMultiError,
// or nil if none found.
func (m *DefaultProduct) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultProduct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	if m.GetMetadata() == nil {
		err := DefaultProductValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefaultProductValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefaultProductValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefaultProductValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSpec() == nil {
		err := DefaultProductValidationError{
			field:  "Spec",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefaultProductValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefaultProductValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefaultProductValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DefaultProductMultiError(errors)
	}

	return nil
}

// DefaultProductMultiError is an error wrapping multiple validation errors
// returned by DefaultProduct.ValidateAll() if the designated constraints
// aren't met.
type DefaultProductMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultProductMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultProductMultiError) AllErrors() []error { return m }

// DefaultProductValidationError is the validation error returned by
// DefaultProduct.Validate if the designated constraints aren't met.
type DefaultProductValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultProductValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultProductValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultProductValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultProductValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultProductValidationError) ErrorName() string { return "DefaultProductValidationError" }

// Error satisfies the builtin error interface
func (e DefaultProductValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultProduct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultProductValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultProductValidationError{}

// Validate checks the field values on ProductSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductSpecMultiError, or
// nil if none found.
func (m *ProductSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ProductSpecValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProductSpec_Id_Pattern.MatchString(m.GetId()) {
		err := ProductSpecValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[0-9a-zA-Z]{8}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductSpecValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductSpecValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductSpecValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetVendorId()) < 1 {
		err := ProductSpecValidationError{
			field:  "VendorId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetVendorId()); err != nil {
		err = ProductSpecValidationError{
			field:  "VendorId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFamilyId()) < 1 {
		err := ProductSpecValidationError{
			field:  "FamilyId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFamilyId()); err != nil {
		err = ProductSpecValidationError{
			field:  "FamilyId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDescription()); l < 1 || l > 100 {
		err := ProductSpecValidationError{
			field:  "Description",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProductSpec_Description_Pattern.MatchString(m.GetDescription()) {
		err := ProductSpecValidationError{
			field:  "Description",
			reason: "value does not match regex pattern \"^[\\\\w\\\\s\\\\pP\\\\pS]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMetadata()) < 1 {
		err := ProductSpecValidationError{
			field:  "Metadata",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductSpecValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductSpecValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductSpecValidationError{
					field:  fmt.Sprintf("Metadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Eccn

	// no validation rules for Pcq

	if utf8.RuneCountInString(m.GetMatchExpr()) < 1 {
		err := ProductSpecValidationError{
			field:  "MatchExpr",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRates()) < 4 {
		err := ProductSpecValidationError{
			field:  "Rates",
			reason: "value must contain at least 4 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductSpecValidationError{
						field:  fmt.Sprintf("Rates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductSpecValidationError{
						field:  fmt.Sprintf("Rates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductSpecValidationError{
					field:  fmt.Sprintf("Rates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	// no validation rules for Access

	if len(errors) > 0 {
		return ProductSpecMultiError(errors)
	}

	return nil
}

func (m *ProductSpec) _validateUuid(uuid string) error {
	if matched := _productcatalog_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ProductSpecMultiError is an error wrapping multiple validation errors
// returned by ProductSpec.ValidateAll() if the designated constraints aren't met.
type ProductSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductSpecMultiError) AllErrors() []error { return m }

// ProductSpecValidationError is the validation error returned by
// ProductSpec.Validate if the designated constraints aren't met.
type ProductSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductSpecValidationError) ErrorName() string { return "ProductSpecValidationError" }

// Error satisfies the builtin error interface
func (e ProductSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductSpecValidationError{}

var _ProductSpec_Id_Pattern = regexp.MustCompile("^[0-9a-zA-Z]{8}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{4}-[0-9a-zA-Z]{12}$")

var _ProductSpec_Description_Pattern = regexp.MustCompile("^[\\w\\s\\pP\\pS]+$")

// Validate checks the field values on DefaultRate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DefaultRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultRate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefaultRateMultiError, or
// nil if none found.
func (m *DefaultRate) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAccountType()) < 1 {
		err := DefaultRateValidationError{
			field:  "AccountType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DefaultRate_AccountType_Pattern.MatchString(m.GetAccountType()) {
		err := DefaultRateValidationError{
			field:  "AccountType",
			reason: "value does not match regex pattern \"^(standard|premium|enterprise|intel)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUnit()) < 1 {
		err := DefaultRateValidationError{
			field:  "Unit",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DefaultRate_Unit_Pattern.MatchString(m.GetUnit()) {
		err := DefaultRateValidationError{
			field:  "Unit",
			reason: "value does not match regex pattern \"^(dollarsPerMinute|dollarsPerTBPerHour|dollarsPerInference|dollarsPerMillionTokens)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRate()) < 1 {
		err := DefaultRateValidationError{
			field:  "Rate",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DefaultRate_Rate_Pattern.MatchString(m.GetRate()) {
		err := DefaultRateValidationError{
			field:  "Rate",
			reason: "value does not match regex pattern \"^[0-9]+(\\\\.[0-9]+)?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUsageExpr()) < 1 {
		err := DefaultRateValidationError{
			field:  "UsageExpr",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DefaultRate_UsageExpr_Pattern.MatchString(m.GetUsageExpr()) {
		err := DefaultRateValidationError{
			field:  "UsageExpr",
			reason: "value does not match regex pattern \"^(time – previous\\\\.time)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DefaultRateMultiError(errors)
	}

	return nil
}

// DefaultRateMultiError is an error wrapping multiple validation errors
// returned by DefaultRate.ValidateAll() if the designated constraints aren't met.
type DefaultRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultRateMultiError) AllErrors() []error { return m }

// DefaultRateValidationError is the validation error returned by
// DefaultRate.Validate if the designated constraints aren't met.
type DefaultRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultRateValidationError) ErrorName() string { return "DefaultRateValidationError" }

// Error satisfies the builtin error interface
func (e DefaultRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultRateValidationError{}

var _DefaultRate_AccountType_Pattern = regexp.MustCompile("^(standard|premium|enterprise|intel)$")

var _DefaultRate_Unit_Pattern = regexp.MustCompile("^(dollarsPerMinute|dollarsPerTBPerHour|dollarsPerInference|dollarsPerMillionTokens)$")

var _DefaultRate_Rate_Pattern = regexp.MustCompile("^[0-9]+(\\.[0-9]+)?$")

var _DefaultRate_UsageExpr_Pattern = regexp.MustCompile("^(time – previous\\.time)$")

// Validate checks the field values on KeyValue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KeyValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KeyValue with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KeyValueMultiError, or nil
// if none found.
func (m *KeyValue) ValidateAll() error {
	return m.validate(true)
}

func (m *KeyValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 1 {
		err := KeyValueValidationError{
			field:  "Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Value

	if len(errors) > 0 {
		return KeyValueMultiError(errors)
	}

	return nil
}

// KeyValueMultiError is an error wrapping multiple validation errors returned
// by KeyValue.ValidateAll() if the designated constraints aren't met.
type KeyValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyValueMultiError) AllErrors() []error { return m }

// KeyValueValidationError is the validation error returned by
// KeyValue.Validate if the designated constraints aren't met.
type KeyValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValueValidationError) ErrorName() string { return "KeyValueValidationError" }

// Error satisfies the builtin error interface
func (e KeyValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKeyValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValueValidationError{}

// Validate checks the field values on DefaultProductDeleteRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultProductDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultProductDeleteRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultProductDeleteRequestMultiError, or nil if none found.
func (m *DefaultProductDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultProductDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DefaultProductDeleteRequestMultiError(errors)
	}

	return nil
}

// DefaultProductDeleteRequestMultiError is an error wrapping multiple
// validation errors returned by DefaultProductDeleteRequest.ValidateAll() if
// the designated constraints aren't met.
type DefaultProductDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultProductDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultProductDeleteRequestMultiError) AllErrors() []error { return m }

// DefaultProductDeleteRequestValidationError is the validation error returned
// by DefaultProductDeleteRequest.Validate if the designated constraints
// aren't met.
type DefaultProductDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultProductDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultProductDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultProductDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultProductDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultProductDeleteRequestValidationError) ErrorName() string {
	return "DefaultProductDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultProductDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultProductDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultProductDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultProductDeleteRequestValidationError{}

// Validate checks the field values on DefaultProductSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultProductSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultProductSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultProductSearchRequestMultiError, or nil if none found.
func (m *DefaultProductSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultProductSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DefaultProductSearchRequestMultiError(errors)
	}

	return nil
}

// DefaultProductSearchRequestMultiError is an error wrapping multiple
// validation errors returned by DefaultProductSearchRequest.ValidateAll() if
// the designated constraints aren't met.
type DefaultProductSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultProductSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultProductSearchRequestMultiError) AllErrors() []error { return m }

// DefaultProductSearchRequestValidationError is the validation error returned
// by DefaultProductSearchRequest.Validate if the designated constraints
// aren't met.
type DefaultProductSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultProductSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultProductSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultProductSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultProductSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultProductSearchRequestValidationError) ErrorName() string {
	return "DefaultProductSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultProductSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultProductSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultProductSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultProductSearchRequestValidationError{}

// Validate checks the field values on DefaultProductGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultProductGetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultProductGetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultProductGetRequestMultiError, or nil if none found.
func (m *DefaultProductGetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultProductGetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DefaultProductGetRequestMultiError(errors)
	}

	return nil
}

// DefaultProductGetRequestMultiError is an error wrapping multiple validation
// errors returned by DefaultProductGetRequest.ValidateAll() if the designated
// constraints aren't met.
type DefaultProductGetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultProductGetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultProductGetRequestMultiError) AllErrors() []error { return m }

// DefaultProductGetRequestValidationError is the validation error returned by
// DefaultProductGetRequest.Validate if the designated constraints aren't met.
type DefaultProductGetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultProductGetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultProductGetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultProductGetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultProductGetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultProductGetRequestValidationError) ErrorName() string {
	return "DefaultProductGetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultProductGetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultProductGetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultProductGetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultProductGetRequestValidationError{}

// Validate checks the field values on DefaultVendor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DefaultVendor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultVendor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefaultVendorMultiError, or
// nil if none found.
func (m *DefaultVendor) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultVendor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefaultVendorValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefaultVendorValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefaultVendorValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefaultVendorValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefaultVendorValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefaultVendorValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DefaultVendorMultiError(errors)
	}

	return nil
}

// DefaultVendorMultiError is an error wrapping multiple validation errors
// returned by DefaultVendor.ValidateAll() if the designated constraints
// aren't met.
type DefaultVendorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultVendorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultVendorMultiError) AllErrors() []error { return m }

// DefaultVendorValidationError is the validation error returned by
// DefaultVendor.Validate if the designated constraints aren't met.
type DefaultVendorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultVendorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultVendorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultVendorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultVendorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultVendorValidationError) ErrorName() string { return "DefaultVendorValidationError" }

// Error satisfies the builtin error interface
func (e DefaultVendorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultVendor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultVendorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultVendorValidationError{}

// Validate checks the field values on VendorSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorSpecMultiError, or
// nil if none found.
func (m *VendorSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	for idx, item := range m.GetFamilies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VendorSpecValidationError{
						field:  fmt.Sprintf("Families[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VendorSpecValidationError{
						field:  fmt.Sprintf("Families[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VendorSpecValidationError{
					field:  fmt.Sprintf("Families[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VendorSpecMultiError(errors)
	}

	return nil
}

// VendorSpecMultiError is an error wrapping multiple validation errors
// returned by VendorSpec.ValidateAll() if the designated constraints aren't met.
type VendorSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorSpecMultiError) AllErrors() []error { return m }

// VendorSpecValidationError is the validation error returned by
// VendorSpec.Validate if the designated constraints aren't met.
type VendorSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorSpecValidationError) ErrorName() string { return "VendorSpecValidationError" }

// Error satisfies the builtin error interface
func (e VendorSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorSpecValidationError{}

// Validate checks the field values on DefaultFamily with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DefaultFamily) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultFamily with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefaultFamilyMultiError, or
// nil if none found.
func (m *DefaultFamily) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultFamily) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	// no validation rules for Description

	if len(errors) > 0 {
		return DefaultFamilyMultiError(errors)
	}

	return nil
}

// DefaultFamilyMultiError is an error wrapping multiple validation errors
// returned by DefaultFamily.ValidateAll() if the designated constraints
// aren't met.
type DefaultFamilyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultFamilyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultFamilyMultiError) AllErrors() []error { return m }

// DefaultFamilyValidationError is the validation error returned by
// DefaultFamily.Validate if the designated constraints aren't met.
type DefaultFamilyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultFamilyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultFamilyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultFamilyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultFamilyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultFamilyValidationError) ErrorName() string { return "DefaultFamilyValidationError" }

// Error satisfies the builtin error interface
func (e DefaultFamilyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultFamily.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultFamilyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultFamilyValidationError{}

// Validate checks the field values on DefaultVendortDeleteRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultVendortDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultVendortDeleteRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultVendortDeleteRequestMultiError, or nil if none found.
func (m *DefaultVendortDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultVendortDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DefaultVendortDeleteRequestMultiError(errors)
	}

	return nil
}

// DefaultVendortDeleteRequestMultiError is an error wrapping multiple
// validation errors returned by DefaultVendortDeleteRequest.ValidateAll() if
// the designated constraints aren't met.
type DefaultVendortDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultVendortDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultVendortDeleteRequestMultiError) AllErrors() []error { return m }

// DefaultVendortDeleteRequestValidationError is the validation error returned
// by DefaultVendortDeleteRequest.Validate if the designated constraints
// aren't met.
type DefaultVendortDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultVendortDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultVendortDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultVendortDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultVendortDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultVendortDeleteRequestValidationError) ErrorName() string {
	return "DefaultVendortDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultVendortDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultVendortDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultVendortDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultVendortDeleteRequestValidationError{}

// Validate checks the field values on DefaultVendorSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultVendorSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultVendorSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultVendorSearchRequestMultiError, or nil if none found.
func (m *DefaultVendorSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultVendorSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DefaultVendorSearchRequestMultiError(errors)
	}

	return nil
}

// DefaultVendorSearchRequestMultiError is an error wrapping multiple
// validation errors returned by DefaultVendorSearchRequest.ValidateAll() if
// the designated constraints aren't met.
type DefaultVendorSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultVendorSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultVendorSearchRequestMultiError) AllErrors() []error { return m }

// DefaultVendorSearchRequestValidationError is the validation error returned
// by DefaultVendorSearchRequest.Validate if the designated constraints aren't met.
type DefaultVendorSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultVendorSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultVendorSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultVendorSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultVendorSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultVendorSearchRequestValidationError) ErrorName() string {
	return "DefaultVendorSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultVendorSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultVendorSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultVendorSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultVendorSearchRequestValidationError{}

// Validate checks the field values on DefaultVendorGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultVendorGetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultVendorGetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultVendorGetRequestMultiError, or nil if none found.
func (m *DefaultVendorGetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultVendorGetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DefaultVendorGetRequestMultiError(errors)
	}

	return nil
}

// DefaultVendorGetRequestMultiError is an error wrapping multiple validation
// errors returned by DefaultVendorGetRequest.ValidateAll() if the designated
// constraints aren't met.
type DefaultVendorGetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultVendorGetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultVendorGetRequestMultiError) AllErrors() []error { return m }

// DefaultVendorGetRequestValidationError is the validation error returned by
// DefaultVendorGetRequest.Validate if the designated constraints aren't met.
type DefaultVendorGetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultVendorGetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultVendorGetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultVendorGetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultVendorGetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultVendorGetRequestValidationError) ErrorName() string {
	return "DefaultVendorGetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultVendorGetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultVendorGetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultVendorGetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultVendorGetRequestValidationError{}

// Validate checks the field values on FamilyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FamilyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FamilyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FamilyRequestMultiError, or
// nil if none found.
func (m *FamilyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FamilyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.VendorId != nil {
		// no validation rules for VendorId
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.AdminName != nil {
		// no validation rules for AdminName
	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return FamilyRequestMultiError(errors)
	}

	return nil
}

// FamilyRequestMultiError is an error wrapping multiple validation errors
// returned by FamilyRequest.ValidateAll() if the designated constraints
// aren't met.
type FamilyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FamilyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FamilyRequestMultiError) AllErrors() []error { return m }

// FamilyRequestValidationError is the validation error returned by
// FamilyRequest.Validate if the designated constraints aren't met.
type FamilyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FamilyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FamilyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FamilyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FamilyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FamilyRequestValidationError) ErrorName() string { return "FamilyRequestValidationError" }

// Error satisfies the builtin error interface
func (e FamilyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFamilyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FamilyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FamilyRequestValidationError{}

// Validate checks the field values on FamilyResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FamilyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FamilyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FamilyResponseMultiError,
// or nil if none found.
func (m *FamilyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FamilyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFamilies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FamilyResponseValidationError{
						field:  fmt.Sprintf("Families[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FamilyResponseValidationError{
						field:  fmt.Sprintf("Families[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FamilyResponseValidationError{
					field:  fmt.Sprintf("Families[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FamilyResponseMultiError(errors)
	}

	return nil
}

// FamilyResponseMultiError is an error wrapping multiple validation errors
// returned by FamilyResponse.ValidateAll() if the designated constraints
// aren't met.
type FamilyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FamilyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FamilyResponseMultiError) AllErrors() []error { return m }

// FamilyResponseValidationError is the validation error returned by
// FamilyResponse.Validate if the designated constraints aren't met.
type FamilyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FamilyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FamilyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FamilyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FamilyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FamilyResponseValidationError) ErrorName() string { return "FamilyResponseValidationError" }

// Error satisfies the builtin error interface
func (e FamilyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFamilyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FamilyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FamilyResponseValidationError{}

// Validate checks the field values on Family with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Family) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Family with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FamilyMultiError, or nil if none found.
func (m *Family) ValidateAll() error {
	return m.validate(true)
}

func (m *Family) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Enabled

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FamilyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FamilyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FamilyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FamilyMultiError(errors)
	}

	return nil
}

// FamilyMultiError is an error wrapping multiple validation errors returned by
// Family.ValidateAll() if the designated constraints aren't met.
type FamilyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FamilyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FamilyMultiError) AllErrors() []error { return m }

// FamilyValidationError is the validation error returned by Family.Validate if
// the designated constraints aren't met.
type FamilyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FamilyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FamilyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FamilyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FamilyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FamilyValidationError) ErrorName() string { return "FamilyValidationError" }

// Error satisfies the builtin error interface
func (e FamilyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFamily.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FamilyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FamilyValidationError{}

// Validate checks the field values on FamilyFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FamilyFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FamilyFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FamilyFilterMultiError, or
// nil if none found.
func (m *FamilyFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *FamilyFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return FamilyFilterMultiError(errors)
	}

	return nil
}

// FamilyFilterMultiError is an error wrapping multiple validation errors
// returned by FamilyFilter.ValidateAll() if the designated constraints aren't met.
type FamilyFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FamilyFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FamilyFilterMultiError) AllErrors() []error { return m }

// FamilyFilterValidationError is the validation error returned by
// FamilyFilter.Validate if the designated constraints aren't met.
type FamilyFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FamilyFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FamilyFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FamilyFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FamilyFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FamilyFilterValidationError) ErrorName() string { return "FamilyFilterValidationError" }

// Error satisfies the builtin error interface
func (e FamilyFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFamilyFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FamilyFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FamilyFilterValidationError{}

// Validate checks the field values on ListFamiliesByVendorRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListFamiliesByVendorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFamiliesByVendorRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFamiliesByVendorRequestMultiError, or nil if none found.
func (m *ListFamiliesByVendorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFamiliesByVendorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VendorId

	if len(errors) > 0 {
		return ListFamiliesByVendorRequestMultiError(errors)
	}

	return nil
}

// ListFamiliesByVendorRequestMultiError is an error wrapping multiple
// validation errors returned by ListFamiliesByVendorRequest.ValidateAll() if
// the designated constraints aren't met.
type ListFamiliesByVendorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFamiliesByVendorRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFamiliesByVendorRequestMultiError) AllErrors() []error { return m }

// ListFamiliesByVendorRequestValidationError is the validation error returned
// by ListFamiliesByVendorRequest.Validate if the designated constraints
// aren't met.
type ListFamiliesByVendorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFamiliesByVendorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFamiliesByVendorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFamiliesByVendorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFamiliesByVendorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFamiliesByVendorRequestValidationError) ErrorName() string {
	return "ListFamiliesByVendorRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListFamiliesByVendorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFamiliesByVendorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFamiliesByVendorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFamiliesByVendorRequestValidationError{}

// Validate checks the field values on VendorRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorRequestMultiError, or
// nil if none found.
func (m *VendorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.AdminName != nil {
		// no validation rules for AdminName
	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return VendorRequestMultiError(errors)
	}

	return nil
}

// VendorRequestMultiError is an error wrapping multiple validation errors
// returned by VendorRequest.ValidateAll() if the designated constraints
// aren't met.
type VendorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorRequestMultiError) AllErrors() []error { return m }

// VendorRequestValidationError is the validation error returned by
// VendorRequest.Validate if the designated constraints aren't met.
type VendorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorRequestValidationError) ErrorName() string { return "VendorRequestValidationError" }

// Error satisfies the builtin error interface
func (e VendorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorRequestValidationError{}

// Validate checks the field values on VendorRequestFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VendorRequestFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorRequestFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VendorRequestFilterMultiError, or nil if none found.
func (m *VendorRequestFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorRequestFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return VendorRequestFilterMultiError(errors)
	}

	return nil
}

// VendorRequestFilterMultiError is an error wrapping multiple validation
// errors returned by VendorRequestFilter.ValidateAll() if the designated
// constraints aren't met.
type VendorRequestFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorRequestFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorRequestFilterMultiError) AllErrors() []error { return m }

// VendorRequestFilterValidationError is the validation error returned by
// VendorRequestFilter.Validate if the designated constraints aren't met.
type VendorRequestFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorRequestFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorRequestFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorRequestFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorRequestFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorRequestFilterValidationError) ErrorName() string {
	return "VendorRequestFilterValidationError"
}

// Error satisfies the builtin error interface
func (e VendorRequestFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorRequestFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorRequestFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorRequestFilterValidationError{}

// Validate checks the field values on VendorId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorIdMultiError, or nil
// if none found.
func (m *VendorId) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorIdMultiError(errors)
	}

	return nil
}

// VendorIdMultiError is an error wrapping multiple validation errors returned
// by VendorId.ValidateAll() if the designated constraints aren't met.
type VendorIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorIdMultiError) AllErrors() []error { return m }

// VendorIdValidationError is the validation error returned by
// VendorId.Validate if the designated constraints aren't met.
type VendorIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorIdValidationError) ErrorName() string { return "VendorIdValidationError" }

// Error satisfies the builtin error interface
func (e VendorIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorIdValidationError{}

// Validate checks the field values on RegionalRateFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegionalRateFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegionalRateFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegionalRateFilterMultiError, or nil if none found.
func (m *RegionalRateFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *RegionalRateFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductId

	// no validation rules for RegionId

	if len(errors) > 0 {
		return RegionalRateFilterMultiError(errors)
	}

	return nil
}

// RegionalRateFilterMultiError is an error wrapping multiple validation errors
// returned by RegionalRateFilter.ValidateAll() if the designated constraints
// aren't met.
type RegionalRateFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegionalRateFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegionalRateFilterMultiError) AllErrors() []error { return m }

// RegionalRateFilterValidationError is the validation error returned by
// RegionalRateFilter.Validate if the designated constraints aren't met.
type RegionalRateFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegionalRateFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegionalRateFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegionalRateFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegionalRateFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegionalRateFilterValidationError) ErrorName() string {
	return "RegionalRateFilterValidationError"
}

// Error satisfies the builtin error interface
func (e RegionalRateFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegionalRateFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegionalRateFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegionalRateFilterValidationError{}

// Validate checks the field values on ProductAccessRequestV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductAccessRequestV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductAccessRequestV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductAccessRequestV2MultiError, or nil if none found.
func (m *ProductAccessRequestV2) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductAccessRequestV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for ProductId

	// no validation rules for RegionId

	// no validation rules for AdminName

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductAccessRequestV2ValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductAccessRequestV2ValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductAccessRequestV2ValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductAccessRequestV2MultiError(errors)
	}

	return nil
}

// ProductAccessRequestV2MultiError is an error wrapping multiple validation
// errors returned by ProductAccessRequestV2.ValidateAll() if the designated
// constraints aren't met.
type ProductAccessRequestV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductAccessRequestV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductAccessRequestV2MultiError) AllErrors() []error { return m }

// ProductAccessRequestV2ValidationError is the validation error returned by
// ProductAccessRequestV2.Validate if the designated constraints aren't met.
type ProductAccessRequestV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductAccessRequestV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductAccessRequestV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductAccessRequestV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductAccessRequestV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductAccessRequestV2ValidationError) ErrorName() string {
	return "ProductAccessRequestV2ValidationError"
}

// Error satisfies the builtin error interface
func (e ProductAccessRequestV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductAccessRequestV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductAccessRequestV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductAccessRequestV2ValidationError{}

// Validate checks the field values on DeleteAccessRequestV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAccessRequestV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAccessRequestV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAccessRequestV2MultiError, or nil if none found.
func (m *DeleteAccessRequestV2) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAccessRequestV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for RegionId

	// no validation rules for ProductId

	if len(errors) > 0 {
		return DeleteAccessRequestV2MultiError(errors)
	}

	return nil
}

// DeleteAccessRequestV2MultiError is an error wrapping multiple validation
// errors returned by DeleteAccessRequestV2.ValidateAll() if the designated
// constraints aren't met.
type DeleteAccessRequestV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAccessRequestV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAccessRequestV2MultiError) AllErrors() []error { return m }

// DeleteAccessRequestV2ValidationError is the validation error returned by
// DeleteAccessRequestV2.Validate if the designated constraints aren't met.
type DeleteAccessRequestV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAccessRequestV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAccessRequestV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAccessRequestV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAccessRequestV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAccessRequestV2ValidationError) ErrorName() string {
	return "DeleteAccessRequestV2ValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAccessRequestV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAccessRequestV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAccessRequestV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAccessRequestV2ValidationError{}

// Validate checks the field values on GetAccessResponseV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessResponseV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessResponseV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessResponseV2MultiError, or nil if none found.
func (m *GetAccessResponseV2) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessResponseV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAcl() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAccessResponseV2ValidationError{
						field:  fmt.Sprintf("Acl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAccessResponseV2ValidationError{
						field:  fmt.Sprintf("Acl[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAccessResponseV2ValidationError{
					field:  fmt.Sprintf("Acl[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAccessResponseV2MultiError(errors)
	}

	return nil
}

// GetAccessResponseV2MultiError is an error wrapping multiple validation
// errors returned by GetAccessResponseV2.ValidateAll() if the designated
// constraints aren't met.
type GetAccessResponseV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessResponseV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessResponseV2MultiError) AllErrors() []error { return m }

// GetAccessResponseV2ValidationError is the validation error returned by
// GetAccessResponseV2.Validate if the designated constraints aren't met.
type GetAccessResponseV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessResponseV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessResponseV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessResponseV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessResponseV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessResponseV2ValidationError) ErrorName() string {
	return "GetAccessResponseV2ValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessResponseV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessResponseV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessResponseV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessResponseV2ValidationError{}

// Validate checks the field values on ProductAccessResponseV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductAccessResponseV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductAccessResponseV2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductAccessResponseV2MultiError, or nil if none found.
func (m *ProductAccessResponseV2) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductAccessResponseV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for RegionId

	// no validation rules for ProductId

	// no validation rules for AdminName

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductAccessResponseV2ValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductAccessResponseV2ValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductAccessResponseV2ValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductAccessResponseV2MultiError(errors)
	}

	return nil
}

// ProductAccessResponseV2MultiError is an error wrapping multiple validation
// errors returned by ProductAccessResponseV2.ValidateAll() if the designated
// constraints aren't met.
type ProductAccessResponseV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductAccessResponseV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductAccessResponseV2MultiError) AllErrors() []error { return m }

// ProductAccessResponseV2ValidationError is the validation error returned by
// ProductAccessResponseV2.Validate if the designated constraints aren't met.
type ProductAccessResponseV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductAccessResponseV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductAccessResponseV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductAccessResponseV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductAccessResponseV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductAccessResponseV2ValidationError) ErrorName() string {
	return "ProductAccessResponseV2ValidationError"
}

// Error satisfies the builtin error interface
func (e ProductAccessResponseV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductAccessResponseV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductAccessResponseV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductAccessResponseV2ValidationError{}

// Validate checks the field values on RateData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RateData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RateDataMultiError, or nil
// if none found.
func (m *RateData) ValidateAll() error {
	return m.validate(true)
}

func (m *RateData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ProductId != nil {
		// no validation rules for ProductId
	}

	if m.RegionId != nil {
		// no validation rules for RegionId
	}

	if m.AccountType != nil {
		// no validation rules for AccountType
	}

	if m.Rate != nil {
		// no validation rules for Rate
	}

	if m.Unit != nil {
		// no validation rules for Unit
	}

	if m.UsageExpr != nil {
		// no validation rules for UsageExpr
	}

	if len(errors) > 0 {
		return RateDataMultiError(errors)
	}

	return nil
}

// RateDataMultiError is an error wrapping multiple validation errors returned
// by RateData.ValidateAll() if the designated constraints aren't met.
type RateDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateDataMultiError) AllErrors() []error { return m }

// RateDataValidationError is the validation error returned by
// RateData.Validate if the designated constraints aren't met.
type RateDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateDataValidationError) ErrorName() string { return "RateDataValidationError" }

// Error satisfies the builtin error interface
func (e RateDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateDataValidationError{}

// Validate checks the field values on ProductData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProductData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProductDataMultiError, or
// nil if none found.
func (m *ProductData) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.FamilyId != nil {
		// no validation rules for FamilyId
	}

	if m.VendorId != nil {
		// no validation rules for VendorId
	}

	if m.Pcq != nil {
		// no validation rules for Pcq
	}

	if m.Eccn != nil {
		// no validation rules for Eccn
	}

	if m.MatchExpr != nil {
		// no validation rules for MatchExpr
	}

	if m.ServiceName != nil {
		// no validation rules for ServiceName
	}

	if m.ServiceType != nil {
		// no validation rules for ServiceType
	}

	if m.InstanceType != nil {
		// no validation rules for InstanceType
	}

	if m.InstanceMode != nil {
		// no validation rules for InstanceMode
	}

	if m.InstanceCategory != nil {
		// no validation rules for InstanceCategory
	}

	if m.DisplayName != nil {
		// no validation rules for DisplayName
	}

	if m.DisplayCategory != nil {
		// no validation rules for DisplayCategory
	}

	if m.DisplayDesc != nil {
		// no validation rules for DisplayDesc
	}

	if m.DisplayInfo != nil {
		// no validation rules for DisplayInfo
	}

	if m.DisplayHighlight != nil {
		// no validation rules for DisplayHighlight
	}

	if m.AccountTypesBlocked != nil {
		// no validation rules for AccountTypesBlocked
	}

	if m.AccountWhitelist != nil {
		// no validation rules for AccountWhitelist
	}

	if m.BillingEnable != nil {
		// no validation rules for BillingEnable
	}

	if m.ReleaseStatus != nil {
		// no validation rules for ReleaseStatus
	}

	if m.Usecase != nil {
		// no validation rules for Usecase
	}

	if m.Metadata != nil {
		// no validation rules for Metadata
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.Enabled != nil {
		// no validation rules for Enabled
	}

	if len(errors) > 0 {
		return ProductDataMultiError(errors)
	}

	return nil
}

// ProductDataMultiError is an error wrapping multiple validation errors
// returned by ProductData.ValidateAll() if the designated constraints aren't met.
type ProductDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductDataMultiError) AllErrors() []error { return m }

// ProductDataValidationError is the validation error returned by
// ProductData.Validate if the designated constraints aren't met.
type ProductDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductDataValidationError) ErrorName() string { return "ProductDataValidationError" }

// Error satisfies the builtin error interface
func (e ProductDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductDataValidationError{}

// Validate checks the field values on ProposedData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProposedData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProposedData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProposedDataMultiError, or
// nil if none found.
func (m *ProposedData) ValidateAll() error {
	return m.validate(true)
}

func (m *ProposedData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProduct()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProposedDataValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProposedDataValidationError{
					field:  "Product",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProduct()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProposedDataValidationError{
				field:  "Product",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProposedDataValidationError{
						field:  fmt.Sprintf("Rates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProposedDataValidationError{
						field:  fmt.Sprintf("Rates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProposedDataValidationError{
					field:  fmt.Sprintf("Rates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProposedDataMultiError(errors)
	}

	return nil
}

// ProposedDataMultiError is an error wrapping multiple validation errors
// returned by ProposedData.ValidateAll() if the designated constraints aren't met.
type ProposedDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProposedDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProposedDataMultiError) AllErrors() []error { return m }

// ProposedDataValidationError is the validation error returned by
// ProposedData.Validate if the designated constraints aren't met.
type ProposedDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProposedDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProposedDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProposedDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProposedDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProposedDataValidationError) ErrorName() string { return "ProposedDataValidationError" }

// Error satisfies the builtin error interface
func (e ProposedDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProposedData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProposedDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProposedDataValidationError{}

// Validate checks the field values on ProductChangeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductChangeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductChangeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductChangeRequestMultiError, or nil if none found.
func (m *ProductChangeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductChangeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RequestType

	// no validation rules for RequestStatus

	// no validation rules for ProposedData

	// no validation rules for Requester

	// no validation rules for Reviewer

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductChangeRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductChangeRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductChangeRequestValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductChangeRequestValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductChangeRequestValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductChangeRequestValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductChangeRequestMultiError(errors)
	}

	return nil
}

// ProductChangeRequestMultiError is an error wrapping multiple validation
// errors returned by ProductChangeRequest.ValidateAll() if the designated
// constraints aren't met.
type ProductChangeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductChangeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductChangeRequestMultiError) AllErrors() []error { return m }

// ProductChangeRequestValidationError is the validation error returned by
// ProductChangeRequest.Validate if the designated constraints aren't met.
type ProductChangeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductChangeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductChangeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductChangeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductChangeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductChangeRequestValidationError) ErrorName() string {
	return "ProductChangeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProductChangeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductChangeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductChangeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductChangeRequestValidationError{}

// Validate checks the field values on ProductChangeRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductChangeRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductChangeRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductChangeRequestResponseMultiError, or nil if none found.
func (m *ProductChangeRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductChangeRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RequestType

	// no validation rules for RequestStatus

	if all {
		switch v := interface{}(m.GetProposedData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductChangeRequestResponseValidationError{
					field:  "ProposedData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductChangeRequestResponseValidationError{
					field:  "ProposedData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposedData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductChangeRequestResponseValidationError{
				field:  "ProposedData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Requester

	// no validation rules for Reviewer

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductChangeRequestResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductChangeRequestResponseValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductChangeRequestResponseValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductChangeRequestResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductChangeRequestResponseValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductChangeRequestResponseValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductChangeRequestResponseMultiError(errors)
	}

	return nil
}

// ProductChangeRequestResponseMultiError is an error wrapping multiple
// validation errors returned by ProductChangeRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type ProductChangeRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductChangeRequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductChangeRequestResponseMultiError) AllErrors() []error { return m }

// ProductChangeRequestResponseValidationError is the validation error returned
// by ProductChangeRequestResponse.Validate if the designated constraints
// aren't met.
type ProductChangeRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductChangeRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductChangeRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductChangeRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductChangeRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductChangeRequestResponseValidationError) ErrorName() string {
	return "ProductChangeRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProductChangeRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductChangeRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductChangeRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductChangeRequestResponseValidationError{}

// Validate checks the field values on ProductChangeRequestResponseList with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ProductChangeRequestResponseList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductChangeRequestResponseList with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ProductChangeRequestResponseListMultiError, or nil if none found.
func (m *ProductChangeRequestResponseList) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductChangeRequestResponseList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProductChangeRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductChangeRequestResponseListValidationError{
						field:  fmt.Sprintf("ProductChangeRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductChangeRequestResponseListValidationError{
						field:  fmt.Sprintf("ProductChangeRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductChangeRequestResponseListValidationError{
					field:  fmt.Sprintf("ProductChangeRequests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductChangeRequestResponseListMultiError(errors)
	}

	return nil
}

// ProductChangeRequestResponseListMultiError is an error wrapping multiple
// validation errors returned by
// ProductChangeRequestResponseList.ValidateAll() if the designated
// constraints aren't met.
type ProductChangeRequestResponseListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductChangeRequestResponseListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductChangeRequestResponseListMultiError) AllErrors() []error { return m }

// ProductChangeRequestResponseListValidationError is the validation error
// returned by ProductChangeRequestResponseList.Validate if the designated
// constraints aren't met.
type ProductChangeRequestResponseListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductChangeRequestResponseListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductChangeRequestResponseListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductChangeRequestResponseListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductChangeRequestResponseListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductChangeRequestResponseListValidationError) ErrorName() string {
	return "ProductChangeRequestResponseListValidationError"
}

// Error satisfies the builtin error interface
func (e ProductChangeRequestResponseListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductChangeRequestResponseList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductChangeRequestResponseListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductChangeRequestResponseListValidationError{}

// Validate checks the field values on ProductChangeRequestFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductChangeRequestFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductChangeRequestFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductChangeRequestFilterMultiError, or nil if none found.
func (m *ProductChangeRequestFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductChangeRequestFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.RequestStatus != nil {
		// no validation rules for RequestStatus
	}

	if len(errors) > 0 {
		return ProductChangeRequestFilterMultiError(errors)
	}

	return nil
}

// ProductChangeRequestFilterMultiError is an error wrapping multiple
// validation errors returned by ProductChangeRequestFilter.ValidateAll() if
// the designated constraints aren't met.
type ProductChangeRequestFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductChangeRequestFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductChangeRequestFilterMultiError) AllErrors() []error { return m }

// ProductChangeRequestFilterValidationError is the validation error returned
// by ProductChangeRequestFilter.Validate if the designated constraints aren't met.
type ProductChangeRequestFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductChangeRequestFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductChangeRequestFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductChangeRequestFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductChangeRequestFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductChangeRequestFilterValidationError) ErrorName() string {
	return "ProductChangeRequestFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ProductChangeRequestFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductChangeRequestFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductChangeRequestFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductChangeRequestFilterValidationError{}

// Validate checks the field values on ReviewProductChangeRequestFilter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReviewProductChangeRequestFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReviewProductChangeRequestFilter with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReviewProductChangeRequestFilterMultiError, or nil if none found.
func (m *ReviewProductChangeRequestFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReviewProductChangeRequestFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.Approve != nil {
		// no validation rules for Approve
	}

	if len(errors) > 0 {
		return ReviewProductChangeRequestFilterMultiError(errors)
	}

	return nil
}

// ReviewProductChangeRequestFilterMultiError is an error wrapping multiple
// validation errors returned by
// ReviewProductChangeRequestFilter.ValidateAll() if the designated
// constraints aren't met.
type ReviewProductChangeRequestFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReviewProductChangeRequestFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReviewProductChangeRequestFilterMultiError) AllErrors() []error { return m }

// ReviewProductChangeRequestFilterValidationError is the validation error
// returned by ReviewProductChangeRequestFilter.Validate if the designated
// constraints aren't met.
type ReviewProductChangeRequestFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReviewProductChangeRequestFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReviewProductChangeRequestFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReviewProductChangeRequestFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReviewProductChangeRequestFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReviewProductChangeRequestFilterValidationError) ErrorName() string {
	return "ReviewProductChangeRequestFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ReviewProductChangeRequestFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReviewProductChangeRequestFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReviewProductChangeRequestFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReviewProductChangeRequestFilterValidationError{}

// Validate checks the field values on EnableProductFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnableProductFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableProductFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnableProductFilterMultiError, or nil if none found.
func (m *EnableProductFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableProductFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductId

	if m.Enable != nil {
		// no validation rules for Enable
	}

	if len(errors) > 0 {
		return EnableProductFilterMultiError(errors)
	}

	return nil
}

// EnableProductFilterMultiError is an error wrapping multiple validation
// errors returned by EnableProductFilter.ValidateAll() if the designated
// constraints aren't met.
type EnableProductFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableProductFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableProductFilterMultiError) AllErrors() []error { return m }

// EnableProductFilterValidationError is the validation error returned by
// EnableProductFilter.Validate if the designated constraints aren't met.
type EnableProductFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableProductFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableProductFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableProductFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableProductFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableProductFilterValidationError) ErrorName() string {
	return "EnableProductFilterValidationError"
}

// Error satisfies the builtin error interface
func (e EnableProductFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableProductFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableProductFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableProductFilterValidationError{}

// Validate checks the field values on ProductInterestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductInterestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductInterestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductInterestRequestMultiError, or nil if none found.
func (m *ProductInterestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductInterestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CloudaccountId

	// no validation rules for UserEmail

	// no validation rules for ProductId

	// no validation rules for RegionId

	// no validation rules for Description

	if len(errors) > 0 {
		return ProductInterestRequestMultiError(errors)
	}

	return nil
}

// ProductInterestRequestMultiError is an error wrapping multiple validation
// errors returned by ProductInterestRequest.ValidateAll() if the designated
// constraints aren't met.
type ProductInterestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductInterestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductInterestRequestMultiError) AllErrors() []error { return m }

// ProductInterestRequestValidationError is the validation error returned by
// ProductInterestRequest.Validate if the designated constraints aren't met.
type ProductInterestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductInterestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductInterestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductInterestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductInterestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductInterestRequestValidationError) ErrorName() string {
	return "ProductInterestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProductInterestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductInterestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductInterestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductInterestRequestValidationError{}

// Validate checks the field values on ProductInterestFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductInterestFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductInterestFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductInterestFilterMultiError, or nil if none found.
func (m *ProductInterestFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductInterestFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudaccountId

	// no validation rules for UserEmail

	// no validation rules for ProductId

	// no validation rules for RegionId

	if len(errors) > 0 {
		return ProductInterestFilterMultiError(errors)
	}

	return nil
}

// ProductInterestFilterMultiError is an error wrapping multiple validation
// errors returned by ProductInterestFilter.ValidateAll() if the designated
// constraints aren't met.
type ProductInterestFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductInterestFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductInterestFilterMultiError) AllErrors() []error { return m }

// ProductInterestFilterValidationError is the validation error returned by
// ProductInterestFilter.Validate if the designated constraints aren't met.
type ProductInterestFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductInterestFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductInterestFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductInterestFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductInterestFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductInterestFilterValidationError) ErrorName() string {
	return "ProductInterestFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ProductInterestFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductInterestFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductInterestFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductInterestFilterValidationError{}

// Validate checks the field values on ProductInterestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProductInterestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductInterestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductInterestResponseMultiError, or nil if none found.
func (m *ProductInterestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductInterestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProductInterests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProductInterestResponseValidationError{
						field:  fmt.Sprintf("ProductInterests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProductInterestResponseValidationError{
						field:  fmt.Sprintf("ProductInterests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProductInterestResponseValidationError{
					field:  fmt.Sprintf("ProductInterests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProductInterestResponseMultiError(errors)
	}

	return nil
}

// ProductInterestResponseMultiError is an error wrapping multiple validation
// errors returned by ProductInterestResponse.ValidateAll() if the designated
// constraints aren't met.
type ProductInterestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductInterestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductInterestResponseMultiError) AllErrors() []error { return m }

// ProductInterestResponseValidationError is the validation error returned by
// ProductInterestResponse.Validate if the designated constraints aren't met.
type ProductInterestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductInterestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductInterestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductInterestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductInterestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductInterestResponseValidationError) ErrorName() string {
	return "ProductInterestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProductInterestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductInterestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductInterestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductInterestResponseValidationError{}

// Validate checks the field values on ProductInterest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProductInterest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProductInterest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProductInterestMultiError, or nil if none found.
func (m *ProductInterest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProductInterest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CloudaccountId

	// no validation rules for UserEmail

	// no validation rules for ProductId

	// no validation rules for RegionId

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProductInterestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProductInterestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProductInterestValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProductInterestMultiError(errors)
	}

	return nil
}

// ProductInterestMultiError is an error wrapping multiple validation errors
// returned by ProductInterest.ValidateAll() if the designated constraints
// aren't met.
type ProductInterestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProductInterestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProductInterestMultiError) AllErrors() []error { return m }

// ProductInterestValidationError is the validation error returned by
// ProductInterest.Validate if the designated constraints aren't met.
type ProductInterestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProductInterestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProductInterestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProductInterestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProductInterestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProductInterestValidationError) ErrorName() string { return "ProductInterestValidationError" }

// Error satisfies the builtin error interface
func (e ProductInterestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProductInterest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProductInterestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProductInterestValidationError{}

// Validate checks the field values on DefaultProduct_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultProduct_Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultProduct_Metadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultProduct_MetadataMultiError, or nil if none found.
func (m *DefaultProduct_Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultProduct_Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DefaultProduct_MetadataValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DefaultProduct_Metadata_Name_Pattern.MatchString(m.GetName()) {
		err := DefaultProduct_MetadataValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9]+([-.][a-z0-9]+)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DefaultProduct_MetadataMultiError(errors)
	}

	return nil
}

// DefaultProduct_MetadataMultiError is an error wrapping multiple validation
// errors returned by DefaultProduct_Metadata.ValidateAll() if the designated
// constraints aren't met.
type DefaultProduct_MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultProduct_MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultProduct_MetadataMultiError) AllErrors() []error { return m }

// DefaultProduct_MetadataValidationError is the validation error returned by
// DefaultProduct_Metadata.Validate if the designated constraints aren't met.
type DefaultProduct_MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultProduct_MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultProduct_MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultProduct_MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultProduct_MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultProduct_MetadataValidationError) ErrorName() string {
	return "DefaultProduct_MetadataValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultProduct_MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultProduct_Metadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultProduct_MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultProduct_MetadataValidationError{}

var _DefaultProduct_Metadata_Name_Pattern = regexp.MustCompile("^[a-z0-9]+([-.][a-z0-9]+)*$")

// Validate checks the field values on DefaultVendor_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefaultVendor_Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefaultVendor_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefaultVendor_MetadataMultiError, or nil if none found.
func (m *DefaultVendor_Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *DefaultVendor_Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return DefaultVendor_MetadataMultiError(errors)
	}

	return nil
}

// DefaultVendor_MetadataMultiError is an error wrapping multiple validation
// errors returned by DefaultVendor_Metadata.ValidateAll() if the designated
// constraints aren't met.
type DefaultVendor_MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefaultVendor_MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefaultVendor_MetadataMultiError) AllErrors() []error { return m }

// DefaultVendor_MetadataValidationError is the validation error returned by
// DefaultVendor_Metadata.Validate if the designated constraints aren't met.
type DefaultVendor_MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefaultVendor_MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefaultVendor_MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefaultVendor_MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefaultVendor_MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefaultVendor_MetadataValidationError) ErrorName() string {
	return "DefaultVendor_MetadataValidationError"
}

// Error satisfies the builtin error interface
func (e DefaultVendor_MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefaultVendor_Metadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefaultVendor_MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefaultVendor_MetadataValidationError{}
