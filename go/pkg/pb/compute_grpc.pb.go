// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: compute.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SshPublicKeyServiceClient is the client API for SshPublicKeyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SshPublicKeyServiceClient interface {
	// Store an SSH public key.
	Create(ctx context.Context, in *SshPublicKeyCreateRequest, opts ...grpc.CallOption) (*SshPublicKey, error)
	// Retrieve a stored SSH public key.
	Get(ctx context.Context, in *SshPublicKeyGetRequest, opts ...grpc.CallOption) (*SshPublicKey, error)
	// Get a list of stored SSH public keys.
	Search(ctx context.Context, in *SshPublicKeySearchRequest, opts ...grpc.CallOption) (*SshPublicKeySearchResponse, error)
	// List stored SSH public keys as a stream.
	// Warning: This does not work with OpenAPI client.
	// Internal-use only.
	SearchStream(ctx context.Context, in *SshPublicKeySearchRequest, opts ...grpc.CallOption) (SshPublicKeyService_SearchStreamClient, error)
	// Delete an SSH public key.
	Delete(ctx context.Context, in *SshPublicKeyDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sshPublicKeyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSshPublicKeyServiceClient(cc grpc.ClientConnInterface) SshPublicKeyServiceClient {
	return &sshPublicKeyServiceClient{cc}
}

func (c *sshPublicKeyServiceClient) Create(ctx context.Context, in *SshPublicKeyCreateRequest, opts ...grpc.CallOption) (*SshPublicKey, error) {
	out := new(SshPublicKey)
	err := c.cc.Invoke(ctx, "/proto.SshPublicKeyService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sshPublicKeyServiceClient) Get(ctx context.Context, in *SshPublicKeyGetRequest, opts ...grpc.CallOption) (*SshPublicKey, error) {
	out := new(SshPublicKey)
	err := c.cc.Invoke(ctx, "/proto.SshPublicKeyService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sshPublicKeyServiceClient) Search(ctx context.Context, in *SshPublicKeySearchRequest, opts ...grpc.CallOption) (*SshPublicKeySearchResponse, error) {
	out := new(SshPublicKeySearchResponse)
	err := c.cc.Invoke(ctx, "/proto.SshPublicKeyService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sshPublicKeyServiceClient) SearchStream(ctx context.Context, in *SshPublicKeySearchRequest, opts ...grpc.CallOption) (SshPublicKeyService_SearchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &SshPublicKeyService_ServiceDesc.Streams[0], "/proto.SshPublicKeyService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &sshPublicKeyServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SshPublicKeyService_SearchStreamClient interface {
	Recv() (*SshPublicKey, error)
	grpc.ClientStream
}

type sshPublicKeyServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *sshPublicKeyServiceSearchStreamClient) Recv() (*SshPublicKey, error) {
	m := new(SshPublicKey)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sshPublicKeyServiceClient) Delete(ctx context.Context, in *SshPublicKeyDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.SshPublicKeyService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sshPublicKeyServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.SshPublicKeyService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SshPublicKeyServiceServer is the server API for SshPublicKeyService service.
// All implementations must embed UnimplementedSshPublicKeyServiceServer
// for forward compatibility
type SshPublicKeyServiceServer interface {
	// Store an SSH public key.
	Create(context.Context, *SshPublicKeyCreateRequest) (*SshPublicKey, error)
	// Retrieve a stored SSH public key.
	Get(context.Context, *SshPublicKeyGetRequest) (*SshPublicKey, error)
	// Get a list of stored SSH public keys.
	Search(context.Context, *SshPublicKeySearchRequest) (*SshPublicKeySearchResponse, error)
	// List stored SSH public keys as a stream.
	// Warning: This does not work with OpenAPI client.
	// Internal-use only.
	SearchStream(*SshPublicKeySearchRequest, SshPublicKeyService_SearchStreamServer) error
	// Delete an SSH public key.
	Delete(context.Context, *SshPublicKeyDeleteRequest) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedSshPublicKeyServiceServer()
}

// UnimplementedSshPublicKeyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSshPublicKeyServiceServer struct {
}

func (UnimplementedSshPublicKeyServiceServer) Create(context.Context, *SshPublicKeyCreateRequest) (*SshPublicKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedSshPublicKeyServiceServer) Get(context.Context, *SshPublicKeyGetRequest) (*SshPublicKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSshPublicKeyServiceServer) Search(context.Context, *SshPublicKeySearchRequest) (*SshPublicKeySearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSshPublicKeyServiceServer) SearchStream(*SshPublicKeySearchRequest, SshPublicKeyService_SearchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedSshPublicKeyServiceServer) Delete(context.Context, *SshPublicKeyDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSshPublicKeyServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedSshPublicKeyServiceServer) mustEmbedUnimplementedSshPublicKeyServiceServer() {}

// UnsafeSshPublicKeyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SshPublicKeyServiceServer will
// result in compilation errors.
type UnsafeSshPublicKeyServiceServer interface {
	mustEmbedUnimplementedSshPublicKeyServiceServer()
}

func RegisterSshPublicKeyServiceServer(s grpc.ServiceRegistrar, srv SshPublicKeyServiceServer) {
	s.RegisterService(&SshPublicKeyService_ServiceDesc, srv)
}

func _SshPublicKeyService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SshPublicKeyCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshPublicKeyServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SshPublicKeyService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshPublicKeyServiceServer).Create(ctx, req.(*SshPublicKeyCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SshPublicKeyService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SshPublicKeyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshPublicKeyServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SshPublicKeyService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshPublicKeyServiceServer).Get(ctx, req.(*SshPublicKeyGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SshPublicKeyService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SshPublicKeySearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshPublicKeyServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SshPublicKeyService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshPublicKeyServiceServer).Search(ctx, req.(*SshPublicKeySearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SshPublicKeyService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SshPublicKeySearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SshPublicKeyServiceServer).SearchStream(m, &sshPublicKeyServiceSearchStreamServer{stream})
}

type SshPublicKeyService_SearchStreamServer interface {
	Send(*SshPublicKey) error
	grpc.ServerStream
}

type sshPublicKeyServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *sshPublicKeyServiceSearchStreamServer) Send(m *SshPublicKey) error {
	return x.ServerStream.SendMsg(m)
}

func _SshPublicKeyService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SshPublicKeyDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshPublicKeyServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SshPublicKeyService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshPublicKeyServiceServer).Delete(ctx, req.(*SshPublicKeyDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SshPublicKeyService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SshPublicKeyServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.SshPublicKeyService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SshPublicKeyServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SshPublicKeyService_ServiceDesc is the grpc.ServiceDesc for SshPublicKeyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SshPublicKeyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.SshPublicKeyService",
	HandlerType: (*SshPublicKeyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _SshPublicKeyService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _SshPublicKeyService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _SshPublicKeyService_Search_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SshPublicKeyService_Delete_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _SshPublicKeyService_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _SshPublicKeyService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute.proto",
}

// InstanceServiceClient is the client API for InstanceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceServiceClient interface {
	// Launch a new baremetal or virtual machine instance.
	Create(ctx context.Context, in *InstanceCreateRequest, opts ...grpc.CallOption) (*Instance, error)
	// Get the status of an instance.
	Get(ctx context.Context, in *InstanceGetRequest, opts ...grpc.CallOption) (*Instance, error)
	// List instances.
	Search(ctx context.Context, in *InstanceSearchRequest, opts ...grpc.CallOption) (*InstanceSearchResponse, error)
	// Update the specification of an instance.
	Update(ctx context.Context, in *InstanceUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Request deletion (termination) of an instance.
	Delete(ctx context.Context, in *InstanceDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type instanceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceServiceClient(cc grpc.ClientConnInterface) InstanceServiceClient {
	return &instanceServiceClient{cc}
}

func (c *instanceServiceClient) Create(ctx context.Context, in *InstanceCreateRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, "/proto.InstanceService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceServiceClient) Get(ctx context.Context, in *InstanceGetRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, "/proto.InstanceService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceServiceClient) Search(ctx context.Context, in *InstanceSearchRequest, opts ...grpc.CallOption) (*InstanceSearchResponse, error) {
	out := new(InstanceSearchResponse)
	err := c.cc.Invoke(ctx, "/proto.InstanceService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceServiceClient) Update(ctx context.Context, in *InstanceUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceServiceClient) Delete(ctx context.Context, in *InstanceDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceServiceServer is the server API for InstanceService service.
// All implementations must embed UnimplementedInstanceServiceServer
// for forward compatibility
type InstanceServiceServer interface {
	// Launch a new baremetal or virtual machine instance.
	Create(context.Context, *InstanceCreateRequest) (*Instance, error)
	// Get the status of an instance.
	Get(context.Context, *InstanceGetRequest) (*Instance, error)
	// List instances.
	Search(context.Context, *InstanceSearchRequest) (*InstanceSearchResponse, error)
	// Update the specification of an instance.
	Update(context.Context, *InstanceUpdateRequest) (*emptypb.Empty, error)
	// Request deletion (termination) of an instance.
	Delete(context.Context, *InstanceDeleteRequest) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedInstanceServiceServer()
}

// UnimplementedInstanceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceServiceServer struct {
}

func (UnimplementedInstanceServiceServer) Create(context.Context, *InstanceCreateRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedInstanceServiceServer) Get(context.Context, *InstanceGetRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceServiceServer) Search(context.Context, *InstanceSearchRequest) (*InstanceSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedInstanceServiceServer) Update(context.Context, *InstanceUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedInstanceServiceServer) Delete(context.Context, *InstanceDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedInstanceServiceServer) mustEmbedUnimplementedInstanceServiceServer() {}

// UnsafeInstanceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceServiceServer will
// result in compilation errors.
type UnsafeInstanceServiceServer interface {
	mustEmbedUnimplementedInstanceServiceServer()
}

func RegisterInstanceServiceServer(s grpc.ServiceRegistrar, srv InstanceServiceServer) {
	s.RegisterService(&InstanceService_ServiceDesc, srv)
}

func _InstanceService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServiceServer).Create(ctx, req.(*InstanceCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServiceServer).Get(ctx, req.(*InstanceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServiceServer).Search(ctx, req.(*InstanceSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServiceServer).Update(ctx, req.(*InstanceUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServiceServer).Delete(ctx, req.(*InstanceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceService_ServiceDesc is the grpc.ServiceDesc for InstanceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.InstanceService",
	HandlerType: (*InstanceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _InstanceService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstanceService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _InstanceService_Search_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _InstanceService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceService_Delete_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _InstanceService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "compute.proto",
}

// InstanceGroupServiceClient is the client API for InstanceGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceGroupServiceClient interface {
	// Launch a new group of instances.
	Create(ctx context.Context, in *InstanceGroupCreateRequest, opts ...grpc.CallOption) (*InstanceGroup, error)
	// Update the specification of an instanceGroup
	Update(ctx context.Context, in *InstanceGroupUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// List instance groups.
	Search(ctx context.Context, in *InstanceGroupSearchRequest, opts ...grpc.CallOption) (*InstanceGroupSearchResponse, error)
	// Request deletion (termination) of an instance group.
	Delete(ctx context.Context, in *InstanceGroupDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Request deletion (termination) of an instance in a group.
	// It always retains at least one instance in the group to use a template. To delete the entire group, use Delete API instead.
	DeleteMember(ctx context.Context, in *InstanceGroupMemberDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Create new instances for the group to reach to the desired count.
	// This returns an error if the desired count is less than the current count.
	ScaleUp(ctx context.Context, in *InstanceGroupScaleRequest, opts ...grpc.CallOption) (*InstanceGroupScaleResponse, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type instanceGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceGroupServiceClient(cc grpc.ClientConnInterface) InstanceGroupServiceClient {
	return &instanceGroupServiceClient{cc}
}

func (c *instanceGroupServiceClient) Create(ctx context.Context, in *InstanceGroupCreateRequest, opts ...grpc.CallOption) (*InstanceGroup, error) {
	out := new(InstanceGroup)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupServiceClient) Update(ctx context.Context, in *InstanceGroupUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupServiceClient) Search(ctx context.Context, in *InstanceGroupSearchRequest, opts ...grpc.CallOption) (*InstanceGroupSearchResponse, error) {
	out := new(InstanceGroupSearchResponse)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupServiceClient) Delete(ctx context.Context, in *InstanceGroupDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupServiceClient) DeleteMember(ctx context.Context, in *InstanceGroupMemberDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/DeleteMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupServiceClient) ScaleUp(ctx context.Context, in *InstanceGroupScaleRequest, opts ...grpc.CallOption) (*InstanceGroupScaleResponse, error) {
	out := new(InstanceGroupScaleResponse)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/ScaleUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceGroupService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceGroupServiceServer is the server API for InstanceGroupService service.
// All implementations must embed UnimplementedInstanceGroupServiceServer
// for forward compatibility
type InstanceGroupServiceServer interface {
	// Launch a new group of instances.
	Create(context.Context, *InstanceGroupCreateRequest) (*InstanceGroup, error)
	// Update the specification of an instanceGroup
	Update(context.Context, *InstanceGroupUpdateRequest) (*emptypb.Empty, error)
	// List instance groups.
	Search(context.Context, *InstanceGroupSearchRequest) (*InstanceGroupSearchResponse, error)
	// Request deletion (termination) of an instance group.
	Delete(context.Context, *InstanceGroupDeleteRequest) (*emptypb.Empty, error)
	// Request deletion (termination) of an instance in a group.
	// It always retains at least one instance in the group to use a template. To delete the entire group, use Delete API instead.
	DeleteMember(context.Context, *InstanceGroupMemberDeleteRequest) (*emptypb.Empty, error)
	// Create new instances for the group to reach to the desired count.
	// This returns an error if the desired count is less than the current count.
	ScaleUp(context.Context, *InstanceGroupScaleRequest) (*InstanceGroupScaleResponse, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedInstanceGroupServiceServer()
}

// UnimplementedInstanceGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceGroupServiceServer struct {
}

func (UnimplementedInstanceGroupServiceServer) Create(context.Context, *InstanceGroupCreateRequest) (*InstanceGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedInstanceGroupServiceServer) Update(context.Context, *InstanceGroupUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedInstanceGroupServiceServer) Search(context.Context, *InstanceGroupSearchRequest) (*InstanceGroupSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedInstanceGroupServiceServer) Delete(context.Context, *InstanceGroupDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceGroupServiceServer) DeleteMember(context.Context, *InstanceGroupMemberDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMember not implemented")
}
func (UnimplementedInstanceGroupServiceServer) ScaleUp(context.Context, *InstanceGroupScaleRequest) (*InstanceGroupScaleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScaleUp not implemented")
}
func (UnimplementedInstanceGroupServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedInstanceGroupServiceServer) mustEmbedUnimplementedInstanceGroupServiceServer() {}

// UnsafeInstanceGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceGroupServiceServer will
// result in compilation errors.
type UnsafeInstanceGroupServiceServer interface {
	mustEmbedUnimplementedInstanceGroupServiceServer()
}

func RegisterInstanceGroupServiceServer(s grpc.ServiceRegistrar, srv InstanceGroupServiceServer) {
	s.RegisterService(&InstanceGroupService_ServiceDesc, srv)
}

func _InstanceGroupService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).Create(ctx, req.(*InstanceGroupCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).Update(ctx, req.(*InstanceGroupUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).Search(ctx, req.(*InstanceGroupSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).Delete(ctx, req.(*InstanceGroupDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupService_DeleteMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupMemberDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).DeleteMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/DeleteMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).DeleteMember(ctx, req.(*InstanceGroupMemberDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupService_ScaleUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceGroupScaleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).ScaleUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/ScaleUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).ScaleUp(ctx, req.(*InstanceGroupScaleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceGroupService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceGroupService_ServiceDesc is the grpc.ServiceDesc for InstanceGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.InstanceGroupService",
	HandlerType: (*InstanceGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _InstanceGroupService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _InstanceGroupService_Update_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _InstanceGroupService_Search_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceGroupService_Delete_Handler,
		},
		{
			MethodName: "DeleteMember",
			Handler:    _InstanceGroupService_DeleteMember_Handler,
		},
		{
			MethodName: "ScaleUp",
			Handler:    _InstanceGroupService_ScaleUp_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _InstanceGroupService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "compute.proto",
}

// InstanceTypeServiceClient is the client API for InstanceTypeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceTypeServiceClient interface {
	// Create or update an instance type.
	Put(ctx context.Context, in *InstanceType, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Delete an instance typ.
	Delete(ctx context.Context, in *InstanceTypeDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get an instance type.
	Get(ctx context.Context, in *InstanceTypeGetRequest, opts ...grpc.CallOption) (*InstanceType, error)
	// List instance types.
	Search(ctx context.Context, in *InstanceTypeSearchRequest, opts ...grpc.CallOption) (*InstanceTypeSearchResponse, error)
	// List instance types as a stream.
	SearchStream(ctx context.Context, in *InstanceTypeSearchRequest, opts ...grpc.CallOption) (InstanceTypeService_SearchStreamClient, error)
}

type instanceTypeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceTypeServiceClient(cc grpc.ClientConnInterface) InstanceTypeServiceClient {
	return &instanceTypeServiceClient{cc}
}

func (c *instanceTypeServiceClient) Put(ctx context.Context, in *InstanceType, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceTypeService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTypeServiceClient) Delete(ctx context.Context, in *InstanceTypeDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.InstanceTypeService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTypeServiceClient) Get(ctx context.Context, in *InstanceTypeGetRequest, opts ...grpc.CallOption) (*InstanceType, error) {
	out := new(InstanceType)
	err := c.cc.Invoke(ctx, "/proto.InstanceTypeService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTypeServiceClient) Search(ctx context.Context, in *InstanceTypeSearchRequest, opts ...grpc.CallOption) (*InstanceTypeSearchResponse, error) {
	out := new(InstanceTypeSearchResponse)
	err := c.cc.Invoke(ctx, "/proto.InstanceTypeService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTypeServiceClient) SearchStream(ctx context.Context, in *InstanceTypeSearchRequest, opts ...grpc.CallOption) (InstanceTypeService_SearchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &InstanceTypeService_ServiceDesc.Streams[0], "/proto.InstanceTypeService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &instanceTypeServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InstanceTypeService_SearchStreamClient interface {
	Recv() (*InstanceType, error)
	grpc.ClientStream
}

type instanceTypeServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *instanceTypeServiceSearchStreamClient) Recv() (*InstanceType, error) {
	m := new(InstanceType)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InstanceTypeServiceServer is the server API for InstanceTypeService service.
// All implementations must embed UnimplementedInstanceTypeServiceServer
// for forward compatibility
type InstanceTypeServiceServer interface {
	// Create or update an instance type.
	Put(context.Context, *InstanceType) (*emptypb.Empty, error)
	// Delete an instance typ.
	Delete(context.Context, *InstanceTypeDeleteRequest) (*emptypb.Empty, error)
	// Get an instance type.
	Get(context.Context, *InstanceTypeGetRequest) (*InstanceType, error)
	// List instance types.
	Search(context.Context, *InstanceTypeSearchRequest) (*InstanceTypeSearchResponse, error)
	// List instance types as a stream.
	SearchStream(*InstanceTypeSearchRequest, InstanceTypeService_SearchStreamServer) error
	mustEmbedUnimplementedInstanceTypeServiceServer()
}

// UnimplementedInstanceTypeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceTypeServiceServer struct {
}

func (UnimplementedInstanceTypeServiceServer) Put(context.Context, *InstanceType) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedInstanceTypeServiceServer) Delete(context.Context, *InstanceTypeDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceTypeServiceServer) Get(context.Context, *InstanceTypeGetRequest) (*InstanceType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceTypeServiceServer) Search(context.Context, *InstanceTypeSearchRequest) (*InstanceTypeSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedInstanceTypeServiceServer) SearchStream(*InstanceTypeSearchRequest, InstanceTypeService_SearchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedInstanceTypeServiceServer) mustEmbedUnimplementedInstanceTypeServiceServer() {}

// UnsafeInstanceTypeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceTypeServiceServer will
// result in compilation errors.
type UnsafeInstanceTypeServiceServer interface {
	mustEmbedUnimplementedInstanceTypeServiceServer()
}

func RegisterInstanceTypeServiceServer(s grpc.ServiceRegistrar, srv InstanceTypeServiceServer) {
	s.RegisterService(&InstanceTypeService_ServiceDesc, srv)
}

func _InstanceTypeService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTypeServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceTypeService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTypeServiceServer).Put(ctx, req.(*InstanceType))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTypeService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceTypeDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTypeServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceTypeService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTypeServiceServer).Delete(ctx, req.(*InstanceTypeDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTypeService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceTypeGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTypeServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceTypeService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTypeServiceServer).Get(ctx, req.(*InstanceTypeGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTypeService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceTypeSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTypeServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.InstanceTypeService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTypeServiceServer).Search(ctx, req.(*InstanceTypeSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTypeService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceTypeSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InstanceTypeServiceServer).SearchStream(m, &instanceTypeServiceSearchStreamServer{stream})
}

type InstanceTypeService_SearchStreamServer interface {
	Send(*InstanceType) error
	grpc.ServerStream
}

type instanceTypeServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *instanceTypeServiceSearchStreamServer) Send(m *InstanceType) error {
	return x.ServerStream.SendMsg(m)
}

// InstanceTypeService_ServiceDesc is the grpc.ServiceDesc for InstanceTypeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceTypeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.InstanceTypeService",
	HandlerType: (*InstanceTypeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _InstanceTypeService_Put_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceTypeService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstanceTypeService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _InstanceTypeService_Search_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _InstanceTypeService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute.proto",
}

// MachineImageServiceClient is the client API for MachineImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MachineImageServiceClient interface {
	// Create or update a machine image.
	Put(ctx context.Context, in *MachineImage, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Delete a machine image.
	Delete(ctx context.Context, in *MachineImageDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Get a machine image.
	Get(ctx context.Context, in *MachineImageGetRequest, opts ...grpc.CallOption) (*MachineImage, error)
	// List machine images.
	Search(ctx context.Context, in *MachineImageSearchRequest, opts ...grpc.CallOption) (*MachineImageSearchResponse, error)
	// List machine images as a stream.
	SearchStream(ctx context.Context, in *MachineImageSearchRequest, opts ...grpc.CallOption) (MachineImageService_SearchStreamClient, error)
}

type machineImageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMachineImageServiceClient(cc grpc.ClientConnInterface) MachineImageServiceClient {
	return &machineImageServiceClient{cc}
}

func (c *machineImageServiceClient) Put(ctx context.Context, in *MachineImage, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.MachineImageService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImageServiceClient) Delete(ctx context.Context, in *MachineImageDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.MachineImageService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImageServiceClient) Get(ctx context.Context, in *MachineImageGetRequest, opts ...grpc.CallOption) (*MachineImage, error) {
	out := new(MachineImage)
	err := c.cc.Invoke(ctx, "/proto.MachineImageService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImageServiceClient) Search(ctx context.Context, in *MachineImageSearchRequest, opts ...grpc.CallOption) (*MachineImageSearchResponse, error) {
	out := new(MachineImageSearchResponse)
	err := c.cc.Invoke(ctx, "/proto.MachineImageService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImageServiceClient) SearchStream(ctx context.Context, in *MachineImageSearchRequest, opts ...grpc.CallOption) (MachineImageService_SearchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &MachineImageService_ServiceDesc.Streams[0], "/proto.MachineImageService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &machineImageServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MachineImageService_SearchStreamClient interface {
	Recv() (*MachineImage, error)
	grpc.ClientStream
}

type machineImageServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *machineImageServiceSearchStreamClient) Recv() (*MachineImage, error) {
	m := new(MachineImage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MachineImageServiceServer is the server API for MachineImageService service.
// All implementations must embed UnimplementedMachineImageServiceServer
// for forward compatibility
type MachineImageServiceServer interface {
	// Create or update a machine image.
	Put(context.Context, *MachineImage) (*emptypb.Empty, error)
	// Delete a machine image.
	Delete(context.Context, *MachineImageDeleteRequest) (*emptypb.Empty, error)
	// Get a machine image.
	Get(context.Context, *MachineImageGetRequest) (*MachineImage, error)
	// List machine images.
	Search(context.Context, *MachineImageSearchRequest) (*MachineImageSearchResponse, error)
	// List machine images as a stream.
	SearchStream(*MachineImageSearchRequest, MachineImageService_SearchStreamServer) error
	mustEmbedUnimplementedMachineImageServiceServer()
}

// UnimplementedMachineImageServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMachineImageServiceServer struct {
}

func (UnimplementedMachineImageServiceServer) Put(context.Context, *MachineImage) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedMachineImageServiceServer) Delete(context.Context, *MachineImageDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMachineImageServiceServer) Get(context.Context, *MachineImageGetRequest) (*MachineImage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMachineImageServiceServer) Search(context.Context, *MachineImageSearchRequest) (*MachineImageSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMachineImageServiceServer) SearchStream(*MachineImageSearchRequest, MachineImageService_SearchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedMachineImageServiceServer) mustEmbedUnimplementedMachineImageServiceServer() {}

// UnsafeMachineImageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MachineImageServiceServer will
// result in compilation errors.
type UnsafeMachineImageServiceServer interface {
	mustEmbedUnimplementedMachineImageServiceServer()
}

func RegisterMachineImageServiceServer(s grpc.ServiceRegistrar, srv MachineImageServiceServer) {
	s.RegisterService(&MachineImageService_ServiceDesc, srv)
}

func _MachineImageService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineImage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImageServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.MachineImageService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImageServiceServer).Put(ctx, req.(*MachineImage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImageService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineImageDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImageServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.MachineImageService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImageServiceServer).Delete(ctx, req.(*MachineImageDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImageService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineImageGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImageServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.MachineImageService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImageServiceServer).Get(ctx, req.(*MachineImageGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImageService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineImageSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImageServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.MachineImageService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImageServiceServer).Search(ctx, req.(*MachineImageSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImageService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MachineImageSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MachineImageServiceServer).SearchStream(m, &machineImageServiceSearchStreamServer{stream})
}

type MachineImageService_SearchStreamServer interface {
	Send(*MachineImage) error
	grpc.ServerStream
}

type machineImageServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *machineImageServiceSearchStreamServer) Send(m *MachineImage) error {
	return x.ServerStream.SendMsg(m)
}

// MachineImageService_ServiceDesc is the grpc.ServiceDesc for MachineImageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MachineImageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.MachineImageService",
	HandlerType: (*MachineImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _MachineImageService_Put_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MachineImageService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MachineImageService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _MachineImageService_Search_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _MachineImageService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute.proto",
}

// VNetServiceClient is the client API for VNetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VNetServiceClient interface {
	// Create or update a VNet.
	Put(ctx context.Context, in *VNetPutRequest, opts ...grpc.CallOption) (*VNet, error)
	// Retrieve a VNet record from DB
	Get(ctx context.Context, in *VNetGetRequest, opts ...grpc.CallOption) (*VNet, error)
	// Get a list of stored VNets.
	Search(ctx context.Context, in *VNetSearchRequest, opts ...grpc.CallOption) (*VNetSearchResponse, error)
	// List stored VNets as a stream.
	SearchStream(ctx context.Context, in *VNetSearchRequest, opts ...grpc.CallOption) (VNetService_SearchStreamClient, error)
	// Delete an VNet from the DB.
	// Returns FailedPrecondition if VNet has running instances or other consumed IP addresses.
	Delete(ctx context.Context, in *VNetDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type vNetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVNetServiceClient(cc grpc.ClientConnInterface) VNetServiceClient {
	return &vNetServiceClient{cc}
}

func (c *vNetServiceClient) Put(ctx context.Context, in *VNetPutRequest, opts ...grpc.CallOption) (*VNet, error) {
	out := new(VNet)
	err := c.cc.Invoke(ctx, "/proto.VNetService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetServiceClient) Get(ctx context.Context, in *VNetGetRequest, opts ...grpc.CallOption) (*VNet, error) {
	out := new(VNet)
	err := c.cc.Invoke(ctx, "/proto.VNetService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetServiceClient) Search(ctx context.Context, in *VNetSearchRequest, opts ...grpc.CallOption) (*VNetSearchResponse, error) {
	out := new(VNetSearchResponse)
	err := c.cc.Invoke(ctx, "/proto.VNetService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetServiceClient) SearchStream(ctx context.Context, in *VNetSearchRequest, opts ...grpc.CallOption) (VNetService_SearchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &VNetService_ServiceDesc.Streams[0], "/proto.VNetService/SearchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vNetServiceSearchStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VNetService_SearchStreamClient interface {
	Recv() (*VNet, error)
	grpc.ClientStream
}

type vNetServiceSearchStreamClient struct {
	grpc.ClientStream
}

func (x *vNetServiceSearchStreamClient) Recv() (*VNet, error) {
	m := new(VNet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vNetServiceClient) Delete(ctx context.Context, in *VNetDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VNetService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNetServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.VNetService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNetServiceServer is the server API for VNetService service.
// All implementations must embed UnimplementedVNetServiceServer
// for forward compatibility
type VNetServiceServer interface {
	// Create or update a VNet.
	Put(context.Context, *VNetPutRequest) (*VNet, error)
	// Retrieve a VNet record from DB
	Get(context.Context, *VNetGetRequest) (*VNet, error)
	// Get a list of stored VNets.
	Search(context.Context, *VNetSearchRequest) (*VNetSearchResponse, error)
	// List stored VNets as a stream.
	SearchStream(*VNetSearchRequest, VNetService_SearchStreamServer) error
	// Delete an VNet from the DB.
	// Returns FailedPrecondition if VNet has running instances or other consumed IP addresses.
	Delete(context.Context, *VNetDeleteRequest) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedVNetServiceServer()
}

// UnimplementedVNetServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVNetServiceServer struct {
}

func (UnimplementedVNetServiceServer) Put(context.Context, *VNetPutRequest) (*VNet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedVNetServiceServer) Get(context.Context, *VNetGetRequest) (*VNet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedVNetServiceServer) Search(context.Context, *VNetSearchRequest) (*VNetSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedVNetServiceServer) SearchStream(*VNetSearchRequest, VNetService_SearchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchStream not implemented")
}
func (UnimplementedVNetServiceServer) Delete(context.Context, *VNetDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedVNetServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedVNetServiceServer) mustEmbedUnimplementedVNetServiceServer() {}

// UnsafeVNetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VNetServiceServer will
// result in compilation errors.
type UnsafeVNetServiceServer interface {
	mustEmbedUnimplementedVNetServiceServer()
}

func RegisterVNetServiceServer(s grpc.ServiceRegistrar, srv VNetServiceServer) {
	s.RegisterService(&VNetService_ServiceDesc, srv)
}

func _VNetService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetServiceServer).Put(ctx, req.(*VNetPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetServiceServer).Get(ctx, req.(*VNetGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetServiceServer).Search(ctx, req.(*VNetSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetService_SearchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VNetSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VNetServiceServer).SearchStream(m, &vNetServiceSearchStreamServer{stream})
}

type VNetService_SearchStreamServer interface {
	Send(*VNet) error
	grpc.ServerStream
}

type vNetServiceSearchStreamServer struct {
	grpc.ServerStream
}

func (x *vNetServiceSearchStreamServer) Send(m *VNet) error {
	return x.ServerStream.SendMsg(m)
}

func _VNetService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNetDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetServiceServer).Delete(ctx, req.(*VNetDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNetService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNetServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.VNetService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNetServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// VNetService_ServiceDesc is the grpc.ServiceDesc for VNetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VNetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.VNetService",
	HandlerType: (*VNetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _VNetService_Put_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _VNetService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _VNetService_Search_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VNetService_Delete_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _VNetService_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchStream",
			Handler:       _VNetService_SearchStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compute.proto",
}

// LoadBalancerServiceClient is the client API for LoadBalancerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoadBalancerServiceClient interface {
	// Create a new load balancer.
	Create(ctx context.Context, in *LoadBalancerCreateRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// Get the status of a load balancer.
	Get(ctx context.Context, in *LoadBalancerGetRequest, opts ...grpc.CallOption) (*LoadBalancer, error)
	// List load balancers.
	Search(ctx context.Context, in *LoadBalancerSearchRequest, opts ...grpc.CallOption) (*LoadBalancerSearchResponse, error)
	// Update the specification of an load balancer.
	Update(ctx context.Context, in *LoadBalancerUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Request deletion of a load balancer.
	Delete(ctx context.Context, in *LoadBalancerDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type loadBalancerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoadBalancerServiceClient(cc grpc.ClientConnInterface) LoadBalancerServiceClient {
	return &loadBalancerServiceClient{cc}
}

func (c *loadBalancerServiceClient) Create(ctx context.Context, in *LoadBalancerCreateRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) Get(ctx context.Context, in *LoadBalancerGetRequest, opts ...grpc.CallOption) (*LoadBalancer, error) {
	out := new(LoadBalancer)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) Search(ctx context.Context, in *LoadBalancerSearchRequest, opts ...grpc.CallOption) (*LoadBalancerSearchResponse, error) {
	out := new(LoadBalancerSearchResponse)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) Update(ctx context.Context, in *LoadBalancerUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) Delete(ctx context.Context, in *LoadBalancerDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loadBalancerServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.LoadBalancerService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoadBalancerServiceServer is the server API for LoadBalancerService service.
// All implementations must embed UnimplementedLoadBalancerServiceServer
// for forward compatibility
type LoadBalancerServiceServer interface {
	// Create a new load balancer.
	Create(context.Context, *LoadBalancerCreateRequest) (*LoadBalancer, error)
	// Get the status of a load balancer.
	Get(context.Context, *LoadBalancerGetRequest) (*LoadBalancer, error)
	// List load balancers.
	Search(context.Context, *LoadBalancerSearchRequest) (*LoadBalancerSearchResponse, error)
	// Update the specification of an load balancer.
	Update(context.Context, *LoadBalancerUpdateRequest) (*emptypb.Empty, error)
	// Request deletion of a load balancer.
	Delete(context.Context, *LoadBalancerDeleteRequest) (*emptypb.Empty, error)
	// Ping always returns a successful response by the service implementation.
	// It can be used for testing connectivity to the service.
	Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedLoadBalancerServiceServer()
}

// UnimplementedLoadBalancerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLoadBalancerServiceServer struct {
}

func (UnimplementedLoadBalancerServiceServer) Create(context.Context, *LoadBalancerCreateRequest) (*LoadBalancer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLoadBalancerServiceServer) Get(context.Context, *LoadBalancerGetRequest) (*LoadBalancer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLoadBalancerServiceServer) Search(context.Context, *LoadBalancerSearchRequest) (*LoadBalancerSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedLoadBalancerServiceServer) Update(context.Context, *LoadBalancerUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLoadBalancerServiceServer) Delete(context.Context, *LoadBalancerDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLoadBalancerServiceServer) Ping(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedLoadBalancerServiceServer) mustEmbedUnimplementedLoadBalancerServiceServer() {}

// UnsafeLoadBalancerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoadBalancerServiceServer will
// result in compilation errors.
type UnsafeLoadBalancerServiceServer interface {
	mustEmbedUnimplementedLoadBalancerServiceServer()
}

func RegisterLoadBalancerServiceServer(s grpc.ServiceRegistrar, srv LoadBalancerServiceServer) {
	s.RegisterService(&LoadBalancerService_ServiceDesc, srv)
}

func _LoadBalancerService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).Create(ctx, req.(*LoadBalancerCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).Get(ctx, req.(*LoadBalancerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).Search(ctx, req.(*LoadBalancerSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).Update(ctx, req.(*LoadBalancerUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadBalancerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).Delete(ctx, req.(*LoadBalancerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoadBalancerService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoadBalancerServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.LoadBalancerService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoadBalancerServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// LoadBalancerService_ServiceDesc is the grpc.ServiceDesc for LoadBalancerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoadBalancerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.LoadBalancerService",
	HandlerType: (*LoadBalancerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LoadBalancerService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LoadBalancerService_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _LoadBalancerService_Search_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LoadBalancerService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LoadBalancerService_Delete_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _LoadBalancerService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "compute.proto",
}
