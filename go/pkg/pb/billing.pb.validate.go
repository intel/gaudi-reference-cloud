// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: billing.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on BillingAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingAccountMultiError,
// or nil if none found.
func (m *BillingAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return BillingAccountMultiError(errors)
	}

	return nil
}

// BillingAccountMultiError is an error wrapping multiple validation errors
// returned by BillingAccount.ValidateAll() if the designated constraints
// aren't met.
type BillingAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingAccountMultiError) AllErrors() []error { return m }

// BillingAccountValidationError is the validation error returned by
// BillingAccount.Validate if the designated constraints aren't met.
type BillingAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingAccountValidationError) ErrorName() string { return "BillingAccountValidationError" }

// Error satisfies the builtin error interface
func (e BillingAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingAccountValidationError{}

// Validate checks the field values on BillingAccountDowngrade with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingAccountDowngrade) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingAccountDowngrade with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingAccountDowngradeMultiError, or nil if none found.
func (m *BillingAccountDowngrade) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingAccountDowngrade) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Force

	// no validation rules for DowngradeOption

	if len(errors) > 0 {
		return BillingAccountDowngradeMultiError(errors)
	}

	return nil
}

// BillingAccountDowngradeMultiError is an error wrapping multiple validation
// errors returned by BillingAccountDowngrade.ValidateAll() if the designated
// constraints aren't met.
type BillingAccountDowngradeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingAccountDowngradeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingAccountDowngradeMultiError) AllErrors() []error { return m }

// BillingAccountDowngradeValidationError is the validation error returned by
// BillingAccountDowngrade.Validate if the designated constraints aren't met.
type BillingAccountDowngradeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingAccountDowngradeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingAccountDowngradeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingAccountDowngradeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingAccountDowngradeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingAccountDowngradeValidationError) ErrorName() string {
	return "BillingAccountDowngradeValidationError"
}

// Error satisfies the builtin error interface
func (e BillingAccountDowngradeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingAccountDowngrade.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingAccountDowngradeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingAccountDowngradeValidationError{}

// Validate checks the field values on BillingOptionFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingOptionFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingOptionFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingOptionFilterMultiError, or nil if none found.
func (m *BillingOptionFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingOptionFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.CloudAccountId != nil {
		// no validation rules for CloudAccountId
	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingOptionFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingOptionFilterValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingOptionFilterValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingOptionFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingOptionFilterValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingOptionFilterValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BillingOptionFilterMultiError(errors)
	}

	return nil
}

// BillingOptionFilterMultiError is an error wrapping multiple validation
// errors returned by BillingOptionFilter.ValidateAll() if the designated
// constraints aren't met.
type BillingOptionFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingOptionFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingOptionFilterMultiError) AllErrors() []error { return m }

// BillingOptionFilterValidationError is the validation error returned by
// BillingOptionFilter.Validate if the designated constraints aren't met.
type BillingOptionFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingOptionFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingOptionFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingOptionFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingOptionFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingOptionFilterValidationError) ErrorName() string {
	return "BillingOptionFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingOptionFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingOptionFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingOptionFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingOptionFilterValidationError{}

// Validate checks the field values on BillingOption with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingOption with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingOptionMultiError, or
// nil if none found.
func (m *BillingOption) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingOptionValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingOptionValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingOptionValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for CloudAccountId

	// no validation rules for FirstName

	// no validation rules for MiddleInitial

	// no validation rules for LastName

	// no validation rules for Email

	// no validation rules for PaymentType

	switch v := m.PaymentMethod.(type) {
	case *BillingOption_CreditCard:
		if v == nil {
			err := BillingOptionValidationError{
				field:  "PaymentMethod",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreditCard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingOptionValidationError{
						field:  "CreditCard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingOptionValidationError{
						field:  "CreditCard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreditCard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingOptionValidationError{
					field:  "CreditCard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BillingOption_Other:
		if v == nil {
			err := BillingOptionValidationError{
				field:  "PaymentMethod",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOther()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingOptionValidationError{
						field:  "Other",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingOptionValidationError{
						field:  "Other",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOther()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingOptionValidationError{
					field:  "Other",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return BillingOptionMultiError(errors)
	}

	return nil
}

// BillingOptionMultiError is an error wrapping multiple validation errors
// returned by BillingOption.ValidateAll() if the designated constraints
// aren't met.
type BillingOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingOptionMultiError) AllErrors() []error { return m }

// BillingOptionValidationError is the validation error returned by
// BillingOption.Validate if the designated constraints aren't met.
type BillingOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingOptionValidationError) ErrorName() string { return "BillingOptionValidationError" }

// Error satisfies the builtin error interface
func (e BillingOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingOptionValidationError{}

// Validate checks the field values on CreditCard with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditCard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditCard with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditCardMultiError, or
// nil if none found.
func (m *CreditCard) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditCard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Suffix

	// no validation rules for Expiration

	// no validation rules for Type

	if len(errors) > 0 {
		return CreditCardMultiError(errors)
	}

	return nil
}

// CreditCardMultiError is an error wrapping multiple validation errors
// returned by CreditCard.ValidateAll() if the designated constraints aren't met.
type CreditCardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditCardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditCardMultiError) AllErrors() []error { return m }

// CreditCardValidationError is the validation error returned by
// CreditCard.Validate if the designated constraints aren't met.
type CreditCardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditCardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditCardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditCardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditCardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditCardValidationError) ErrorName() string { return "CreditCardValidationError" }

// Error satisfies the builtin error interface
func (e CreditCardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditCardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditCardValidationError{}

// Validate checks the field values on PaymentMethodOther with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaymentMethodOther) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentMethodOther with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaymentMethodOtherMultiError, or nil if none found.
func (m *PaymentMethodOther) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentMethodOther) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PaymentMethodOtherMultiError(errors)
	}

	return nil
}

// PaymentMethodOtherMultiError is an error wrapping multiple validation errors
// returned by PaymentMethodOther.ValidateAll() if the designated constraints
// aren't met.
type PaymentMethodOtherMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentMethodOtherMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentMethodOtherMultiError) AllErrors() []error { return m }

// PaymentMethodOtherValidationError is the validation error returned by
// PaymentMethodOther.Validate if the designated constraints aren't met.
type PaymentMethodOtherValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentMethodOtherValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentMethodOtherValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentMethodOtherValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentMethodOtherValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentMethodOtherValidationError) ErrorName() string {
	return "PaymentMethodOtherValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentMethodOtherValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentMethodOther.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentMethodOtherValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentMethodOtherValidationError{}

// Validate checks the field values on BillingRateFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BillingRateFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingRateFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingRateFilterMultiError, or nil if none found.
func (m *BillingRateFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingRateFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if m.ProductId != nil {
		// no validation rules for ProductId
	}

	if len(errors) > 0 {
		return BillingRateFilterMultiError(errors)
	}

	return nil
}

// BillingRateFilterMultiError is an error wrapping multiple validation errors
// returned by BillingRateFilter.ValidateAll() if the designated constraints
// aren't met.
type BillingRateFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingRateFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingRateFilterMultiError) AllErrors() []error { return m }

// BillingRateFilterValidationError is the validation error returned by
// BillingRateFilter.Validate if the designated constraints aren't met.
type BillingRateFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingRateFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingRateFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingRateFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingRateFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingRateFilterValidationError) ErrorName() string {
	return "BillingRateFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingRateFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingRateFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingRateFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingRateFilterValidationError{}

// Validate checks the field values on BillingRate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingRate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingRateMultiError, or
// nil if none found.
func (m *BillingRate) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for ProductId

	if all {
		switch v := interface{}(m.GetRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingRateValidationError{
					field:  "Rate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingRateValidationError{
					field:  "Rate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingRateValidationError{
				field:  "Rate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillingRateMultiError(errors)
	}

	return nil
}

// BillingRateMultiError is an error wrapping multiple validation errors
// returned by BillingRate.ValidateAll() if the designated constraints aren't met.
type BillingRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingRateMultiError) AllErrors() []error { return m }

// BillingRateValidationError is the validation error returned by
// BillingRate.Validate if the designated constraints aren't met.
type BillingRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingRateValidationError) ErrorName() string { return "BillingRateValidationError" }

// Error satisfies the builtin error interface
func (e BillingRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingRateValidationError{}

// Validate checks the field values on BillingMigratedCredit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingMigratedCredit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingMigratedCredit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingMigratedCreditMultiError, or nil if none found.
func (m *BillingMigratedCredit) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingMigratedCredit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return BillingMigratedCreditMultiError(errors)
	}

	return nil
}

// BillingMigratedCreditMultiError is an error wrapping multiple validation
// errors returned by BillingMigratedCredit.ValidateAll() if the designated
// constraints aren't met.
type BillingMigratedCreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingMigratedCreditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingMigratedCreditMultiError) AllErrors() []error { return m }

// BillingMigratedCreditValidationError is the validation error returned by
// BillingMigratedCredit.Validate if the designated constraints aren't met.
type BillingMigratedCreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingMigratedCreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingMigratedCreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingMigratedCreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingMigratedCreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingMigratedCreditValidationError) ErrorName() string {
	return "BillingMigratedCreditValidationError"
}

// Error satisfies the builtin error interface
func (e BillingMigratedCreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingMigratedCredit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingMigratedCreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingMigratedCreditValidationError{}

// Validate checks the field values on BillingUnappliedCredit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingUnappliedCredit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingUnappliedCredit with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingUnappliedCreditMultiError, or nil if none found.
func (m *BillingUnappliedCredit) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingUnappliedCredit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for RemainingAmount

	if all {
		switch v := interface{}(m.GetExpiration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingUnappliedCreditValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingUnappliedCreditValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingUnappliedCreditValidationError{
				field:  "Expiration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillingUnappliedCreditMultiError(errors)
	}

	return nil
}

// BillingUnappliedCreditMultiError is an error wrapping multiple validation
// errors returned by BillingUnappliedCredit.ValidateAll() if the designated
// constraints aren't met.
type BillingUnappliedCreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingUnappliedCreditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingUnappliedCreditMultiError) AllErrors() []error { return m }

// BillingUnappliedCreditValidationError is the validation error returned by
// BillingUnappliedCredit.Validate if the designated constraints aren't met.
type BillingUnappliedCreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingUnappliedCreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingUnappliedCreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingUnappliedCreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingUnappliedCreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingUnappliedCreditValidationError) ErrorName() string {
	return "BillingUnappliedCreditValidationError"
}

// Error satisfies the builtin error interface
func (e BillingUnappliedCreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingUnappliedCredit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingUnappliedCreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingUnappliedCreditValidationError{}

// Validate checks the field values on BillingCredit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingCredit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCredit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingCreditMultiError, or
// nil if none found.
func (m *BillingCredit) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCredit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCreditValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCreditValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCreditValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpiration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCreditValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCreditValidationError{
					field:  "Expiration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCreditValidationError{
				field:  "Expiration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CloudAccountId

	// no validation rules for Reason

	// no validation rules for OriginalAmount

	// no validation rules for RemainingAmount

	// no validation rules for CouponCode

	// no validation rules for AmountUsed

	if len(errors) > 0 {
		return BillingCreditMultiError(errors)
	}

	return nil
}

// BillingCreditMultiError is an error wrapping multiple validation errors
// returned by BillingCredit.ValidateAll() if the designated constraints
// aren't met.
type BillingCreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCreditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCreditMultiError) AllErrors() []error { return m }

// BillingCreditValidationError is the validation error returned by
// BillingCredit.Validate if the designated constraints aren't met.
type BillingCreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCreditValidationError) ErrorName() string { return "BillingCreditValidationError" }

// Error satisfies the builtin error interface
func (e BillingCreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCredit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCreditValidationError{}

// Validate checks the field values on BillingUnappliedCreditBalance with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingUnappliedCreditBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingUnappliedCreditBalance with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BillingUnappliedCreditBalanceMultiError, or nil if none found.
func (m *BillingUnappliedCreditBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingUnappliedCreditBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UnappliedAmount

	if len(errors) > 0 {
		return BillingUnappliedCreditBalanceMultiError(errors)
	}

	return nil
}

// BillingUnappliedCreditBalanceMultiError is an error wrapping multiple
// validation errors returned by BillingUnappliedCreditBalance.ValidateAll()
// if the designated constraints aren't met.
type BillingUnappliedCreditBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingUnappliedCreditBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingUnappliedCreditBalanceMultiError) AllErrors() []error { return m }

// BillingUnappliedCreditBalanceValidationError is the validation error
// returned by BillingUnappliedCreditBalance.Validate if the designated
// constraints aren't met.
type BillingUnappliedCreditBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingUnappliedCreditBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingUnappliedCreditBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingUnappliedCreditBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingUnappliedCreditBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingUnappliedCreditBalanceValidationError) ErrorName() string {
	return "BillingUnappliedCreditBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e BillingUnappliedCreditBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingUnappliedCreditBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingUnappliedCreditBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingUnappliedCreditBalanceValidationError{}

// Validate checks the field values on BillingCreditFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCreditFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCreditFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCreditFilterMultiError, or nil if none found.
func (m *BillingCreditFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCreditFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if m.History != nil {
		// no validation rules for History
	}

	if len(errors) > 0 {
		return BillingCreditFilterMultiError(errors)
	}

	return nil
}

// BillingCreditFilterMultiError is an error wrapping multiple validation
// errors returned by BillingCreditFilter.ValidateAll() if the designated
// constraints aren't met.
type BillingCreditFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCreditFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCreditFilterMultiError) AllErrors() []error { return m }

// BillingCreditFilterValidationError is the validation error returned by
// BillingCreditFilter.Validate if the designated constraints aren't met.
type BillingCreditFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCreditFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCreditFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCreditFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCreditFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCreditFilterValidationError) ErrorName() string {
	return "BillingCreditFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCreditFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCreditFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCreditFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCreditFilterValidationError{}

// Validate checks the field values on BillingCreditResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCreditResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCreditResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCreditResponseMultiError, or nil if none found.
func (m *BillingCreditResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCreditResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalRemainingAmount

	// no validation rules for TotalUsedAmount

	// no validation rules for TotalUnAppliedAmount

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCreditResponseValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCreditResponseValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCreditResponseValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpirationDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCreditResponseValidationError{
					field:  "ExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCreditResponseValidationError{
					field:  "ExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpirationDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCreditResponseValidationError{
				field:  "ExpirationDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCredits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingCreditResponseValidationError{
						field:  fmt.Sprintf("Credits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingCreditResponseValidationError{
						field:  fmt.Sprintf("Credits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingCreditResponseValidationError{
					field:  fmt.Sprintf("Credits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BillingCreditResponseMultiError(errors)
	}

	return nil
}

// BillingCreditResponseMultiError is an error wrapping multiple validation
// errors returned by BillingCreditResponse.ValidateAll() if the designated
// constraints aren't met.
type BillingCreditResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCreditResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCreditResponseMultiError) AllErrors() []error { return m }

// BillingCreditResponseValidationError is the validation error returned by
// BillingCreditResponse.Validate if the designated constraints aren't met.
type BillingCreditResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCreditResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCreditResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCreditResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCreditResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCreditResponseValidationError) ErrorName() string {
	return "BillingCreditResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCreditResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCreditResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCreditResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCreditResponseValidationError{}

// Validate checks the field values on BillingCouponFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCouponFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCouponFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCouponFilterMultiError, or nil if none found.
func (m *BillingCouponFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCouponFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Code != nil {
		// no validation rules for Code
	}

	if m.Redeemed != nil {

		if all {
			switch v := interface{}(m.GetRedeemed()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingCouponFilterValidationError{
						field:  "Redeemed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingCouponFilterValidationError{
						field:  "Redeemed",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedeemed()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingCouponFilterValidationError{
					field:  "Redeemed",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Creator != nil {
		// no validation rules for Creator
	}

	if len(errors) > 0 {
		return BillingCouponFilterMultiError(errors)
	}

	return nil
}

// BillingCouponFilterMultiError is an error wrapping multiple validation
// errors returned by BillingCouponFilter.ValidateAll() if the designated
// constraints aren't met.
type BillingCouponFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponFilterMultiError) AllErrors() []error { return m }

// BillingCouponFilterValidationError is the validation error returned by
// BillingCouponFilter.Validate if the designated constraints aren't met.
type BillingCouponFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponFilterValidationError) ErrorName() string {
	return "BillingCouponFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCouponFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCouponFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponFilterValidationError{}

// Validate checks the field values on BillingCouponResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCouponResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCouponResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCouponResponseMultiError, or nil if none found.
func (m *BillingCouponResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCouponResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCoupons() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingCouponResponseValidationError{
						field:  fmt.Sprintf("Coupons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingCouponResponseValidationError{
						field:  fmt.Sprintf("Coupons[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingCouponResponseValidationError{
					field:  fmt.Sprintf("Coupons[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRedemptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingCouponResponseValidationError{
						field:  fmt.Sprintf("Redemptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingCouponResponseValidationError{
						field:  fmt.Sprintf("Redemptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingCouponResponseValidationError{
					field:  fmt.Sprintf("Redemptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BillingCouponResponseMultiError(errors)
	}

	return nil
}

// BillingCouponResponseMultiError is an error wrapping multiple validation
// errors returned by BillingCouponResponse.ValidateAll() if the designated
// constraints aren't met.
type BillingCouponResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponResponseMultiError) AllErrors() []error { return m }

// BillingCouponResponseValidationError is the validation error returned by
// BillingCouponResponse.Validate if the designated constraints aren't met.
type BillingCouponResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponResponseValidationError) ErrorName() string {
	return "BillingCouponResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCouponResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCouponResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponResponseValidationError{}

// Validate checks the field values on BillingCouponRedeem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCouponRedeem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCouponRedeem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCouponRedeemMultiError, or nil if none found.
func (m *BillingCouponRedeem) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCouponRedeem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return BillingCouponRedeemMultiError(errors)
	}

	return nil
}

// BillingCouponRedeemMultiError is an error wrapping multiple validation
// errors returned by BillingCouponRedeem.ValidateAll() if the designated
// constraints aren't met.
type BillingCouponRedeemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponRedeemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponRedeemMultiError) AllErrors() []error { return m }

// BillingCouponRedeemValidationError is the validation error returned by
// BillingCouponRedeem.Validate if the designated constraints aren't met.
type BillingCouponRedeemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponRedeemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponRedeemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponRedeemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponRedeemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponRedeemValidationError) ErrorName() string {
	return "BillingCouponRedeemValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCouponRedeemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCouponRedeem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponRedeemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponRedeemValidationError{}

// Validate checks the field values on BillingCouponDisable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCouponDisable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCouponDisable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCouponDisableMultiError, or nil if none found.
func (m *BillingCouponDisable) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCouponDisable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if all {
		switch v := interface{}(m.GetDisabled()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponDisableValidationError{
					field:  "Disabled",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponDisableValidationError{
					field:  "Disabled",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisabled()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponDisableValidationError{
				field:  "Disabled",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillingCouponDisableMultiError(errors)
	}

	return nil
}

// BillingCouponDisableMultiError is an error wrapping multiple validation
// errors returned by BillingCouponDisable.ValidateAll() if the designated
// constraints aren't met.
type BillingCouponDisableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponDisableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponDisableMultiError) AllErrors() []error { return m }

// BillingCouponDisableValidationError is the validation error returned by
// BillingCouponDisable.Validate if the designated constraints aren't met.
type BillingCouponDisableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponDisableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponDisableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponDisableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponDisableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponDisableValidationError) ErrorName() string {
	return "BillingCouponDisableValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCouponDisableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCouponDisable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponDisableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponDisableValidationError{}

// Validate checks the field values on BillingCouponCreate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCouponCreate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCouponCreate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCouponCreateMultiError, or nil if none found.
func (m *BillingCouponCreate) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCouponCreate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponCreateValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponCreateValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponCreateValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpires()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponCreateValidationError{
					field:  "Expires",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponCreateValidationError{
					field:  "Expires",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpires()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponCreateValidationError{
				field:  "Expires",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Amount

	// no validation rules for NumUses

	// no validation rules for Creator

	if m.IsStandard != nil {
		// no validation rules for IsStandard
	}

	if len(errors) > 0 {
		return BillingCouponCreateMultiError(errors)
	}

	return nil
}

// BillingCouponCreateMultiError is an error wrapping multiple validation
// errors returned by BillingCouponCreate.ValidateAll() if the designated
// constraints aren't met.
type BillingCouponCreateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponCreateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponCreateMultiError) AllErrors() []error { return m }

// BillingCouponCreateValidationError is the validation error returned by
// BillingCouponCreate.Validate if the designated constraints aren't met.
type BillingCouponCreateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponCreateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponCreateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponCreateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponCreateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponCreateValidationError) ErrorName() string {
	return "BillingCouponCreateValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCouponCreateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCouponCreate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponCreateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponCreateValidationError{}

// Validate checks the field values on BillingCoupon with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingCoupon) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCoupon with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingCouponMultiError, or
// nil if none found.
func (m *BillingCoupon) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCoupon) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Creator

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpires()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Expires",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Expires",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpires()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponValidationError{
				field:  "Expires",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDisabled()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Disabled",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponValidationError{
					field:  "Disabled",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDisabled()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponValidationError{
				field:  "Disabled",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Amount

	// no validation rules for NumUses

	// no validation rules for NumRedeemed

	for idx, item := range m.GetRedemptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingCouponValidationError{
						field:  fmt.Sprintf("Redemptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingCouponValidationError{
						field:  fmt.Sprintf("Redemptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingCouponValidationError{
					field:  fmt.Sprintf("Redemptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.IsStandard != nil {
		// no validation rules for IsStandard
	}

	if len(errors) > 0 {
		return BillingCouponMultiError(errors)
	}

	return nil
}

// BillingCouponMultiError is an error wrapping multiple validation errors
// returned by BillingCoupon.ValidateAll() if the designated constraints
// aren't met.
type BillingCouponMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponMultiError) AllErrors() []error { return m }

// BillingCouponValidationError is the validation error returned by
// BillingCoupon.Validate if the designated constraints aren't met.
type BillingCouponValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponValidationError) ErrorName() string { return "BillingCouponValidationError" }

// Error satisfies the builtin error interface
func (e BillingCouponValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCoupon.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponValidationError{}

// Validate checks the field values on BillingCouponRedemption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingCouponRedemption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingCouponRedemption with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingCouponRedemptionMultiError, or nil if none found.
func (m *BillingCouponRedemption) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingCouponRedemption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for CloudAccountId

	if all {
		switch v := interface{}(m.GetRedeemed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingCouponRedemptionValidationError{
					field:  "Redeemed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingCouponRedemptionValidationError{
					field:  "Redeemed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedeemed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingCouponRedemptionValidationError{
				field:  "Redeemed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Installed

	// no validation rules for Creator

	if len(errors) > 0 {
		return BillingCouponRedemptionMultiError(errors)
	}

	return nil
}

// BillingCouponRedemptionMultiError is an error wrapping multiple validation
// errors returned by BillingCouponRedemption.ValidateAll() if the designated
// constraints aren't met.
type BillingCouponRedemptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingCouponRedemptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingCouponRedemptionMultiError) AllErrors() []error { return m }

// BillingCouponRedemptionValidationError is the validation error returned by
// BillingCouponRedemption.Validate if the designated constraints aren't met.
type BillingCouponRedemptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingCouponRedemptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingCouponRedemptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingCouponRedemptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingCouponRedemptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingCouponRedemptionValidationError) ErrorName() string {
	return "BillingCouponRedemptionValidationError"
}

// Error satisfies the builtin error interface
func (e BillingCouponRedemptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingCouponRedemption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingCouponRedemptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingCouponRedemptionValidationError{}

// Validate checks the field values on BillingInvoiceFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingInvoiceFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingInvoiceFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingInvoiceFilterMultiError, or nil if none found.
func (m *BillingInvoiceFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingInvoiceFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.SearchStart != nil {

		if all {
			switch v := interface{}(m.GetSearchStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingInvoiceFilterValidationError{
						field:  "SearchStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingInvoiceFilterValidationError{
						field:  "SearchStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSearchStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingInvoiceFilterValidationError{
					field:  "SearchStart",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SearchEnd != nil {

		if all {
			switch v := interface{}(m.GetSearchEnd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingInvoiceFilterValidationError{
						field:  "SearchEnd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingInvoiceFilterValidationError{
						field:  "SearchEnd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSearchEnd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingInvoiceFilterValidationError{
					field:  "SearchEnd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BillingInvoiceFilterMultiError(errors)
	}

	return nil
}

// BillingInvoiceFilterMultiError is an error wrapping multiple validation
// errors returned by BillingInvoiceFilter.ValidateAll() if the designated
// constraints aren't met.
type BillingInvoiceFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingInvoiceFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingInvoiceFilterMultiError) AllErrors() []error { return m }

// BillingInvoiceFilterValidationError is the validation error returned by
// BillingInvoiceFilter.Validate if the designated constraints aren't met.
type BillingInvoiceFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingInvoiceFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingInvoiceFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingInvoiceFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingInvoiceFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingInvoiceFilterValidationError) ErrorName() string {
	return "BillingInvoiceFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingInvoiceFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingInvoiceFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingInvoiceFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingInvoiceFilterValidationError{}

// Validate checks the field values on BillingInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingInvoiceResponseMultiError, or nil if none found.
func (m *BillingInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingInvoiceResponseValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingInvoiceResponseValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingInvoiceResponseValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInvoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingInvoiceResponseValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingInvoiceResponseValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingInvoiceResponseValidationError{
					field:  fmt.Sprintf("Invoices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BillingInvoiceResponseMultiError(errors)
	}

	return nil
}

// BillingInvoiceResponseMultiError is an error wrapping multiple validation
// errors returned by BillingInvoiceResponse.ValidateAll() if the designated
// constraints aren't met.
type BillingInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingInvoiceResponseMultiError) AllErrors() []error { return m }

// BillingInvoiceResponseValidationError is the validation error returned by
// BillingInvoiceResponse.Validate if the designated constraints aren't met.
type BillingInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingInvoiceResponseValidationError) ErrorName() string {
	return "BillingInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BillingInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingInvoiceResponseValidationError{}

// Validate checks the field values on InvoiceDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceDetailMultiError, or
// nil if none found.
func (m *InvoiceDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProductId

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceDetailValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceDetailValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceDetailValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceDetailValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceDetailValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceDetailValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceDetailValidationError{
					field:  "Rate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceDetailValidationError{
					field:  "Rate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceDetailValidationError{
				field:  "Rate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Usage

	// no validation rules for Amount

	if len(errors) > 0 {
		return InvoiceDetailMultiError(errors)
	}

	return nil
}

// InvoiceDetailMultiError is an error wrapping multiple validation errors
// returned by InvoiceDetail.ValidateAll() if the designated constraints
// aren't met.
type InvoiceDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceDetailMultiError) AllErrors() []error { return m }

// InvoiceDetailValidationError is the validation error returned by
// InvoiceDetail.Validate if the designated constraints aren't met.
type InvoiceDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceDetailValidationError) ErrorName() string { return "InvoiceDetailValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceDetailValidationError{}

// Validate checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InvoiceMultiError, or nil if none found.
func (m *Invoice) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Id

	// no validation rules for Total

	// no validation rules for Paid

	// no validation rules for Due

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoiceDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "InvoiceDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "InvoiceDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "InvoiceDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "DueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotifyDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "NotifyDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "NotifyDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotifyDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "NotifyDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaidDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaidDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "PaidDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BillingPeriod

	// no validation rules for Status

	// no validation rules for StatementLink

	// no validation rules for DownloadLink

	if len(errors) > 0 {
		return InvoiceMultiError(errors)
	}

	return nil
}

// InvoiceMultiError is an error wrapping multiple validation errors returned
// by Invoice.ValidateAll() if the designated constraints aren't met.
type InvoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceMultiError) AllErrors() []error { return m }

// InvoiceValidationError is the validation error returned by Invoice.Validate
// if the designated constraints aren't met.
type InvoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceValidationError) ErrorName() string { return "InvoiceValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceValidationError{}

// Validate checks the field values on InvoiceId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceIdMultiError, or nil
// if none found.
func (m *InvoiceId) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for InvoiceId

	if len(errors) > 0 {
		return InvoiceIdMultiError(errors)
	}

	return nil
}

// InvoiceIdMultiError is an error wrapping multiple validation errors returned
// by InvoiceId.ValidateAll() if the designated constraints aren't met.
type InvoiceIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceIdMultiError) AllErrors() []error { return m }

// InvoiceIdValidationError is the validation error returned by
// InvoiceId.Validate if the designated constraints aren't met.
type InvoiceIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceIdValidationError) ErrorName() string { return "InvoiceIdValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceIdValidationError{}

// Validate checks the field values on Statement with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Statement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Statement with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatementMultiError, or nil
// if none found.
func (m *Statement) ValidateAll() error {
	return m.validate(true)
}

func (m *Statement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MimeType

	// no validation rules for Statement

	if len(errors) > 0 {
		return StatementMultiError(errors)
	}

	return nil
}

// StatementMultiError is an error wrapping multiple validation errors returned
// by Statement.ValidateAll() if the designated constraints aren't met.
type StatementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatementMultiError) AllErrors() []error { return m }

// StatementValidationError is the validation error returned by
// Statement.Validate if the designated constraints aren't met.
type StatementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatementValidationError) ErrorName() string { return "StatementValidationError" }

// Error satisfies the builtin error interface
func (e StatementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatementValidationError{}

// Validate checks the field values on PrePaymentRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PrePaymentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrePaymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrePaymentRequestMultiError, or nil if none found.
func (m *PrePaymentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PrePaymentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return PrePaymentRequestMultiError(errors)
	}

	return nil
}

// PrePaymentRequestMultiError is an error wrapping multiple validation errors
// returned by PrePaymentRequest.ValidateAll() if the designated constraints
// aren't met.
type PrePaymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrePaymentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrePaymentRequestMultiError) AllErrors() []error { return m }

// PrePaymentRequestValidationError is the validation error returned by
// PrePaymentRequest.Validate if the designated constraints aren't met.
type PrePaymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrePaymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrePaymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrePaymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrePaymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrePaymentRequestValidationError) ErrorName() string {
	return "PrePaymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PrePaymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrePaymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrePaymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrePaymentRequestValidationError{}

// Validate checks the field values on PrePaymentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrePaymentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrePaymentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrePaymentResponseMultiError, or nil if none found.
func (m *PrePaymentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PrePaymentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for DirectPostUrl

	// no validation rules for FunctionMode

	if len(errors) > 0 {
		return PrePaymentResponseMultiError(errors)
	}

	return nil
}

// PrePaymentResponseMultiError is an error wrapping multiple validation errors
// returned by PrePaymentResponse.ValidateAll() if the designated constraints
// aren't met.
type PrePaymentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrePaymentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrePaymentResponseMultiError) AllErrors() []error { return m }

// PrePaymentResponseValidationError is the validation error returned by
// PrePaymentResponse.Validate if the designated constraints aren't met.
type PrePaymentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrePaymentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrePaymentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrePaymentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrePaymentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrePaymentResponseValidationError) ErrorName() string {
	return "PrePaymentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PrePaymentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrePaymentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrePaymentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrePaymentResponseValidationError{}

// Validate checks the field values on PostPaymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostPaymentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostPaymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostPaymentRequestMultiError, or nil if none found.
func (m *PostPaymentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostPaymentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for PrimaryPaymentMethodNo

	if len(errors) > 0 {
		return PostPaymentRequestMultiError(errors)
	}

	return nil
}

// PostPaymentRequestMultiError is an error wrapping multiple validation errors
// returned by PostPaymentRequest.ValidateAll() if the designated constraints
// aren't met.
type PostPaymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostPaymentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostPaymentRequestMultiError) AllErrors() []error { return m }

// PostPaymentRequestValidationError is the validation error returned by
// PostPaymentRequest.Validate if the designated constraints aren't met.
type PostPaymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostPaymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostPaymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostPaymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostPaymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostPaymentRequestValidationError) ErrorName() string {
	return "PostPaymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PostPaymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostPaymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostPaymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostPaymentRequestValidationError{}

// Validate checks the field values on BillingPaidInstanceFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingPaidInstanceFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingPaidInstanceFilter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingPaidInstanceFilterMultiError, or nil if none found.
func (m *BillingPaidInstanceFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingPaidInstanceFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if len(errors) > 0 {
		return BillingPaidInstanceFilterMultiError(errors)
	}

	return nil
}

// BillingPaidInstanceFilterMultiError is an error wrapping multiple validation
// errors returned by BillingPaidInstanceFilter.ValidateAll() if the
// designated constraints aren't met.
type BillingPaidInstanceFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingPaidInstanceFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingPaidInstanceFilterMultiError) AllErrors() []error { return m }

// BillingPaidInstanceFilterValidationError is the validation error returned by
// BillingPaidInstanceFilter.Validate if the designated constraints aren't met.
type BillingPaidInstanceFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingPaidInstanceFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingPaidInstanceFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingPaidInstanceFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingPaidInstanceFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingPaidInstanceFilterValidationError) ErrorName() string {
	return "BillingPaidInstanceFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingPaidInstanceFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingPaidInstanceFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingPaidInstanceFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingPaidInstanceFilterValidationError{}

// Validate checks the field values on BillingPaidInstanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingPaidInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingPaidInstanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingPaidInstanceResponseMultiError, or nil if none found.
func (m *BillingPaidInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingPaidInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BillingPaidInstanceResponseMultiError(errors)
	}

	return nil
}

// BillingPaidInstanceResponseMultiError is an error wrapping multiple
// validation errors returned by BillingPaidInstanceResponse.ValidateAll() if
// the designated constraints aren't met.
type BillingPaidInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingPaidInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingPaidInstanceResponseMultiError) AllErrors() []error { return m }

// BillingPaidInstanceResponseValidationError is the validation error returned
// by BillingPaidInstanceResponse.Validate if the designated constraints
// aren't met.
type BillingPaidInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingPaidInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingPaidInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingPaidInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingPaidInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingPaidInstanceResponseValidationError) ErrorName() string {
	return "BillingPaidInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BillingPaidInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingPaidInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingPaidInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingPaidInstanceResponseValidationError{}

// Validate checks the field values on BillingUsageFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingUsageFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingUsageFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingUsageFilterMultiError, or nil if none found.
func (m *BillingUsageFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingUsageFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	if m.SearchStart != nil {

		if all {
			switch v := interface{}(m.GetSearchStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingUsageFilterValidationError{
						field:  "SearchStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingUsageFilterValidationError{
						field:  "SearchStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSearchStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingUsageFilterValidationError{
					field:  "SearchStart",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SearchEnd != nil {

		if all {
			switch v := interface{}(m.GetSearchEnd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingUsageFilterValidationError{
						field:  "SearchEnd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingUsageFilterValidationError{
						field:  "SearchEnd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSearchEnd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingUsageFilterValidationError{
					field:  "SearchEnd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RegionName != nil {
		// no validation rules for RegionName
	}

	if len(errors) > 0 {
		return BillingUsageFilterMultiError(errors)
	}

	return nil
}

// BillingUsageFilterMultiError is an error wrapping multiple validation errors
// returned by BillingUsageFilter.ValidateAll() if the designated constraints
// aren't met.
type BillingUsageFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingUsageFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingUsageFilterMultiError) AllErrors() []error { return m }

// BillingUsageFilterValidationError is the validation error returned by
// BillingUsageFilter.Validate if the designated constraints aren't met.
type BillingUsageFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingUsageFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingUsageFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingUsageFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingUsageFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingUsageFilterValidationError) ErrorName() string {
	return "BillingUsageFilterValidationError"
}

// Error satisfies the builtin error interface
func (e BillingUsageFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingUsageFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingUsageFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingUsageFilterValidationError{}

// Validate checks the field values on BillingUsageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingUsageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingUsageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingUsageResponseMultiError, or nil if none found.
func (m *BillingUsageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingUsageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalAmount

	if all {
		switch v := interface{}(m.GetLastUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingUsageResponseValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingUsageResponseValidationError{
					field:  "LastUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingUsageResponseValidationError{
				field:  "LastUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DownloadUrl

	// no validation rules for Period

	for idx, item := range m.GetUsages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BillingUsageResponseValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BillingUsageResponseValidationError{
						field:  fmt.Sprintf("Usages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BillingUsageResponseValidationError{
					field:  fmt.Sprintf("Usages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalUsage

	if len(errors) > 0 {
		return BillingUsageResponseMultiError(errors)
	}

	return nil
}

// BillingUsageResponseMultiError is an error wrapping multiple validation
// errors returned by BillingUsageResponse.ValidateAll() if the designated
// constraints aren't met.
type BillingUsageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingUsageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingUsageResponseMultiError) AllErrors() []error { return m }

// BillingUsageResponseValidationError is the validation error returned by
// BillingUsageResponse.Validate if the designated constraints aren't met.
type BillingUsageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingUsageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingUsageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingUsageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingUsageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingUsageResponseValidationError) ErrorName() string {
	return "BillingUsageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BillingUsageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingUsageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingUsageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingUsageResponseValidationError{}

// Validate checks the field values on BillingUsage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingUsage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingUsage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingUsageMultiError, or
// nil if none found.
func (m *BillingUsage) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingUsage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for ProductType

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingUsageValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingUsageValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingUsageValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingUsageValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingUsageValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingUsageValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MinsUsed

	// no validation rules for Amount

	// no validation rules for Rate

	// no validation rules for RegionName

	if all {
		switch v := interface{}(m.GetBillingUsageMetrics()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingUsageValidationError{
					field:  "BillingUsageMetrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingUsageValidationError{
					field:  "BillingUsageMetrics",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBillingUsageMetrics()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingUsageValidationError{
				field:  "BillingUsageMetrics",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProductFamily

	if len(errors) > 0 {
		return BillingUsageMultiError(errors)
	}

	return nil
}

// BillingUsageMultiError is an error wrapping multiple validation errors
// returned by BillingUsage.ValidateAll() if the designated constraints aren't met.
type BillingUsageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingUsageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingUsageMultiError) AllErrors() []error { return m }

// BillingUsageValidationError is the validation error returned by
// BillingUsage.Validate if the designated constraints aren't met.
type BillingUsageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingUsageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingUsageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingUsageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingUsageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingUsageValidationError) ErrorName() string { return "BillingUsageValidationError" }

// Error satisfies the builtin error interface
func (e BillingUsageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingUsage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingUsageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingUsageValidationError{}

// Validate checks the field values on BillingUsageMetrics with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BillingUsageMetrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingUsageMetrics with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BillingUsageMetricsMultiError, or nil if none found.
func (m *BillingUsageMetrics) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingUsageMetrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UsageQuantity

	// no validation rules for UsageUnitName

	// no validation rules for UsageQuantityUnitName

	if len(errors) > 0 {
		return BillingUsageMetricsMultiError(errors)
	}

	return nil
}

// BillingUsageMetricsMultiError is an error wrapping multiple validation
// errors returned by BillingUsageMetrics.ValidateAll() if the designated
// constraints aren't met.
type BillingUsageMetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingUsageMetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingUsageMetricsMultiError) AllErrors() []error { return m }

// BillingUsageMetricsValidationError is the validation error returned by
// BillingUsageMetrics.Validate if the designated constraints aren't met.
type BillingUsageMetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingUsageMetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingUsageMetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingUsageMetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingUsageMetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingUsageMetricsValidationError) ErrorName() string {
	return "BillingUsageMetricsValidationError"
}

// Error satisfies the builtin error interface
func (e BillingUsageMetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingUsageMetrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingUsageMetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingUsageMetricsValidationError{}

// Validate checks the field values on SchedulerAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SchedulerAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchedulerAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SchedulerActionMultiError, or nil if none found.
func (m *SchedulerAction) ValidateAll() error {
	return m.validate(true)
}

func (m *SchedulerAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Action

	if len(errors) > 0 {
		return SchedulerActionMultiError(errors)
	}

	return nil
}

// SchedulerActionMultiError is an error wrapping multiple validation errors
// returned by SchedulerAction.ValidateAll() if the designated constraints
// aren't met.
type SchedulerActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchedulerActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchedulerActionMultiError) AllErrors() []error { return m }

// SchedulerActionValidationError is the validation error returned by
// SchedulerAction.Validate if the designated constraints aren't met.
type SchedulerActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchedulerActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchedulerActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchedulerActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchedulerActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchedulerActionValidationError) ErrorName() string { return "SchedulerActionValidationError" }

// Error satisfies the builtin error interface
func (e SchedulerActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedulerAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchedulerActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchedulerActionValidationError{}

// Validate checks the field values on InstanceQuotas with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceQuotas) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceQuotas with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceQuotasMultiError,
// or nil if none found.
func (m *InstanceQuotas) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceQuotas) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceType

	// no validation rules for Limit

	if len(errors) > 0 {
		return InstanceQuotasMultiError(errors)
	}

	return nil
}

// InstanceQuotasMultiError is an error wrapping multiple validation errors
// returned by InstanceQuotas.ValidateAll() if the designated constraints
// aren't met.
type InstanceQuotasMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceQuotasMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceQuotasMultiError) AllErrors() []error { return m }

// InstanceQuotasValidationError is the validation error returned by
// InstanceQuotas.Validate if the designated constraints aren't met.
type InstanceQuotasValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceQuotasValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceQuotasValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceQuotasValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceQuotasValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceQuotasValidationError) ErrorName() string { return "InstanceQuotasValidationError" }

// Error satisfies the builtin error interface
func (e InstanceQuotasValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceQuotas.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceQuotasValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceQuotasValidationError{}

// Validate checks the field values on DeactivateInstances with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeactivateInstances) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeactivateInstances with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivateInstancesMultiError, or nil if none found.
func (m *DeactivateInstances) ValidateAll() error {
	return m.validate(true)
}

func (m *DeactivateInstances) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	for idx, item := range m.GetQuotas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeactivateInstancesValidationError{
						field:  fmt.Sprintf("Quotas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeactivateInstancesValidationError{
						field:  fmt.Sprintf("Quotas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeactivateInstancesValidationError{
					field:  fmt.Sprintf("Quotas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeactivateInstancesMultiError(errors)
	}

	return nil
}

// DeactivateInstancesMultiError is an error wrapping multiple validation
// errors returned by DeactivateInstances.ValidateAll() if the designated
// constraints aren't met.
type DeactivateInstancesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivateInstancesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivateInstancesMultiError) AllErrors() []error { return m }

// DeactivateInstancesValidationError is the validation error returned by
// DeactivateInstances.Validate if the designated constraints aren't met.
type DeactivateInstancesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivateInstancesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivateInstancesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivateInstancesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivateInstancesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivateInstancesValidationError) ErrorName() string {
	return "DeactivateInstancesValidationError"
}

// Error satisfies the builtin error interface
func (e DeactivateInstancesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivateInstances.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivateInstancesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivateInstancesValidationError{}

// Validate checks the field values on DeactivateAccounts with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeactivateAccounts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeactivateAccounts with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivateAccountsMultiError, or nil if none found.
func (m *DeactivateAccounts) ValidateAll() error {
	return m.validate(true)
}

func (m *DeactivateAccounts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CloudAccountId

	// no validation rules for Email

	if all {
		switch v := interface{}(m.GetCreditsDepleted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeactivateAccountsValidationError{
					field:  "CreditsDepleted",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeactivateAccountsValidationError{
					field:  "CreditsDepleted",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreditsDepleted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeactivateAccountsValidationError{
				field:  "CreditsDepleted",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeactivateAccountsMultiError(errors)
	}

	return nil
}

// DeactivateAccountsMultiError is an error wrapping multiple validation errors
// returned by DeactivateAccounts.ValidateAll() if the designated constraints
// aren't met.
type DeactivateAccountsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivateAccountsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivateAccountsMultiError) AllErrors() []error { return m }

// DeactivateAccountsValidationError is the validation error returned by
// DeactivateAccounts.Validate if the designated constraints aren't met.
type DeactivateAccountsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivateAccountsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivateAccountsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivateAccountsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivateAccountsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivateAccountsValidationError) ErrorName() string {
	return "DeactivateAccountsValidationError"
}

// Error satisfies the builtin error interface
func (e DeactivateAccountsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivateAccounts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivateAccountsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivateAccountsValidationError{}

// Validate checks the field values on DeactivateInstancesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeactivateInstancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeactivateInstancesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivateInstancesResponseMultiError, or nil if none found.
func (m *DeactivateInstancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeactivateInstancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDeactivationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeactivateInstancesResponseValidationError{
						field:  fmt.Sprintf("DeactivationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeactivateInstancesResponseValidationError{
						field:  fmt.Sprintf("DeactivationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeactivateInstancesResponseValidationError{
					field:  fmt.Sprintf("DeactivationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeactivateInstancesResponseMultiError(errors)
	}

	return nil
}

// DeactivateInstancesResponseMultiError is an error wrapping multiple
// validation errors returned by DeactivateInstancesResponse.ValidateAll() if
// the designated constraints aren't met.
type DeactivateInstancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivateInstancesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivateInstancesResponseMultiError) AllErrors() []error { return m }

// DeactivateInstancesResponseValidationError is the validation error returned
// by DeactivateInstancesResponse.Validate if the designated constraints
// aren't met.
type DeactivateInstancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivateInstancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivateInstancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivateInstancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivateInstancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivateInstancesResponseValidationError) ErrorName() string {
	return "DeactivateInstancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeactivateInstancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivateInstancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivateInstancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivateInstancesResponseValidationError{}

// Validate checks the field values on GetDeactivatedAccountsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDeactivatedAccountsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDeactivatedAccountsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDeactivatedAccountsRequestMultiError, or nil if none found.
func (m *GetDeactivatedAccountsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDeactivatedAccountsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ProductFamily != nil {
		// no validation rules for ProductFamily
	}

	if m.CleanupThreshold != nil {
		// no validation rules for CleanupThreshold
	}

	if m.TradeRestricted != nil {
		// no validation rules for TradeRestricted
	}

	if len(errors) > 0 {
		return GetDeactivatedAccountsRequestMultiError(errors)
	}

	return nil
}

// GetDeactivatedAccountsRequestMultiError is an error wrapping multiple
// validation errors returned by GetDeactivatedAccountsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetDeactivatedAccountsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDeactivatedAccountsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDeactivatedAccountsRequestMultiError) AllErrors() []error { return m }

// GetDeactivatedAccountsRequestValidationError is the validation error
// returned by GetDeactivatedAccountsRequest.Validate if the designated
// constraints aren't met.
type GetDeactivatedAccountsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDeactivatedAccountsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDeactivatedAccountsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDeactivatedAccountsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDeactivatedAccountsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDeactivatedAccountsRequestValidationError) ErrorName() string {
	return "GetDeactivatedAccountsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDeactivatedAccountsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDeactivatedAccountsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDeactivatedAccountsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDeactivatedAccountsRequestValidationError{}
