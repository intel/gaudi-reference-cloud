// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/baremetal_enrollment/myssh (interfaces: SSHManagerAccessor,SSHClientAccessor,SSHSessionAccessor)

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	myssh "github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/baremetal_enrollment/myssh"
	ssh "golang.org/x/crypto/ssh"
)

// MockSSHManagerAccessor is a mock of SSHManagerAccessor interface.
type MockSSHManagerAccessor struct {
	ctrl     *gomock.Controller
	recorder *MockSSHManagerAccessorMockRecorder
}

// MockSSHManagerAccessorMockRecorder is the mock recorder for MockSSHManagerAccessor.
type MockSSHManagerAccessorMockRecorder struct {
	mock *MockSSHManagerAccessor
}

// NewMockSSHManagerAccessor creates a new mock instance.
func NewMockSSHManagerAccessor(ctrl *gomock.Controller) *MockSSHManagerAccessor {
	mock := &MockSSHManagerAccessor{ctrl: ctrl}
	mock.recorder = &MockSSHManagerAccessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSSHManagerAccessor) EXPECT() *MockSSHManagerAccessorMockRecorder {
	return m.recorder
}

// Dial mocks base method.
func (m *MockSSHManagerAccessor) Dial(arg0, arg1 string, arg2 *ssh.ClientConfig) (myssh.SSHClientAccessor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dial", arg0, arg1, arg2)
	ret0, _ := ret[0].(myssh.SSHClientAccessor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Dial indicates an expected call of Dial.
func (mr *MockSSHManagerAccessorMockRecorder) Dial(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dial", reflect.TypeOf((*MockSSHManagerAccessor)(nil).Dial), arg0, arg1, arg2)
}

// MockSSHClientAccessor is a mock of SSHClientAccessor interface.
type MockSSHClientAccessor struct {
	ctrl     *gomock.Controller
	recorder *MockSSHClientAccessorMockRecorder
}

// MockSSHClientAccessorMockRecorder is the mock recorder for MockSSHClientAccessor.
type MockSSHClientAccessorMockRecorder struct {
	mock *MockSSHClientAccessor
}

// NewMockSSHClientAccessor creates a new mock instance.
func NewMockSSHClientAccessor(ctrl *gomock.Controller) *MockSSHClientAccessor {
	mock := &MockSSHClientAccessor{ctrl: ctrl}
	mock.recorder = &MockSSHClientAccessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSSHClientAccessor) EXPECT() *MockSSHClientAccessorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockSSHClientAccessor) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSSHClientAccessorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSSHClientAccessor)(nil).Close))
}

// NewSession mocks base method.
func (m *MockSSHClientAccessor) NewSession() (myssh.SSHSessionAccessor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewSession")
	ret0, _ := ret[0].(myssh.SSHSessionAccessor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewSession indicates an expected call of NewSession.
func (mr *MockSSHClientAccessorMockRecorder) NewSession() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewSession", reflect.TypeOf((*MockSSHClientAccessor)(nil).NewSession))
}

// MockSSHSessionAccessor is a mock of SSHSessionAccessor interface.
type MockSSHSessionAccessor struct {
	ctrl     *gomock.Controller
	recorder *MockSSHSessionAccessorMockRecorder
}

// MockSSHSessionAccessorMockRecorder is the mock recorder for MockSSHSessionAccessor.
type MockSSHSessionAccessorMockRecorder struct {
	mock *MockSSHSessionAccessor
}

// NewMockSSHSessionAccessor creates a new mock instance.
func NewMockSSHSessionAccessor(ctrl *gomock.Controller) *MockSSHSessionAccessor {
	mock := &MockSSHSessionAccessor{ctrl: ctrl}
	mock.recorder = &MockSSHSessionAccessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSSHSessionAccessor) EXPECT() *MockSSHSessionAccessorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockSSHSessionAccessor) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSSHSessionAccessorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSSHSessionAccessor)(nil).Close))
}

// CombinedOutput mocks base method.
func (m *MockSSHSessionAccessor) CombinedOutput(arg0 string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CombinedOutput", arg0)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CombinedOutput indicates an expected call of CombinedOutput.
func (mr *MockSSHSessionAccessorMockRecorder) CombinedOutput(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CombinedOutput", reflect.TypeOf((*MockSSHSessionAccessor)(nil).CombinedOutput), arg0)
}
