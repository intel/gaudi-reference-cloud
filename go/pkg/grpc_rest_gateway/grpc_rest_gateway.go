// INTEL CONFIDENTIAL
// Copyright (C) 2023 Intel Corporation
// Note that when deploying in Kubernetes, the file below must be modified so that Istio routes the paths to this server.
// /deployment/charts/compute-api-server/templates/istio-virtualservice.yaml

package grpc_rest_gateway

import (
	"context"
	"fmt"
	"net"
	"net/http"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/grpcutil"
	"github.com/intel-innersource/frameworks.cloud.devcloud.services.idc/go/pkg/log"
	"google.golang.org/grpc"
)

// This is deprecated. It is only used for integration testing.
// See /go/svc/grpc-rest-gateway/grpc-rest-gateway.go.
type RestService struct {
	// Format should be "localhost:30002"
	TargetAddr string
	// Members should be RegisterXXXHandler functions generated by protoc.
	registerHandlerFunctions [](func(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error)
	listener                 net.Listener
	srv                      *http.Server
	errc                     chan error
}

func New(ctx context.Context, config *Config, listener net.Listener) (*RestService, error) {
	if config.TargetAddr == "" {
		return nil, fmt.Errorf("TargetAddr must be in format 'host:port'")
	}
	return &RestService{
		TargetAddr: config.TargetAddr,
		listener:   listener,
	}, nil
}

func (s *RestService) AddService(f func(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error) {
	s.registerHandlerFunctions = append(s.registerHandlerFunctions, f)
}

// Run service, blocking until an error occurs.
func (s *RestService) Run(ctx context.Context) error {
	if err := s.Start(ctx); err != nil {
		return err
	}
	// Wait for ListenAndServe to return, return error.
	return <-s.errc
}

// Start the service and return when it is running.
func (s *RestService) Start(ctx context.Context) error {
	log := log.FromContext(ctx).WithName("RestService.Start")
	log.Info("BEGIN", "ListenAddr", s.listener.Addr().(*net.TCPAddr).Port, "TargetAddr", s.TargetAddr)
	defer log.Info("END")

	mux := http.NewServeMux()
	mux.HandleFunc("/readyz", readyz)
	mux.HandleFunc("/livez", readyz)

	gwmux := runtime.NewServeMux()
	clientConn, err := grpcutil.NewClient(ctx, s.TargetAddr)
	if err != nil {
		return err
	}
	for _, registerHandler := range s.registerHandlerFunctions {
		if err := registerHandler(ctx, gwmux, clientConn); err != nil {
			return err
		}
	}
	mux.Handle("/", gwmux)

	s.srv = &http.Server{
		Handler: http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {
			mux.ServeHTTP(resp, req)
		}),
	}
	s.errc = make(chan error, 1)
	go func() {
		s.errc <- s.srv.Serve(s.listener)
		close(s.errc)
	}()
	return nil
}

func (s *RestService) Stop(ctx context.Context) error {
	log := log.FromContext(ctx).WithName("RestService.Stop")
	log.Info("BEGIN")
	defer log.Info("END")
	if s != nil && s.srv != nil {
		if err := s.srv.Shutdown(ctx); err != nil {
			return err
		}
	}
	return nil
}

func readyz(resp http.ResponseWriter, req *http.Request) {
	log := log.FromContext(req.Context())
	log.Info("RestService.readyz")
	_, err := fmt.Fprintf(resp, "ok")
	if err != nil {
		log.Error(err, "readyz encountered error")
	}
}
