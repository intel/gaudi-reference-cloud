package util

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

func WriteFileAtomically(fileName string, writer func(io.Writer) error) error {
	tempFile := fileName + ".tmp"
	outf, err := os.OpenFile(tempFile, os.O_WRONLY|os.
		O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	defer os.Remove(tempFile)
	if err = writer(outf); err != nil {
		return err
	}
	if err = outf.Close(); err != nil {
		return err
	}
	if err = os.Rename(tempFile, fileName); err != nil {
		return err
	}
	return nil
}

func WriteGenComment(outf io.Writer, tool string, comment string) error {
	_, err := fmt.Fprintf(outf, "%v Code generated by %v. DO NOT EDIT.\n", comment, tool)
	return err
}

func WriteGenCommentGo(outf io.Writer, tool string) error {
	return WriteGenComment(outf, tool, "//")
}

func getConfigMapHeader(mapName string) string {
	var configMapHeader = `apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "idc-common.fullname" . }}-%%v
  namespace: {{ include "idc-common.namespace" . }}
data:
  %s.rego: |
`
	return fmt.Sprintf(configMapHeader, mapName)
}

func WriteConfigMap(outf io.Writer, tool string, mapName string, content []byte) error {
	if err := WriteGenComment(outf, tool, "#"); err != nil {
		return err
	}
	if _, err := fmt.Fprintf(outf, getConfigMapHeader(mapName), mapName); err != nil {
		return err
	}
	for len(content) > 0 {
		end := bytes.IndexByte(content, '\n')
		if end == -1 {
			end = len(content)
		}
		start := 0
		if end > 0 && !(content[0] == '{' && content[1] == '{') {
			spaces := []byte("    ")
			if _, err := outf.Write(spaces); err != nil {
				return err
			}
			for content[start] == '\t' {
				if _, err := outf.Write(spaces); err != nil {
					return err
				}
				start++
			}
		}
		if _, err := outf.Write(content[start:end]); err != nil {
			return err
		}
		if _, err := outf.Write([]byte{'\n'}); err != nil {
			return err
		}
		if end == len(content) {
			break
		}
		content = content[end+1:]
	}
	return nil
}
