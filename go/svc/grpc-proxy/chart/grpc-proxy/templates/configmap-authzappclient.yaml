# Code generated by protoauthzappclient. DO NOT EDIT.
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "idc-common.fullname" . }}-authzappclient
  namespace: {{ include "idc-common.namespace" . }}
data:
  authzappclient.rego: |
    package envoy.authz

    import future.keywords.in
    import input.attributes.request.http
    authz := {"scheme":scheme, "token":payload} {
     	[scheme, encoded] := split(http.headers.authorization, " ")
     	# The header and signature are ignored. The JWT has already been validated by
     	# the ingress. We are using the JWT for information about the caller, not for
     	# authentication.
     	[_, payload, _] := io.jwt.decode(encoded)
    }
         
    clientId := authz.token.client_id

    # Get current cloudaccount associated with access_token
    cloudAccount := cloudaccount.getAppClientCloudAccount(clientId)
    cloudAccountId := cloudAccount["id"]
     
    # getAppClientCloudAccount returns owner_email - if owner's token
    # getAppClientCloudAccount returns member_email - if member's token
    email := cloudAccount["name"]

    # countryCode of the user (owner or member)
    countryCode := cloudAccount["countryCode"]

    # get current user associated CloudAccounts
    response := cloudaccount.getRelatedCloudAccounts(email)
    relatedCloudAccounts := response["relatedAccounts"]

    result["allowed"] := allow

    result["body"] := "User is restricted" {
        method_ok
        not user_ok
        not allow
    }

    # product_ok and gts_ok enabled only in prod and staging
{{- if not (eq $.Values.environmentName "kind-idc-global") }}
    result["body"] := "product not found" {
        product_need_custom_body
        prod == {}
    }
    result["body"] := "paid service not allowed" {
        product_access_ok
        product_need_custom_body
        prod != {}
    }
    result["body"] := "product access not allowed" {
        need_product_match
        not product_access_ok
        prod != {}
    }
    result["body"] := "gts check failed" {
        need_gts_match
        method_ok
        user_ok
        product_ok
        product_access_ok
        not gts_ok
    }

    product_need_custom_body {
        need_product_match
        method_ok
        user_ok
        not product_ok
    }
{{- end }}

    default allow = false
    default prod = {}
    default need_product_match = false
    default need_gts_match = false
    default method_ok = false
    default user_ok = false
    default product_ok = false
    default product_access_ok = false

    # users allowed (owner or member)
    allow {
        email != ""
        method_ok
        user_ok
{{- if not (eq $.Values.environmentName "kind-idc-global") }}
        product_ok
        product_access_ok
        gts_ok
{{- end }}
    }

    # gts_ok by default for intel users
    gts_ok {
        endswith(email, "@intel.com")
    }

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Create"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    SshPublicKeyService_Create_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := SshPublicKeyService_Create_cloudAccount["personId"] if {
        # email belongs to an owner
        email == SshPublicKeyService_Create_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, SshPublicKeyService_Create_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Create"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not SshPublicKeyService_Create_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Create"]
    }



    product_access_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Create"]
    }

    gts_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Create"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Get"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    SshPublicKeyService_Get_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := SshPublicKeyService_Get_cloudAccount["personId"] if {
        # email belongs to an owner
        email == SshPublicKeyService_Get_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, SshPublicKeyService_Get_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Get"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not SshPublicKeyService_Get_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Get"]
    }



    product_access_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Get"]
    }

    gts_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Get"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Search"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    SshPublicKeyService_Search_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := SshPublicKeyService_Search_cloudAccount["personId"] if {
        # email belongs to an owner
        email == SshPublicKeyService_Search_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, SshPublicKeyService_Search_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Search"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not SshPublicKeyService_Search_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Search"]
    }



    product_access_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Search"]
    }

    gts_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Search"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Delete"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    SshPublicKeyService_Delete_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := SshPublicKeyService_Delete_cloudAccount["personId"] if {
        # email belongs to an owner
        email == SshPublicKeyService_Delete_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, SshPublicKeyService_Delete_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Delete"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not SshPublicKeyService_Delete_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Delete"]
    }



    product_access_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Delete"]
    }

    gts_ok {
        input.parsed_path == ["proto.SshPublicKeyService", "Delete"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.InstanceService", "Create"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    InstanceService_Create_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := InstanceService_Create_cloudAccount["personId"] if {
        # email belongs to an owner
        email == InstanceService_Create_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, InstanceService_Create_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.InstanceService", "Create"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not InstanceService_Create_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.InstanceService", "Create"]	
        # ProductNameField validation requires CloudAccountField
        prod["name"] != ""
        InstanceServiceCreate_product_ok
    }


    InstanceServiceCreate_product_access_ok {
        prod["access"] == "open"
    }

    InstanceServiceCreate_product_access_ok {
        checkProductAccess := productcatalog.checkProductAccess(input.parsed_body.metadata.productId, InstanceService_Create_cloudAccount["id"])
        checkProductAccess == true
    }


    product_access_ok {
        input.parsed_path == ["proto.InstanceService", "Create"]
            InstanceServiceCreate_product_access_ok
    }

    prod := pp {
        input.parsed_path == ["proto.InstanceService", "Create"]
        pp := productcatalog.getProductByName(input.parsed_body.spec.instanceType, InstanceService_Create_cloudAccount["type"])
    }

    need_product_match {
        input.parsed_path == ["proto.InstanceService", "Create"]
    }

    InstanceServiceCreate_product_ok {
        some ii
        to_number(prod.rates[ii].rate) == 0
    }

    InstanceServiceCreate_product_ok {
        InstanceService_Create_cloudAccount["paidServicesAllowed"]
    }

    gts_ok {
        input.parsed_path == ["proto.InstanceService", "Create"]
        # GTSCheckNameField validation requires CloudAccountField
        personId != ""
        countryCode != ""
        prodData["id"] != ""
        gts.isGTSOrderValid(prodData["id"], email, personId, countryCode)
    }

    prodData := pp {
        input.parsed_path == ["proto.InstanceService", "Create"]
        pp := productcatalog.getProductByName(input.parsed_body.spec.instanceType, InstanceService_Create_cloudAccount["type"])
    }

    need_gts_match {
        input.parsed_path == ["proto.InstanceService", "Create"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.InstanceService", "Get"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    InstanceService_Get_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := InstanceService_Get_cloudAccount["personId"] if {
        # email belongs to an owner
        email == InstanceService_Get_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, InstanceService_Get_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.InstanceService", "Get"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not InstanceService_Get_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.InstanceService", "Get"]
    }



    product_access_ok {
        input.parsed_path == ["proto.InstanceService", "Get"]
    }

    gts_ok {
        input.parsed_path == ["proto.InstanceService", "Get"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.InstanceService", "Search"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    InstanceService_Search_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := InstanceService_Search_cloudAccount["personId"] if {
        # email belongs to an owner
        email == InstanceService_Search_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, InstanceService_Search_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.InstanceService", "Search"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not InstanceService_Search_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.InstanceService", "Search"]
    }



    product_access_ok {
        input.parsed_path == ["proto.InstanceService", "Search"]
    }

    gts_ok {
        input.parsed_path == ["proto.InstanceService", "Search"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.InstanceService", "Delete"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    InstanceService_Delete_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := InstanceService_Delete_cloudAccount["personId"] if {
        # email belongs to an owner
        email == InstanceService_Delete_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, InstanceService_Delete_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.InstanceService", "Delete"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not InstanceService_Delete_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.InstanceService", "Delete"]
    }



    product_access_ok {
        input.parsed_path == ["proto.InstanceService", "Delete"]
    }

    gts_ok {
        input.parsed_path == ["proto.InstanceService", "Delete"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.InstanceTypeService", "Search"]
    }

    user_ok {
        input.parsed_path == ["proto.InstanceTypeService", "Search"]
    }

    product_ok {
        input.parsed_path == ["proto.InstanceTypeService", "Search"]
    }



    product_access_ok {
        input.parsed_path == ["proto.InstanceTypeService", "Search"]
    }

    gts_ok {
        input.parsed_path == ["proto.InstanceTypeService", "Search"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.MachineImageService", "Search"]
    }

    user_ok {
        input.parsed_path == ["proto.MachineImageService", "Search"]
    }

    product_ok {
        input.parsed_path == ["proto.MachineImageService", "Search"]
    }



    product_access_ok {
        input.parsed_path == ["proto.MachineImageService", "Search"]
    }

    gts_ok {
        input.parsed_path == ["proto.MachineImageService", "Search"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.VNetService", "Put"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    VNetService_Put_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := VNetService_Put_cloudAccount["personId"] if {
        # email belongs to an owner
        email == VNetService_Put_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, VNetService_Put_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.VNetService", "Put"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not VNetService_Put_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.VNetService", "Put"]
    }



    product_access_ok {
        input.parsed_path == ["proto.VNetService", "Put"]
    }

    gts_ok {
        input.parsed_path == ["proto.VNetService", "Put"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.VNetService", "Search"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    VNetService_Search_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := VNetService_Search_cloudAccount["personId"] if {
        # email belongs to an owner
        email == VNetService_Search_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, VNetService_Search_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.VNetService", "Search"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not VNetService_Search_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.VNetService", "Search"]
    }



    product_access_ok {
        input.parsed_path == ["proto.VNetService", "Search"]
    }

    gts_ok {
        input.parsed_path == ["proto.VNetService", "Search"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_CreateNewCluster_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_CreateNewCluster_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_CreateNewCluster_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_CreateNewCluster_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_CreateNewCluster_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]	
        # ProductNameField validation requires CloudAccountField
        prod["name"] != ""
        IksCreateNewCluster_product_ok
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
    }

    prod := pp {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
        pp := productcatalog.getProductByName(input.parsed_body.instanceType, Iks_CreateNewCluster_cloudAccount["type"])
    }

    need_product_match {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
    }

    IksCreateNewCluster_product_ok {
        some ii
        to_number(prod.rates[ii].rate) == 0
    }

    IksCreateNewCluster_product_ok {
        Iks_CreateNewCluster_cloudAccount["paidServicesAllowed"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
        # GTSCheckNameField validation requires CloudAccountField
        personId != ""
        countryCode != ""
        prodData["id"] != ""
        gts.isGTSOrderValid(prodData["id"], email, personId, countryCode)
    }

    prodData := pp {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
        pp := productcatalog.getProductByName(input.parsed_body.instanceType, Iks_CreateNewCluster_cloudAccount["type"])
    }

    need_gts_match {
        input.parsed_path == ["proto.Iks", "CreateNewCluster"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetClusters"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetClusters_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetClusters_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetClusters_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetClusters_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetClusters"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetClusters_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetClusters"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetClusters"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetClusters"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetCluster"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetCluster_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetCluster_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetCluster_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetCluster_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetCluster"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetCluster_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetCluster"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetCluster"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetCluster"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "UpgradeCluster"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_UpgradeCluster_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_UpgradeCluster_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_UpgradeCluster_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_UpgradeCluster_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "UpgradeCluster"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_UpgradeCluster_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "UpgradeCluster"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "UpgradeCluster"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "UpgradeCluster"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "EnableClusterStorage"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_EnableClusterStorage_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_EnableClusterStorage_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_EnableClusterStorage_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_EnableClusterStorage_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "EnableClusterStorage"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_EnableClusterStorage_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "EnableClusterStorage"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "EnableClusterStorage"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "EnableClusterStorage"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "DeleteCluster"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_DeleteCluster_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_DeleteCluster_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_DeleteCluster_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_DeleteCluster_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "DeleteCluster"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_DeleteCluster_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "DeleteCluster"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "DeleteCluster"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "DeleteCluster"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetClusterStatus"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetClusterStatus_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetClusterStatus_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetClusterStatus_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetClusterStatus_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetClusterStatus"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetClusterStatus_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetClusterStatus"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetClusterStatus"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetClusterStatus"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_CreateNodeGroup_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_CreateNodeGroup_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_CreateNodeGroup_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_CreateNodeGroup_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_CreateNodeGroup_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]	
        # ProductNameField validation requires CloudAccountField
        prod["name"] != ""
        IksCreateNodeGroup_product_ok
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
    }

    prod := pp {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
        pp := productcatalog.getProductByName(input.parsed_body.instanceType, Iks_CreateNodeGroup_cloudAccount["type"])
    }

    need_product_match {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
    }

    IksCreateNodeGroup_product_ok {
        some ii
        to_number(prod.rates[ii].rate) == 0
    }

    IksCreateNodeGroup_product_ok {
        Iks_CreateNodeGroup_cloudAccount["paidServicesAllowed"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
        # GTSCheckNameField validation requires CloudAccountField
        personId != ""
        countryCode != ""
        prodData["id"] != ""
        gts.isGTSOrderValid(prodData["id"], email, personId, countryCode)
    }

    prodData := pp {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
        pp := productcatalog.getProductByName(input.parsed_body.instanceType, Iks_CreateNodeGroup_cloudAccount["type"])
    }

    need_gts_match {
        input.parsed_path == ["proto.Iks", "CreateNodeGroup"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroup"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetNodeGroup_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetNodeGroup_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetNodeGroup_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetNodeGroup_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroup"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetNodeGroup_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroup"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroup"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroup"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "PutNodeGroup"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_PutNodeGroup_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_PutNodeGroup_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_PutNodeGroup_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_PutNodeGroup_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "PutNodeGroup"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_PutNodeGroup_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "PutNodeGroup"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "PutNodeGroup"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "PutNodeGroup"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "UpgradeNodeGroup"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_UpgradeNodeGroup_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_UpgradeNodeGroup_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_UpgradeNodeGroup_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_UpgradeNodeGroup_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "UpgradeNodeGroup"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_UpgradeNodeGroup_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "UpgradeNodeGroup"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "UpgradeNodeGroup"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "UpgradeNodeGroup"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroup"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_DeleteNodeGroup_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_DeleteNodeGroup_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_DeleteNodeGroup_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_DeleteNodeGroup_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroup"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_DeleteNodeGroup_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroup"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroup"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroup"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroupStatus"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetNodeGroupStatus_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetNodeGroupStatus_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetNodeGroupStatus_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetNodeGroupStatus_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroupStatus"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetNodeGroupStatus_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroupStatus"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroupStatus"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetNodeGroupStatus"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroupInstance"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_DeleteNodeGroupInstance_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_DeleteNodeGroupInstance_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_DeleteNodeGroupInstance_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_DeleteNodeGroupInstance_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroupInstance"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_DeleteNodeGroupInstance_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroupInstance"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroupInstance"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "DeleteNodeGroupInstance"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetPublicK8sVersions"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetPublicK8sVersions_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetPublicK8sVersions_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetPublicK8sVersions_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetPublicK8sVersions_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetPublicK8sVersions"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetPublicK8sVersions_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetPublicK8sVersions"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetPublicK8sVersions"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetPublicK8sVersions"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "RetrieveKubeConfig"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_RetrieveKubeConfig_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_RetrieveKubeConfig_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_RetrieveKubeConfig_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_RetrieveKubeConfig_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "RetrieveKubeConfig"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_RetrieveKubeConfig_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "RetrieveKubeConfig"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "RetrieveKubeConfig"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "RetrieveKubeConfig"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "CreateNewVip"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_CreateNewVip_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_CreateNewVip_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_CreateNewVip_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_CreateNewVip_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "CreateNewVip"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_CreateNewVip_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "CreateNewVip"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "CreateNewVip"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "CreateNewVip"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetVips"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetVips_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetVips_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetVips_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetVips_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetVips"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetVips_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetVips"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetVips"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetVips"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetVip"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetVip_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetVip_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetVip_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetVip_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetVip"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetVip_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetVip"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetVip"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetVip"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "UpdateFirewallRule"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_UpdateFirewallRule_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_UpdateFirewallRule_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_UpdateFirewallRule_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_UpdateFirewallRule_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "UpdateFirewallRule"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_UpdateFirewallRule_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "UpdateFirewallRule"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "UpdateFirewallRule"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "UpdateFirewallRule"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "GetFirewallRule"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_GetFirewallRule_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_GetFirewallRule_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_GetFirewallRule_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_GetFirewallRule_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "GetFirewallRule"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_GetFirewallRule_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "GetFirewallRule"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "GetFirewallRule"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "GetFirewallRule"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.Iks", "DeleteFirewallRule"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    Iks_DeleteFirewallRule_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := Iks_DeleteFirewallRule_cloudAccount["personId"] if {
        # email belongs to an owner
        email == Iks_DeleteFirewallRule_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, Iks_DeleteFirewallRule_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.Iks", "DeleteFirewallRule"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not Iks_DeleteFirewallRule_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.Iks", "DeleteFirewallRule"]
    }



    product_access_ok {
        input.parsed_path == ["proto.Iks", "DeleteFirewallRule"]
    }

    gts_ok {
        input.parsed_path == ["proto.Iks", "DeleteFirewallRule"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.cloudAccountId == relatedCloudAccount["id"]
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    MaasGateway_GenerateStream_cloudAccount := cloudaccount.getById(input.parsed_body.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := MaasGateway_GenerateStream_cloudAccount["personId"] if {
        # email belongs to an owner
        email == MaasGateway_GenerateStream_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, MaasGateway_GenerateStream_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not MaasGateway_GenerateStream_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]	
        # ProductNameField validation requires CloudAccountField
        prod["name"] != ""
        MaasGatewayGenerateStream_product_ok
    }


    MaasGatewayGenerateStream_product_access_ok {
        prod["access"] == "open"
    }

    MaasGatewayGenerateStream_product_access_ok {
        checkProductAccess := productcatalog.checkProductAccess(input.parsed_body.productId, MaasGateway_GenerateStream_cloudAccount["id"])
        checkProductAccess == true
    }


    product_access_ok {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
            MaasGatewayGenerateStream_product_access_ok
    }

    prod := pp {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
        pp := productcatalog.getProductByName(input.parsed_body.productName, MaasGateway_GenerateStream_cloudAccount["type"])
    }

    need_product_match {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
    }

    MaasGatewayGenerateStream_product_ok {
        some ii
        to_number(prod.rates[ii].rate) == 0
    }

    MaasGatewayGenerateStream_product_ok {
        MaasGateway_GenerateStream_cloudAccount["paidServicesAllowed"]
    }

    gts_ok {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
        # GTSCheckNameField validation requires CloudAccountField
        personId != ""
        countryCode != ""
        prodData["id"] != ""
        gts.isGTSOrderValid(prodData["id"], email, personId, countryCode)
    }

    prodData := pp {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
        pp := productcatalog.getProductByName(input.parsed_body.productName, MaasGateway_GenerateStream_cloudAccount["type"])
    }

    need_gts_match {
        input.parsed_path == ["proto.MaasGateway", "GenerateStream"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}

    method_ok {
        input.parsed_path == ["proto.MaasGateway", "GetSupportedModels"]
    }

    user_ok {
        input.parsed_path == ["proto.MaasGateway", "GetSupportedModels"]
    }

    product_ok {
        input.parsed_path == ["proto.MaasGateway", "GetSupportedModels"]
    }



    product_access_ok {
        input.parsed_path == ["proto.MaasGateway", "GetSupportedModels"]
    }

    gts_ok {
        input.parsed_path == ["proto.MaasGateway", "GetSupportedModels"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    FileStorageService_Create_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    FileStorageService_Create_authZResult := authzService.check(email, clientId,FileStorageService_Create_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.FileStorageService", "Create"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        FileStorageService_Create_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    FileStorageService_Create_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := FileStorageService_Create_cloudAccount["personId"] if {
        # email belongs to an owner
        email == FileStorageService_Create_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, FileStorageService_Create_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.FileStorageService", "Create"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not FileStorageService_Create_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.FileStorageService", "Create"]	
        # ProductNameField validation requires CloudAccountField
        prod["name"] != ""
        FileStorageServiceCreate_product_ok
    }



    product_access_ok {
        input.parsed_path == ["proto.FileStorageService", "Create"]
    }

    prod := pp {
        input.parsed_path == ["proto.FileStorageService", "Create"]
        pp := productcatalog.getProductByName(input.parsed_body.spec.instanceType, FileStorageService_Create_cloudAccount["type"])
    }

    need_product_match {
        input.parsed_path == ["proto.FileStorageService", "Create"]
    }

    FileStorageServiceCreate_product_ok {
        some ii
        to_number(prod.rates[ii].rate) == 0
    }

    FileStorageServiceCreate_product_ok {
        FileStorageService_Create_cloudAccount["paidServicesAllowed"]
    }

    gts_ok {
        input.parsed_path == ["proto.FileStorageService", "Create"]
        # GTSCheckNameField validation requires CloudAccountField
        personId != ""
        countryCode != ""
        prodData["id"] != ""
        gts.isGTSOrderValid(prodData["id"], email, personId, countryCode)
    }

    prodData := pp {
        input.parsed_path == ["proto.FileStorageService", "Create"]
        pp := productcatalog.getProductByName(input.parsed_body.spec.instanceType, FileStorageService_Create_cloudAccount["type"])
    }

    need_gts_match {
        input.parsed_path == ["proto.FileStorageService", "Create"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    FileStorageService_Get_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    FileStorageService_Get_authZResult := authzService.check(email, clientId,FileStorageService_Get_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.FileStorageService", "Get"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        FileStorageService_Get_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    FileStorageService_Get_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := FileStorageService_Get_cloudAccount["personId"] if {
        # email belongs to an owner
        email == FileStorageService_Get_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, FileStorageService_Get_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.FileStorageService", "Get"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not FileStorageService_Get_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.FileStorageService", "Get"]
    }



    product_access_ok {
        input.parsed_path == ["proto.FileStorageService", "Get"]
    }

    gts_ok {
        input.parsed_path == ["proto.FileStorageService", "Get"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    FileStorageService_Search_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    FileStorageService_Search_authZResult := authzService.check(email, clientId,FileStorageService_Search_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.FileStorageService", "Search"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        FileStorageService_Search_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    FileStorageService_Search_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := FileStorageService_Search_cloudAccount["personId"] if {
        # email belongs to an owner
        email == FileStorageService_Search_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, FileStorageService_Search_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.FileStorageService", "Search"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not FileStorageService_Search_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.FileStorageService", "Search"]
    }



    product_access_ok {
        input.parsed_path == ["proto.FileStorageService", "Search"]
    }

    gts_ok {
        input.parsed_path == ["proto.FileStorageService", "Search"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    FileStorageService_Update_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    FileStorageService_Update_authZResult := authzService.check(email, clientId,FileStorageService_Update_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.FileStorageService", "Update"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        FileStorageService_Update_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    FileStorageService_Update_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := FileStorageService_Update_cloudAccount["personId"] if {
        # email belongs to an owner
        email == FileStorageService_Update_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, FileStorageService_Update_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.FileStorageService", "Update"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not FileStorageService_Update_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.FileStorageService", "Update"]
    }



    product_access_ok {
        input.parsed_path == ["proto.FileStorageService", "Update"]
    }

    gts_ok {
        input.parsed_path == ["proto.FileStorageService", "Update"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    FileStorageService_Delete_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    FileStorageService_Delete_authZResult := authzService.check(email, clientId,FileStorageService_Delete_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.FileStorageService", "Delete"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        FileStorageService_Delete_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    FileStorageService_Delete_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := FileStorageService_Delete_cloudAccount["personId"] if {
        # email belongs to an owner
        email == FileStorageService_Delete_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, FileStorageService_Delete_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.FileStorageService", "Delete"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not FileStorageService_Delete_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.FileStorageService", "Delete"]
    }



    product_access_ok {
        input.parsed_path == ["proto.FileStorageService", "Delete"]
    }

    gts_ok {
        input.parsed_path == ["proto.FileStorageService", "Delete"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    FileStorageService_GetUser_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    FileStorageService_GetUser_authZResult := authzService.check(email, clientId,FileStorageService_GetUser_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.FileStorageService", "GetUser"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        FileStorageService_GetUser_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    FileStorageService_GetUser_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := FileStorageService_GetUser_cloudAccount["personId"] if {
        # email belongs to an owner
        email == FileStorageService_GetUser_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, FileStorageService_GetUser_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.FileStorageService", "GetUser"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not FileStorageService_GetUser_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.FileStorageService", "GetUser"]
    }



    product_access_ok {
        input.parsed_path == ["proto.FileStorageService", "GetUser"]
    }

    gts_ok {
        input.parsed_path == ["proto.FileStorageService", "GetUser"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    ObjectStorageService_CreateBucket_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    ObjectStorageService_CreateBucket_authZResult := authzService.check(email, clientId,ObjectStorageService_CreateBucket_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        ObjectStorageService_CreateBucket_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    ObjectStorageService_CreateBucket_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := ObjectStorageService_CreateBucket_cloudAccount["personId"] if {
        # email belongs to an owner
        email == ObjectStorageService_CreateBucket_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, ObjectStorageService_CreateBucket_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not ObjectStorageService_CreateBucket_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]	
        # ProductNameField validation requires CloudAccountField
        prod["name"] != ""
        ObjectStorageServiceCreateBucket_product_ok
    }



    product_access_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
    }

    prod := pp {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
        pp := productcatalog.getProductByName(input.parsed_body.spec.instanceType, ObjectStorageService_CreateBucket_cloudAccount["type"])
    }

    need_product_match {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
    }

    ObjectStorageServiceCreateBucket_product_ok {
        some ii
        to_number(prod.rates[ii].rate) == 0
    }

    ObjectStorageServiceCreateBucket_product_ok {
        ObjectStorageService_CreateBucket_cloudAccount["paidServicesAllowed"]
    }

    gts_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
        # GTSCheckNameField validation requires CloudAccountField
        personId != ""
        countryCode != ""
        prodData["id"] != ""
        gts.isGTSOrderValid(prodData["id"], email, personId, countryCode)
    }

    prodData := pp {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
        pp := productcatalog.getProductByName(input.parsed_body.spec.instanceType, ObjectStorageService_CreateBucket_cloudAccount["type"])
    }

    need_gts_match {
        input.parsed_path == ["proto.ObjectStorageService", "CreateBucket"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    ObjectStorageService_GetBucket_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    ObjectStorageService_GetBucket_authZResult := authzService.check(email, clientId,ObjectStorageService_GetBucket_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetBucket"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        ObjectStorageService_GetBucket_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    ObjectStorageService_GetBucket_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := ObjectStorageService_GetBucket_cloudAccount["personId"] if {
        # email belongs to an owner
        email == ObjectStorageService_GetBucket_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, ObjectStorageService_GetBucket_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetBucket"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not ObjectStorageService_GetBucket_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetBucket"]
    }



    product_access_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetBucket"]
    }

    gts_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetBucket"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    ObjectStorageService_DeleteBucket_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    ObjectStorageService_DeleteBucket_authZResult := authzService.check(email, clientId,ObjectStorageService_DeleteBucket_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteBucket"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        ObjectStorageService_DeleteBucket_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    ObjectStorageService_DeleteBucket_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := ObjectStorageService_DeleteBucket_cloudAccount["personId"] if {
        # email belongs to an owner
        email == ObjectStorageService_DeleteBucket_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, ObjectStorageService_DeleteBucket_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteBucket"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not ObjectStorageService_DeleteBucket_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteBucket"]
    }



    product_access_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteBucket"]
    }

    gts_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteBucket"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    ObjectStorageService_CreateObjectUser_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    ObjectStorageService_CreateObjectUser_authZResult := authzService.check(email, clientId,ObjectStorageService_CreateObjectUser_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateObjectUser"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        ObjectStorageService_CreateObjectUser_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    ObjectStorageService_CreateObjectUser_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := ObjectStorageService_CreateObjectUser_cloudAccount["personId"] if {
        # email belongs to an owner
        email == ObjectStorageService_CreateObjectUser_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, ObjectStorageService_CreateObjectUser_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateObjectUser"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not ObjectStorageService_CreateObjectUser_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateObjectUser"]
    }



    product_access_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateObjectUser"]
    }

    gts_ok {
        input.parsed_path == ["proto.ObjectStorageService", "CreateObjectUser"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    ObjectStorageService_GetObjectUser_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    ObjectStorageService_GetObjectUser_authZResult := authzService.check(email, clientId,ObjectStorageService_GetObjectUser_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetObjectUser"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        ObjectStorageService_GetObjectUser_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    ObjectStorageService_GetObjectUser_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := ObjectStorageService_GetObjectUser_cloudAccount["personId"] if {
        # email belongs to an owner
        email == ObjectStorageService_GetObjectUser_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, ObjectStorageService_GetObjectUser_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetObjectUser"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not ObjectStorageService_GetObjectUser_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetObjectUser"]
    }



    product_access_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetObjectUser"]
    }

    gts_ok {
        input.parsed_path == ["proto.ObjectStorageService", "GetObjectUser"]
    }
{{- end }}

{{- if or (eq $.Values.deployment "all") (eq $.Values.deployment "regional") }}
{{- if $.Values.authz.enabled }}
    ObjectStorageService_DeleteObjectUser_authZCloudAccountId := input.parsed_body.metadata.cloudAccountId
    ObjectStorageService_DeleteObjectUser_authZResult := authzService.check(email, clientId,ObjectStorageService_DeleteObjectUser_authZCloudAccountId,input.attributes.request.http.headers["x-original-http-path"],input.attributes.request.http.headers["x-original-http-method"],input.parsed_body)
{{- end }}

    method_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteObjectUser"]
        # enforce access to cloudaccount-specific resources
        some _, relatedCloudAccount in relatedCloudAccounts
        input.parsed_body.metadata.cloudAccountId == relatedCloudAccount["id"]
{{- if $.Values.authz.enabled }}
        ObjectStorageService_DeleteObjectUser_authZResult  == true
{{- end }}
    }
    # Store Service.Method.cloudAccount based on CloudAccountField
    ObjectStorageService_DeleteObjectUser_cloudAccount := cloudaccount.getById(input.parsed_body.metadata.cloudAccountId)

    # Store personId for gts-check if owner/member
    personId := ObjectStorageService_DeleteObjectUser_cloudAccount["personId"] if {
        # email belongs to an owner
        email == ObjectStorageService_DeleteObjectUser_cloudAccount["name"]
    } else := cloudaccount.getMemberPersonId(email, ObjectStorageService_DeleteObjectUser_cloudAccount["id"])

    user_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteObjectUser"]
        # admin will set restricted to true if this user needs to be restricted
        # use Service.Method.cloudAccount
        not ObjectStorageService_DeleteObjectUser_cloudAccount["restricted"]
    }

    product_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteObjectUser"]
    }



    product_access_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteObjectUser"]
    }

    gts_ok {
        input.parsed_path == ["proto.ObjectStorageService", "DeleteObjectUser"]
    }
{{- end }}
