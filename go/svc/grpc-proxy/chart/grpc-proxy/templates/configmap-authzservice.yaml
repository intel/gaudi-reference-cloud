# Code generated by protoauthzservice. DO NOT EDIT.
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "idc-common.fullname" . }}-authzservice
  namespace: {{ include "idc-common.namespace" . }}
data:
  authzservice.rego: |
    package envoy.authz

    import future.keywords.in
    import input.attributes.request.http

    default allow = false 
    result["allowed"] := allow

    authz := {"scheme":scheme, "token":payload} {
         [scheme, encoded] := split(http.headers["authorization"], " ")
         [_, payload, _] := io.jwt.decode(encoded)
     }

    scopes := split(authz.token.scope, " ")
        
    # For tracability/debugging
    result["scopes"] := scopes

    # TODO: move to .proto file definitions
    external_client_path_scopes_map := {
        "/proto.CloudCreditsCouponService/Read": "/coupons:view",
        "/proto.BillingCouponService/Read": "/coupons:view",
        "/proto.CloudCreditsCouponService/Create": "/coupons:create",
        "/proto.BillingCouponService/Create": "/coupons:create",
    }

    internal_client_scopes := [
        "/bucket-metering-monitor",
        "/compute-api-server", 
        "/iks-api-server",
        "/storage-admin-api-server",
        "/storage-api-server", 
        "/storage-metering-monitor", 
        "/storage-resource-cleaner",
        "/grpc-proxy", 
        "/write", # aria
        "/compute-metering-monitor",
        "/training-api-server",
        "internal/read"
    ]

    allow {
        some scope in scopes
        some internal_client_scope in internal_client_scopes
        contains(scope, internal_client_scope)
    }

    allow {
        required_scope := external_client_path_scopes_map[http.path]
        some i
        contains(scopes[i], required_scope)
    }
