// INTEL CONFIDENTIAL
// Copyright (C) 2023 Intel Corporation
syntax = "proto3";

package intel.storagecontroller.v1.weka;

import "buf/validate/validate.proto";
import "intel/storagecontroller/v1/common.proto";
import "intel/storagecontroller/v1/namespace.proto";

option go_package = "github.com/intel-innersource/applications.infrastructure.idcstorage.sds-controller/api/intel/storagecontroller/v1/weka";

// Service for working with Weka type filesystem, used to manage filesystems in storage.
// This service will only work with Weka cluster and will error out in all other cases.
service FilesystemService {
  // Query all Weka filesystems in Weka cluster, can be used with filters
  rpc ListFilesystems(ListFilesystemsRequest) returns (ListFilesystemsResponse) {}

  // Get filesystem in Weka cluster by it ID
  rpc GetFilesystem(GetFilesystemRequest) returns (GetFilesystemResponse) {}

  // Attempts to create new Weka Filesystem in the cluster
  rpc CreateFilesystem(CreateFilesystemRequest) returns (CreateFilesystemResponse) {}

  // Updates Weka Filesystem parameters in the cluster
  rpc UpdateFilesystem(UpdateFilesystemRequest) returns (UpdateFilesystemResponse) {}

  // Deletes Weka Filesystem from the cluster
  rpc DeleteFilesystem(DeleteFilesystemRequest) returns (DeleteFilesystemResponse) {}
}

message ListFilesystemsRequest {
  // ID of the namespace to list filesystems in
  NamespaceIdentifier namespace_id = 1 [(buf.validate.field).required = true];

  // Filter can be used to select filesystems by properties
  Filter filter = 2;

  message Filter {
    // List of names filter filesystems by
    repeated string names = 1;
  }

  // User Auth context who has access to namespace, Admin level role required
  AuthenticationContext auth_ctx = 100;
}

message ListFilesystemsResponse {
  // Lists all found filesystems
  repeated Filesystem filesystems = 1;
}

message GetFilesystemRequest {
  // ID of the filesystem
  FilesystemIdentifier filesystem_id = 1 [(buf.validate.field).required = true];

  // User auth context should be able to query filesystem params
  AuthenticationContext auth_ctx = 100;
}

message GetFilesystemResponse {
  // If filesystem is found, returns `Filesystem` object
  Filesystem filesystem = 1;
}

message CreateFilesystemRequest {
  // ID of the namespace in which `Filesystem` should be created
  NamespaceIdentifier namespace_id = 1 [(buf.validate.field).required = true];

  // Name of the filesystem, used to mount it to the machine
  string name = 2 [(buf.validate.field).string.min_len = 1];

  // Total amount of bytes allocated for the filesystem
  uint64 total_bytes = 3;

  // Is `Filesystem` needs to be encrypted
  bool encrypted = 4;

  // Is authentication required to mount filesystem
  bool auth_required = 5;

  // User Auth context, Admin level role required for the namespace to create `Filesystem`
  AuthenticationContext auth_ctx = 100;
}

message CreateFilesystemResponse {
  // Created filesystem
  Filesystem filesystem = 1;
}

// Update request contains optinal fields for all of them starts with `new_`, prefix
// if field is not specified this param will not be updated/touched.
message UpdateFilesystemRequest {
  // ID of the filesystem to update
  FilesystemIdentifier filesystem_id = 1 [(buf.validate.field).required = true];

  // New name of the filesystem
  optional string new_name = 2;

  // New allocated bytes fot the filesystem
  optional uint64 new_total_bytes = 3;

  // Is Auth requried
  optional bool new_auth_required = 4;

  // User Auth context, Admin level role required for the namespace to update `Filesystem`
  AuthenticationContext auth_ctx = 100;
}

message UpdateFilesystemResponse {
  // Updated filesystem
  Filesystem filesystem = 1;
}

message DeleteFilesystemRequest {
  // ID of the filesytem to delete
  FilesystemIdentifier filesystem_id = 1 [(buf.validate.field).required = true];

  // User Auth context, Admin level role required for the namespace to delete `Filesystem`
  AuthenticationContext auth_ctx = 100;
}

message DeleteFilesystemResponse {}

// ID of the filesystem, composite type, namespace bound
message FilesystemIdentifier {
  // ID of the namespace filesystem part of
  NamespaceIdentifier namespace_id = 1 [(buf.validate.field).required = true];

  // ID of the filesystem, usualy are uuid/id value, but can be any arbitrary string
  string id = 2 [(buf.validate.field).string.min_len = 1];
}

message Filesystem {
  // ID of the filesystem
  FilesystemIdentifier id = 1 [(buf.validate.field).required = true];

  // Name of the filesystem, used to mount
  string name = 2 [(buf.validate.field).required = true];

  // Current status of the filesystem
  Status status = 3;

  // Is filesystem encrypted
  bool is_encrypted = 4;

  // Is authentication required to mount filesystem
  bool auth_required = 5;

  // Capacity metrics of the filesystem
  Capacity capacity = 6;

  // Filesystem backend uri, required to mount filesystem with weka cli
  string backend = 7 [(buf.validate.field).required = true];

  enum Status {
    STATUS_UNSPECIFIED = 0;

    // Filesystem is creating, cannot be mount
    STATUS_CREATING = 1;

    // Filesystem is ready and can be mounted
    STATUS_READY = 2;

    // Filesystem is deleting, cannot be mounted/modified
    STATUS_REMOVING = 3;
  }

  message Capacity {
    // Total amount of allocated bytes for the filesystem
    uint64 total_bytes = 1;

    // Bytes available in the filesystem to be used
    uint64 available_bytes = 2;
  }
}
